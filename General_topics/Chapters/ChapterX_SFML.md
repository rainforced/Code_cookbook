# Chapter X SFML
**SFML** (с англ. «Simple and Fast Multimedia Library» = «Простая и быстрая мультимедийная библиотека») - свободная кроссплатформенная мультимедийная библиотека, написанная на C++, но также доступна и для C, C#, .Net, D, Java, Python, Ruby, OCaml, Go и Rust. Представляет собой объектно-ориентированный аналог SDL. На ней можно писать 2D графические приложения.
## Создание проекта и добавление зависемостей
Подробнее [тут](https://ravesli.com/graficheskaya-biblioteka-sfml-vstuplenie-i-ustanovka/). Последовательность действий:
1. подключить каталог заголовочных и исходных файлов SFML (/include);
2. подключить каталог библиотечных файлов SFML (/lib);
3. подключить библиотечные файлы SFML в качестве дополнительных зависимостей;
4. скопировать .dll файлы в проект.

## Скелет программы
```cpp
#include <SFML/Graphics.hpp>

int main()
{
	// Объект, который, собственно, является главным окном приложения
	sf::RenderWindow window(sf::VideoMode(1200, 600), "SFML Works!");
	// Главный цикл приложения. Выполняется, пока открыто окно
	while (window.isOpen())
	{
		// Обрабатываем очередь событий в цикле
		sf::Event evnt; 	//event - это зарезервированное слов в С++, поэтому лучше использовать, например, evnt
		while (window.pollEvent(evnt))
		{
			// Пользователь нажал на «крестик» и хочет закрыть окно?
			if (evnt.type == sf::Event::Closed)	//или evnt.type == evnt.Closed (тоже самое)
				// Тогда закрываем его
				window.close();
		}
		window.clear(Color(250, 220, 100, 0));
		// Отрисовка окна	
		window.display();
	}

	return 0;
}
```
- `RenderWindow window(VideoMode(1200, 600), "SFML Works!");` - окно выводимое на экран - это объект класса RenderWindow. Тут `VideoMode(1200, 600)` - класс задающий размеры окна, `"SFML Works!"` - название окна. Все взаимодействия в с окном производятся над объектом  window. Например, `window.display();` - вызывает отрисовку окна. `window.close();` - закрытие окна. Третьим параметром тут идет `sf::Style` (если он не указан явно то это default) - это параметор отвечающий за кнопки окна (Close - только крестик, Resize - дает возможность менять размер окна и тд). Чтобы указать сразу несколько параметров нужно использовать bitiwse OR: `..., sf::Style::Close | sf::Style::Resize)`.      

Основные циклы программы:
- `while (window.isOpen()){...}` - главный loop. Тут обрабатываются все действия между последовательными отрисовками. 
- `while (window.pollEvent(event))` - loop обработки событий. Он последовательно "вытягивает" event из очериди событий. `pollEvent(event)` - "вытягивание" события. `event.type == Event::Closed` - если нажали на крестик, то это событие ::Closed.

Далее идет отрисовка окна и объектов на нем:
- `window.clear(Color(250, 220, 100, 0));` - заливка окна цветом заданным объектом Color. `(Color(R, G, B, alpha));` - цвет задается через RGB и aplha (уровень прозрачности). По дефолту (`window.clear()`) цвет - черный. Буфер не чистится автоматически, поэтому **нужно самостоятельно вызывать `window.clear()` каждый цикл** перед отрисовкой. 
- `window.display();` идет последней тк она отображает конечный вариант фрейма. Если мы хотим нарисовать что-то в окне это все должно быть до window.display(). Например, мы рисуем круг:
	```cpp
	CircleShape circle(50.f); 	// Создаём фигуру: круг радиусом 50
	circle.setFillColor(Color(230, 0, 230)); // Закрашиваем накруг 
	window.draw(circle); 		// <- добавляем объект в данный фрейм перед отрисовкой		
	window.display();		// Отрисовка окна
	```
## Обработка событий (Window events)
Можно обработывать события используя if ветвление, как показано в примере скелета программы, однако удобнее использовать switch для этой цели:
```cpp
//внутри while (window.isOpen()) 
while (window.pollEvent(evnt))
{
	switch(evnt.type)
	{
		case sf::Event::Closed:
			window.close();
			break;
		case sf::Event::Resize:
			//тк объект  window выходит поверх терминала, то можно использовать и его тоже
			std::cout << "Window size now is: " << evnt.size.width << " width, " 
			<< evnt.size.height << "height" << std::endl;
			break;
	}
}
```

## (Некоторые) события
### Text event
Событие считывания символа введенного с клавиатуры.
```cpp
//внутри while (window.isOpen()) 
	//внутри while (window.pollEvent(evnt))
		switch (evnt.type)
		{
			case sf::Event::TextEntered:
				if (evnt.text.unicode < 128)
					std::cout << (char)evnt.text.unicode;	//возвращает ASCII число
				break;
		}
```

## Keyboard
### Нажатие клавиши
- `sf::Keyboard::isKeyPressed(sf::Keyboard::Key::A)` - вернет true в момент, когда клавиша A нажата. Данная ф-ция не требует обработки событий. В `sf::Keyboard::Key::` прописаны все клавиши.       

Пример использования:
```cpp
//внутри while (window.isOpen()) 
	if(sf::Keyboard::isKeyPressed(sf::Keyboard::Key::A)
		character.move(-0.1f, 0.0f);
	if(sf::Keyboard::isKeyPressed(sf::Keyboard::Key::D)
		character.move(0.1f, 0.0f);
	if(sf::Keyboard::isKeyPressed(sf::Keyboard::Key::W)
		character.move(0.0f, -0.1f);
	if(sf::Keyboard::isKeyPressed(sf::Keyboard::Key::S)
		character.move(0.0f, 0.1f);
```

## Mouse 
- `sf::Mouse::isButtonPressed(sf::Mouse::Left)` - вернет true в момент, когда нажата левая кнопка мыши. 
- `sf::Vector2i mousePos = sf::Mouse::getPosition()` - возвращает Vector2i позицию мыши отностительно экрана компьютера (не окна SFML, а окна операционной системы). Чтобы получить позицию относительно окна SFML нужно передать в эту ф-цию объект window:  `sf::Mouse::getPosition(window)`.      

Пример использования:
```cpp
if(sf::Mouse::isButtonPressed(sf::Mouse::Left)
{
	sf::Vector2i mousePos = sf::Mouse::getPosition(window);	//возвращает int вектор
	character.move((float)mousePos.x, (float)mousePos.y);	//преобразование типа нужно тк .move() принимает float
}
```

# Объекты на экране
-------------------------------------------------------------------------
## Общие замечания
### Положение объекта на экране
- **setOrigin** - устанавливает точку отсчета объкета. Относительно нее будут совершаться перемещения этого объекта. По дефолту - это верхний левый угол объекта. Например, `rect.setOrigin(width/2.0f, height/2.0f)` - поставит точкой отсчета середину объекта rect.
 
### Перемещение объкта
- **setPosition** и **move**. `sprite.setPosition(10.f, 30.f)` - это *абсолютный* сдвиг (те сдвиг относительно левого угла окна).  `sprite.move(10.f, 30.f)` - *относительный* сдвиг (относительно данной позиции объекта).
- **setRotation** и **rotate**.  `sprite.setRotation(45.f)` - абсолютный поворот в 45 градусов. `sprite.rotate(45.f)` - относительный поворот.


## Простые фигуры 
### Круги и многоугольники (CircleShape)
Для рисования кругов используется класса `CircleShape`. Его конструктор принимает диаметр и кол-во углов у фигуры (по дефолту 30, тк при 30 угралах фигура малотличима от круга). С помощью этого класса можно нарисовать любую симетричную фигуру.
```cpp
// Создаём круг радиусом 50
CircleShape circle(50.f);	//по дефолту кол-во углов = 30, что соответствует кругу
circle.setFillColor(Color(230, 0, 230)); // закрашиваем наш круг. Можно добавить 4й параметр Color - прозрачность
circle.setOutlineThickness(15.f); // устанавливаем толщину контура круга
circle.setOutlineColor(Color(80,220,50)); // устанавливаем цвет контура
circle.move(15, 15); // перемещаем наш круг для корректного отображения в окне
window.draw(circle); // отрисовка круга	
// Создаём треугольник
CircleShape triangle(65.f, 3);
triangle.setPosition(125, 0); // устанавливаем начальную позицию справа от круга
triangle.setFillColor(Color::Blue); // устанавливаем цвет треугольника - синий
window.draw(triangle); // отрисовка треугольника
// Создаём квадрат
CircleShape square(60.f, 4);
square.setPosition(250, 0); // устанавливаем начальную позицию справа от треугольника
square.setFillColor(Color::Red); // устанавливаем цвет квадрата - красный
window.draw(square); // отрисовка квадрата
// Создаём октагон
CircleShape octagon(60.f, 8);
octagon.setPosition(380, 0); // устанавливаем начальную позицию справа от квадрата
octagon.setFillColor(Color::Cyan); // устанавливаем цвет октагона - бирюзовый
window.draw(octagon); // отрисовка октагона
```
### Выпуклые многоугольники (ConvexShape)
Нарисоварить многоугольник можно с помощью класса `ConvexShape`. Объекту этого класса надо задать кол-во точек используя метод `.setPointCount(int n)`, а затем задать положение в окне `.setPoint(0, Vector2f(0.f, 0.f))`: 1е число - это номер точки, координаты вершин задаются в виде контейнера `Vector2f(a, b)`. Данный контейнер — это простой шаблонный класс библиотеки SFML (есть также `Vector2i(a, b)` - int и `Vector2u(a, b)` - unsigned int). 
```cpp
ConvexShape convex;
// Устанавливаем ему 5 вершин
convex.setPointCount(5);
// Устанавливаем координаты вершин
convex.setPoint(0, Vector2f(0.f, 0.f));
convex.setPoint(1, Vector2f(150.f, 10.f));
convex.setPoint(2, Vector2f(120.f, 90.f));
convex.setPoint(3, Vector2f(30.f, 100.f));
convex.setPoint(4, Vector2f(5.f, 50.f));

convex.setFillColor(Color::Black); // Устанавливаем цвет многоугольника - чёрный
convex.move(1, 150); // Теперь сдвинем его вниз и чуть-чуть вправо
 
window.draw(convex); // Отрисовка многоугольника
```
*Примечание:* Порядок, в котором вы будете определять точки многоугольника, очень важен. Все они должны быть определены либо по часовой стрелке, либо против часовой стрелки. Если вы будете определять их в несогласованном порядке, то форма многоугольника будет построена неправильно.

### Прямоугольник (RectangleShape)
Для рисования прямоугольников используется класс `RectangleShape`, конструктор которого принимает ширину и высоту (в формате Vector2f(a, b). 
```cpp
RectangleShape rectangle(Vector2f(70.f, 100.f));
rectangle.move(165, 150); // Перемещаем его в нижний ряд справа от многоугольника
rectangle.setFillColor(Color(175, 180, 240)); // Устанавливаем ему цвет
rectangle.rotate(45.f); // Поворачиваем его на 45 градусов
```

### Сглаживание 
Нет возможности сделать сглаживание для отдельной фигуры. Сглаживание осуществляется для все всех фигур одновременно.
```cpp
// Устанавливаем 8-ой уровень сглаживания
ContextSettings settings;
settings.antialiasingLevel = 8;
```
## Текстуры и спрайты
- `Texture` - класс для текстур. Его основные задачи - это 1) загрузка текстуры в программу и 2)"натягивание" текстуры на спрайт.
- `Sprite` - класс для спрайтов.      
```cpp
Texture texture; // Объявляем переменную текстуры
texture.loadFromFile("path"); // Подгружаем нашу текстуру из файла 
Sprite sprite(texture); // Создаём спрайт и устанавливаем ему нашу текстуру
window.draw(sprite); // Отрисовка спрайта
```
В этом случаи получим прямоугольный спрайт. Ф-ция загрузки спрайта возвращает bool значение успешности загрузки, таким образом можно проверить загрузилась ли текстура: 
```cpp
if (!texture.loadFromFile("image.png"))
{
    // error...
}
```

### Текструа на фигурах разной формы
Для этого нужно создать одну из простых фигур, а затеме применить на нее текстуру. При этом, фигура и текстура как бы совмещаются своими квадратами (те левые углы их квадратов накладываются). Например,
```cpp
.loadFromFile("C:\\Users\\twist\\Downloads\\svbbbdi4_2.jpg");
CircleShape sphere(50.0f);
sphere.setTexture(&texture);
```
Чтобы подогнать нужную часть текстуры надо 1) либо вырезать нужный кусок текстуры из изображения. Например, следующий код загружает небольшой кусочек текстуры размером 32×32 пикселя, начинающийся с координат (10;10):          
```cpp
texture.loadFromFile("image.png", IntRect(10, 10, 32, 32));
```  
2) либо для самой фигуры вырезать нужную часть из поной текстуры: 
```cpp
sphere.setTextureRect(sf::IntRect(10, 10, 100, 100));
```

### Сглаживание    
Спрайт можно сгладить используя метод  `texture.setSmooth(true)`. В этом случаи  не бут видно "острых" пикселей, но текстура может стать мыльной (чем больше спрайт, тем сильнее заметно).      

### Покрасить спрайт   
На спрайт можно наложить цвет, тогда текструра "покрасится". Например, `sprite.setColor(Color(255, 255, 255, 128));`.      

### Транформации спрайта
Есть несколько групп трансформаций:
1. **setPosition** и **move**. `sprite.setPosition(10.f, 30.f)` - это *абсолютный* сдвиг (те сдвиг относительно левого угла окна).  `sprite.move(10.f, 30.f)` - *относительный* сдвиг (относительно данной позиции объекта).
2. **setRotation** и **rotate**.  `sprite.setRotation(45.f)` - абсолютный поворот в 45 градусов. `sprite.rotate(45.f)` - относительный поворот.
3. **setScale** и **scale**. `sprite.setScale(0.3f, 0.9f)` - абсолютное маштабирование. `sprite.scale(0.3f, 0.9f)` - относительное маштабирование.       

По дефолту точка отсчета объекта стоит в его левом углу. Можно изменить ее с помощью команды: `sprite.setOrigin(25.f, 25.f)`.
