# week 2: сети и aiohttp
## 1. А как гуглить? 
Что происходит, когда мы отправляем поисковый запрос в браузере

    Представьте: вы налили себе кофе, сели за компьютер и решили наконец-то поменять свою жизнь. Вводите в поисковую строку своего любимого браузера Chrome, с включенной по умолчанию поисковой системой Google, фразу «зарплаты python-разработчиков» и ждете загрузки страницы. Что происходит в это время?

1. При нажатии кнопки Enter браузер выполняет преобразование вашего запроса примерно в такой url-адрес: `https://www.google.com/search?q=%D0%B7%D0%B0%D1%80%D0%BF%D0%BB%D0%B0%D1%82%D1%8B+python-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%BE%D0%B2&oq=%D0%B7%D0%B0%D1%80%D0%BF%D0%BB%D0%B0%D1%82%D1%8B+python-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%BE%D0%B2&aqs=chrome.0.69i59j0i22i30.936j0j7&sourceid=chrome&ie=UTF-8`
В этом адресе можно выделить:
   - протокол взаимодействия `https`    
   - домен `www.google.com`   
   - путь запроса `/search`   
   - набор параметров, представленных как ключ=значение и разделенных амперсандом (&).
   - Значение ключа q — наш поисковый запрос, в котором браузер заранее приводит все кириллические символы из запроса к unicode-стандарту, то есть преобразует к UTF-8-кодировке, чтобы отвязаться от кодировки пользователя (кодировка, кстати, видна в параметре ie).
   - Также браузер добавляет некоторую техническую информацию: sourceid — браузер, из которого был отправлен запрос, и aqs.

2. Каждый домен связан с одним или несколькими IP-адресами, которые представляют собой уникальный номер сетевого компонента в Сети. IP-адрес можно утрировано представить как адрес дома, сам сайт как дом, а домен как название дома в «народе». 
Например: Домен — «Дом-сороконожка» , адрес — Россия, Москва, Беговая, 34. 
Нельзя отправить письмо в «Дом-сороконожку», но можно на Беговую, 34. Поэтому браузеру необходимо узнать, какой IP-адрес скрывается за доменным именем.
Прежде всего, браузер смотрит на настройки пользователя, например, на файл /etc/hosts для Linux, где пользователь может руками задать некоторый IP-адрес для домена. Иногда это необходимо для разработки, например — в закрытых сетях, когда нет другой возможности получить IP-адрес сайта.
Далее браузер проверяет: посещался ли этот сайт ранее и есть ли запись о его IP-адресе в так называемом DNS-кэше. У каждого доменного имени есть параметр **TTL — Time To Live**, который обозначает срок хранения кэшированного домена. Если TTL превышен, то браузер удаляет этот домен из кэша и идет новую информацию у DNS-провайдера.
Если адреса в DNS-кэше нет, то браузер обращается к заданным в настройках DNS-провайдерам. DNS расшифровывается как Domain Name System и представляет собой ряд серверов, в которых есть таблица сопоставления домена и IP-адреса. Если на выбранном сервере нет информации о домене, то эта информация запрашивается с другого DNS-сервера и так далее, пока не найдется.

3. Итак, мы готовы… Но стойте! Что значит буква s на конце привычного http-протокола? Она значит, что необходимо настроить протокол шифрования между клиентом и сервисом. Для этого используется протокол TLS или устаревший SSL, то есть https = HTTP + SSL(TSL). TLS и SSL предполагают под собой асимметричное шифрование, главная цель которого — не передавать ключ к расшифровке по сети, поэтому для его настройки используется так называемое TLS-рукопожатие. Подробнее почитать о TLS можно тут. 


4. На картинке с TLS-рукопожатием видно три голубых блока, рядом с которыми написано TCP. Это Transmission Control Protocol, который используется для установки канала для передачи сообщений. Для того чтобы настроить его, применяется так называемое трехстороннее рукопожатие (на картинке это рукопожатие как-раз показано тремя голубыми блоками). TCP-канал гарантирует доставку сообщения до адресата и доставку этих сообщений ровно в том порядке, в котором они были отправлены. 
Например, вы отправили сообщение другу, а какой-нибудь маршрутизатор отключился и потерял его. Тогда подтверждение получения сообщения от друга не придет, и вы отправите сообщение повторно с тем же номером.
В разговоре про DNS мы упомянули протокол UDP — это неряшливый, но быстрый брат TCP. Он не устанавливает соединение, а сразу идет к цели, не тратя времени на всякие формальности. Если вы проводите банковскую транзакцию, то лучше положиться на более медленный, но надежный TCP, а когда стримите видео, то потеря одного кадра не так важна, как общая скорость стрима, поэтому лучше выбрать UDP.
Итак, при установке TLS уже было выполнено трехсторонее TCP-рукопожатие и теперь у нас есть надежный канал связи.

5. Мы готовы к формированию HTTP-запроса. HTTP расшифровывается как Hyper Text Transfer Protocol, то есть протокол для передачи гипертекста. В самой часто используемой на сегодняшний день версии этого протокола HTTP/1.1 информация представлена в текстовом виде, то есть ее можно прочитать не только роботам, но и обычным человекам. Наш запрос к Google преобразовался в такой вид (для наглядности параметры запроса обрезаны):

    ```
    GET /search?sourceid=chrome&ie=UTF-8 HTTP/1.1
    Host: www.google.com
    User-Agent: Chrome/90.0.4430.85
    Accept-Language: en-GB,en;q=0.9,ru-RU;q=0.8,ru;q=0.7,en-US;q=0.6,la;q=0.5
    …
    ```
    Первая строчка начинается со слова GET — это метод HTTP-запроса, о них пойдет речь в следующих карточках. После нее указан наш путь с передаваемыми параметрами, а затем версия протокола: HTTP/1.1.
    На второй строчке указан наш домен, то есть Host — это то, куда мы должны отправить наш запрос.
    В следующих строчках идет ряд заголовков. Эта специальная информация, которая передается в виде ключ/значение. 
    Например:
    С помощью заголовка User-Agent мы говорим сайту, с какого браузера и устройства мы отправили этот запрос — чтобы, например, открыть мобильную версию сайта, если зашли с телефона.
    С помощью Accept-Language — говорим, что хотим только русско- и англоязычные сайты в поисковой выдаче. О заголовках мы еще поговорим дальше.

6. Помните, на этапе установки защищенного соединения был также настроен TCP-канал с помощью трехстороннего рукопожатия? Чтобы воспользоваться этим каналом для отправки HTTP-запроса, необходимо преобразовать запрос в TCP-пакет. Для этого HTTP-данные преобразуются в бинарный вид и кладутся в поля для данных TCP-пакета. В TCP-пакете уже указан порядковый номер этого пакета относительно созданного TСP-канала, контрольная сумма, а также порт, на который должен прийти запрос. 


    **Порт** — это виртуальный шлюз принимающей стороны, который обычно пишется в конце доменного имени.
    Продолжая аналогию с IP-адресом как адресом дома, можно сказать что порт — это номер квартиры, в которой могут обработать отправляемый запрос. Каждый порт можно назначить какому-нибудь сервису, например, порт под номером 80 отдать под ответы на HTTP-запросы, а порт 587 под отправку электронной почты.    
    Благодаря портам один физический сервер может обрабатывать множество протоколов, приходящих по одному и тому же сетевому кабелю. Принято, что протокол HTTP работает на порту 80, а, например, HTTPS — на 443.

7. Далее необходимо упаковать TCP-пакет в IP-пакет, добавив данные о своем IP-адресе и об IP-адресе получателя. Данные TCP пакета также кладутся в место для данных в IP-пакете.


8. После этого IP-пакет инкапсулируется в Ethernet-кадр, в котором указан физический MAC-адрес устройства, которому адресована эта информация. 


9. После этого Ethernet-пакет в виде световых сигналов или радиоволн, побитово, передается по сети и доходит до получателя с помощью сложной системы хабов, коммутаторов и маршрутизаторов.
Процесс превращения HTTP-запроса в набор физических сигналов называется инкапсуляцией.

10. Получив запрос, сервер Google выполняет обратное преобразование набора световых пучков или электрических сигналов в HTTP-запрос, повторяя всю последовательность шагов с 5 по 8, но в обратном направлении, выполняя деинкапсуляцию. По полученному тексту запроса веб-сервис выполняет необходимую работу и формирует данные для ответа, в нашем случае — список результатов поиска по запросу «зарплаты python-разработчиков».

11. Создается HTTP-ответ, который выглядит примерно таким образом:
    ```
    HTTP/1.1 200 OK
    Server: gws
    Date: Sun, 10 Oct 2021 23:26:07 GMT
    Accept-Ranges: bytes
    Сontent-Type: text/html; charset=UTF-8
    Content-Length: 12
    <html>
    …
    ```
    На первой строке указана версия протокола (HTTP/1.1), статус ответа (200) и текстовое описание статуса (OK). О статусах ответа мы поговорим позже.
    Далее идет ряд заголовков, несущих информацию, например, о типе данных в ответе (Content-Type) и об их длине (Content-Length).

12. Происходит точно такая же инкапсуляция HTTP-ответа, как и в случае HTTP-запроса, но уже на сервере Google и ответ отправляется обратно к клиенту.

13. Браузер пользователя обрабатывает HTTP-ответ и, используя свой графический движок, отрисовывает html-разметку. Мы видим страницу с поисковой выдачей.
Такой путь проходит HTTP-запрос. Не пугайтесь его сложности: для работы backend-разработчика обычно достаточно понимания протокола HTTP — это покрывает практически все задачи, которые могут возникнуть в процессе разработки.

    Далее мы более детально рассмотрим самые важные в разработке вещи, касающиеся сетевого взаимодействия в целом и HTTP-протокола в частности.


## 2. POST или PUT?
Что такое методы HTTP-запроса и когда и какой нужно использовать

    Для совершения HTTP-запроса необходимо указать его метод. В предыдущей части мы использовали метод GET для поиска информации с помощью Google.
Метод — одно из нескольких слов, которые используются для того, чтобы уточнить, что хочет сделать клиент (например, браузер). Рассмотрим их подробнее:    
- GET — клиент хочет получить какую-то информацию. Например, запросить профиль пользователя в соцсети.
- POST — клиент хочет создать какую-то информацию. Например, создать запрос в друзья
- PUT — клиент хочет изменить какую-то информацию. Например, отредактировать номер телефона в профиле.
- DELETE — клиент хочет удалить какую-то информацию. Например, альбом с фотографиями.
- PATCH — клиент хочет изменить часть какой-то информации. Например, удалить одну фотографию из альбома.
- HEAD — клиент хочет получить только заголовки. Например, чтобы проверить, изменилась ли информация с последнего посещения ресурса, не загружая заново даннные.
- OPTIONS — клиент хочет узнать, сможет ли сервер обработать его запрос. Например, принимает ли сервер запросы с методом POST.
- Существуют также методы TRACE и CONNECT, но их используют очень редко.

### Как использовать методы?     
    Допустим, вы делаете виртуальный список покупок в магазине в виде веб-сервиса. Этот веб-сервис должен уметь показывать список покупок, получать информацию о заданной покупке, удалять покупку из списка, изменять данные о какой-то конкретной покупке. Используя HTTP-методы, можно сделать так, что нужно всего два url-пути, чтобы реализовать все 5 функций списка.
Если наш веб-сервер работает на домене список-покупок.рф. Если мы пошлем по url-адресу `список-покупок.рф/pokupki...`
GET-запрос, то выведется список всех покупок с определенными уникальными идентификаторами (id):    
    1 / молоко   
    2 / хлеб   
    3 / лучок       
 
POST-запрос с названием новой покупки, то создастся новый элемент списка:   
    1 / молоко   
    2 / хлеб   
    3 / лучок   
    4 /   

Теперь добавим id-продукта в url-адрес, например: `список-покупок.рф/pokupki/2`.
Если отправить GET-запрос, можно получить информацию о конкретной покупке из списка, в данном случае о хлебе.
Если отправить PUT-запрос, можно изменить покупку из списка, например переименовать «хлеб» в «хлебушек»
Если отправить DELETE-запрос, можно удалить покупку из списка.

### Итоги
существует несколько HTTP-методов, каждый из которых обладает своей общепринятой семантикой. Любой метод можно использовать для любой цели, но всем будет понятнее, если семантика метода будет соответствовать выполняемой цели.

## 3. Зачем нужны заголовки?
Заголовки представляют собой строковую пару **ключ-значение** и являются частью HTTP-протокола.    

Их можно передавать с любым запросом, и чаще всего они несут некоторую общую информацию, нужную для нескольких запросов. Чаще всего заголовки используются для передачи информации о клиенте (браузер, система и т.д.), об авторизации клиента и об особенностях передаваемого контента (тип, размер и т.д.).

Примеры самых часто встречающихся заголовков:   

- **Content-Type**: application/json говорит о том, что данные будут передаваться в формате json.
- **Content-Length**: 104 — размер передаваемых данных составляет 104 байта
- **Authorization**: 0L7QsdC+0LbQsNGOOtC60YLRgQ== — клиент хочет авторизоваться через [Basic Auth](https://en.wikipedia.org/wiki/Basic_access_authentication)
- **User-Agent**: Safari — запрос был выполнен из браузера Safari
Кроме общепринятых заголовков можно передавать любые свои.   

Важно помнить, что заголовки предназначены для передачи информации, которая используется в нескольких запросах. Не нужно делать так, посылая сообщение в чат:
- X-My-Message: Привет, как дела? — для этого лучше подойдет передача данных в теле запроса, например в формате JSON.

### Пример из нашей работы
В админской части конструктора Smartbot Pro у пользователя может быть несколько проектов. Чтобы не посылать id проекта на каждый запрос в теле, мы посылаем его в заголовке. API-сервер проверяет заголовки и сразу добавляет в контекст запроса нужный проект, так как он всегда лежит в одном месте — в заголовке.  Это очень упрощает процесс взаимодействия клиента и сервера. 


## 4. Ты кто? 
### Авторизация в веб-приложениях
Почти во всех приложениях нужна авторизация, чтобы определить: кто шлет запросы и что ему можно. Существует три понятия:   
- **Идентификация** — проверка, что пользователь как-то представился и существует
- **Аутентификация** — проверка верных данных пользователя для входа: логин, пароль
- **Авторизация** — проверка, что пользователь имеет право использовать данный функционал    
  
Классический сценарий: пользователь заходит на сайт и отправляет свои почту и пароль на сервер. Сервер:     
  1. Находит в базе данных аккаунт клиента по почте (Идентификация)    
  2. Сверяет пароль, отправленный клиентом, и тот, что в базе (Аутентификация)   
  3. Проверяет: забанен пользователь или нет (Авторизация)    
  4. Обычно весь этот процесс называют просто авторизацией.    

### Cookies
Самым часто используемым способом авторизации являются **Cookie** (куки), так как их поддержка встроена во все браузеры. Способ работает следующим образом:    
1. Клиент отправляет запрос с данными, необходимыми для аутентификации, например логин/пароль
2. Сервер проверяет данные и, если они верны, добавляет к ответу заголовок Set-Cookie с каким-то значением
3. Браузер «видит» этот заголовок и сохраняет его значение к себе в локальное хранилище    
4. С каждым последующим запросом браузер отправляет заголовок Cookie с сохраненным ранее значением
5. Сервер видит этот заголовок и авторизует пользователя в сервисе — при условии, что значение заголовка Cookie соответствует тому, что сервер записал в свою базу при авторизации


Cookie являются сетевым стандартом и обладают жестко заданным набором дополнительных полей, которые передаются вместе со значением Cookie в заголовке. Браузер сам умеет доставать эти данные из строки.    
Рассмотрим пример cookie:   
```
Cookie: sessionid=ktsOneLove; Domain=.kts.studio; Expires=Thu, 30 Jun 2022 15:57:14 GMT; Secure; HttpOnly; Max-Age=31536000; Path=/; SameSite=Lax;
```
- `Cookie` — ключ заголовка
- `sessionid` — название cookie, а ktsOneLove — значение cookie
- `Expires` — дата «протухания» cookie
- `HttpOnly` — флаг, который означает, что браузер не должен давать доступ к этой cookie из JavaScript кода. Такой атрибут обычно ставят на cookie, которые содержат важную информацию (например, сессию). Если страница содержит xss-уязвимость, то злоумышленник не сможет получить данные этой cookie.
- `Max-Age` — время жизни cookie
- `Domain` — на каких доменах можно использовать эту cookie. Если перед доменом стоит точка, то cookie действует на всех поддоменах этого сайта. Например .kts.studio будет действовать и на metaclass.kts.studio.
- `Path` — на каких относительных url-адресах сайта действует эта cookie. Если значение равно /, то cookie отправляется на любые запросы к этому сайту. Например, если поставить path=/user, то при запросе kts.studio/user/list заголовок Cookie будет отправлен, а на kts.studio/product/list не будет.
- `SameSite` — говорит браузеру, можно ли использовать эту cookie на других сайтах. У SameSite есть три режима:    
  1. None — cookie можно использовать на любом сайте
  2. Lax — cookie можно передавать только для высокоуровневой навигации. Например, со ссылки на сайте, на котором эта cookie была установлена, выполнен переход на другой сайт
  3. Strict — cookie можно использовать только на сайте, который ее установил
    
Одной из главной особенностей cookie является ее время жизни. Это время устанавливается в заголовке Set-Cookie, а браузер следит за временем и удаляет cookie из своего хранилища, если время ее жизни истекло. Установить это время можно с помощью атрибута Expires и Max-Age. Expires задает дату, а Max-Age задает количество секунд, то есть это одинаковая информация, просто представленная в разных форматах. Единственная разница в том, что Expires поддерживается в Internet Explorer, а Max-Age нет.

### Заголовок Authorization
Иногда использовать cookie неудобно и не нужно. Например, мы хотим запустить небольшое приложение и не хотим подключать базу данных, чтобы хранить информацию о сессиях и пользователях, следить за временем жизни cookie и создавать метод авторизации для получением cookie клиентом.

В таких случаях можно просто договориться о каком-то секретном ключе с пользователями сервиса, который они будут слать с каждым запросом, в заголовке. Или другой пример: мы хотим посылать какой-то токен, в котором содержится много полезной информации (например, JWT) и не хотим, чтобы он протухал. Для таких случаев и был разработан заголовок Authorization.

Самым простым способом для такой авторизации является Basic Auth. Сначала клиент получает логин и пароль, например admin / qwerty123. Эти данные сохраняются на сервере, в коде программы или в конфигурационных файлах. Клиент объединяет логин и пароль в такую строку: ‘admin:qwerty123’, а затем кодирует в base64. Получившаяся строка (4oCYYWRtaW46cXdlcnR5MTIz) отправляется вместе с заголовком Authorization и префиксом Basic:    

**Authorization**: Basic 4oCYYWRtaW46cXdlcnR5MTIz

Сервер выполняет обратные операции и сравнивает логин и пароль с теми, что имеются у него.

У этого способа авторизации есть большой минус: если кто-то украдет логин и пароль, то сможет нелегально пользоваться сервером до тех пор, пока эти данные не будут изменены. Поэтому данный способ стоит использовать только в комбинации с TLS-шифрованием или в закрытых сетях.

Существуют и другие способы авторизации в веб-приложениях, но в основном все они используют передачу каких-то данных через заголовки.