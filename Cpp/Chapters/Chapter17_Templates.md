# Chapter 17: Шаблоны
## Как это решалось в C (спойлер: макросы)
В C не было шаблонов и вместо них использовались макросы. Тк макросы просто подставляют нужный текст перед коспиляций, то не происходит проверки полученого кода, а возможные ошибки компилятор не сможет нормально описать. Поэтому макросы - это зло. Однако, как будет понятно далее из раздела [Как компилятор реализует шаблоны ф-ций](https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/Chapter17_Templates.md#%D0%BA%D0%B0%D0%BA-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D1%83%D0%B5%D1%82-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D1%84-%D1%86%D0%B8%D0%B9), на самом деле шаблоны - это и есть макросы, которые узаконили и сделали частью синтаксиса в C++. 
```cpp
/*** в .h файле ***/
# define DEFINE_ARRAY ( Name , Type )	\
struct Name { 				\
explicit Name ( size_t size ) 		\
: data_ ( new Type [ size ]) 		\
, size_ ( size ) {} 			\
~ Name () { delete [] data_ ; } 	\
					\
size_t size () const 			\
{ return size_ ; } 			\
					\
Type operator []( size_t i) const 	\
{ return data_ [i ]; } 			\
Type & operator []( size_t i) 		\
{ return data_ [i ]; } 			\
... 					\
private : 				\
Type * data_ ; 				\
size_t size_ ; 				\
}

/*** в main файле ***/
DEFINE_ARRAY ( ArrayInt , int );
DEFINE_ARRAY ( ArrayFlt , float );
int main ()
{
ArrayInt ai (10);
ArrayFlt af (20);
...
return 0;
}
```
- `#define DEFINE_ARRAY ( Name , Type )` - макрос, вставляющий в текст лежащий ниже Name и Type предоставленные пользователем. При этом, `\` в конце строки нужно, чтобы оформить перенос текста. Те все определение этой структуры - это просто слитныйтекст лежащий под макросом, а `\` нужно, чтобы переносить строку этого текста.
- При вызвове макроса `DEFINE_ARRAY ( ArrayInt , int );`, предпроцессор просто вставляет туда весь текст соответствющего макроса (те полное определение класса с именем ArrayInt и типом данных int). При вызове `DEFINE_ARRAY ( ArrayFlt , float );` определение снова вставится целиком, но уже с новым именем класса и типом данных.

## Шаблоны ф-ций 
Суть шаблона заключается в том, что компилятор сам подставляет тип данных в ф-цию на основе передаваемого типа данных. Это очень похоже на макрос, для которого в C++ сделали свой синтаксис. Однако принципиальное отличе - это то, что шаблон для каждого типа определяется 1 раз (**инстанцируется**), а затем компилятор уже использует его будто это обычная ф-ция/класс. А еще компилятор умеет проверять проверять шаблоны. Пример шаблона ф-ции, 
```cpp
template <typename T> // объявление параметра шаблона функции
T max(T a, T b)
{
    return (a > b) ? a : b;
}
```
- При создании шаблона необходимо сделать объявление шаблона (`template <typename T>`). Вместо ключевого слова `typename` можно использовать `class` (`template <class T>`), однако лучше его оставить для обозначения шаблонов классов. Если речь идет об объявлении имени параметра шаблона, то разницы нет. Однако, в случаии, объявления переменной зависимой от шаблона необходимо использовать `typename`. Например,
  ```cpp
  template<typename T>              //(тут неважно)
  struct X : B<T>                   // "B<T>" is dependent on T
  {
      typename T::A* pa;            // "T::A" is dependent on T (тут важно)
                                    // (see below for the meaning of this use of "typename")
      void f(B<T>* pb) {
          static int i = B<T>::i;   // "B<T>::i" is dependent on T
          pb->j++;                  // "pb->j" is dependent on T
      }
  };
  ```
- Если объявляются сразу несколько параметров шаблона, то они пишутся через запятую: `template <typename T1, typename T2>`.
- Так как шаблоны работают не только для базовых типов данных, то **компилятор так же может вставлять и пользовательские классы**. Поэтому, имеет смысл писать шаблоны ф-ций с передачей и возвращением данных через const ссылки (а не по значению, как в примере в начале):
  ```cpp
  template <typename T>
  const T& max(const T& a, const T& b)
  {
      return (a > b) ? a : b;
  }
  ```
- Нельзя задать **значение по умолчанию** для параметра шаблона ф-ции. Только для параметров шаблона класса.     
  При этом, следует помнить, что компилятор не делает ничего умного, он только вставляет тип данных вместо параметра шаблона. Поэтому, если в теле ф-ции делаются неизвестные компилятору действия, то будет ошибка. Например, в примере выше пользовательский класс должен иметь перегрузку оператора сравнения, иначе будет обшибка.      
  
Еще один пример использования шаблона. Тут надо обрать внимание на то, что опрератор `[]` может возвращать как стандартный тип данных, так и объект класса, который лучше всего возвращать через ссылку. Поэтому в данной реализации предусмотрены оба варианта: возврат по значение (для стандартных типов) и возврат по const сслыке для классов:
```cpp
template <class Type ,
	class SizeT = size_t ,
	class CRet = Type >
struct Array {
explicit Array ( SizeT size )
	: data_ ( new Type [ size ])
	, size_ ( size ) {}
~ Array ()
{ delete [] data_ ;}

SizeT size () const 
{ return size_ ;}

CRet operator []( SizeT i) const 
{ return data_ [i ]; }

Type & operator []( SizeT i ) 
{ return data_ [i ]; }
...
private :
	Type * data_ ;
	SizeT size_ ;
};
void foo ()
{
	Array <int > ai (10);
	Array <float > af (20);
	// Очень неудобно все это вводить ...
	Array < Array <int >, size_t , Array <int > const & >	da (30);
	...
}
// ... Поэтому проще заменить имя, если использовать этот шаблон часто 
typedef Array <int > Ints ;
typedef Array < Ints , size_t , Ints const &> IInts ;

void bar ()
{
	IInts da (30);
}
```
- Использование отдельного парамера шаблона CRet для возврата значения оператора `[]`, позволяет использовать этот шаблон как для стандартных типов данных, так и для классов.  
- Подобный подход ведет к тому, что объявления щаблонов получаются очень длинными. В случаии, если надо использовать их неоднократно, имеет смысл заменить имя с помошью typedef: `typedef Array < Ints , size_t , Ints const &> IInts ;`.

### Как компилятор реализует шаблоны ф-ций
1. Шаблон независимо компилируется для каждого значение параметров шаблона при первой встрече (**инстацирование**). Код шаблона вставляется на месте первого вызова и компилируется. Далее если компилятор снова встречает использование этого шаблона с теми же параметрами, она просто использует скомпилированный код. Те **для каждого типа параметра шаблона код компилируется только 1 раз**. 
2. Из за того, что шаблон вставляется inline в первом месте вызова, всю реализацию следует держать в .h файле (тк это все происходит на этапе компиляции, а линковка .cpp файлов будет после того, как все .cpp файлы скомпилированы).
3. **Компиляция шаблонов классов — ленивая**, компилируются только те методы, которые используются. Те всегда копилируются только 2 метода (конструктор и деструктор), осатьные методы шаблонного класса будут компилироваться только, если они вызваны в программе. Поэтому, если шаблонный класс скоспилировался, но не использовал некоторые методы, нельзя сказать корректны ли они, тк их не были скомпилировали.        

Когда компилятор встречает вызов обычной ф-ции, он просто вставляет адрес реализации этой ф-ции на месте его вызова. В случаии шаблона ф-ции, компилятор вставляет всю реализацию ф-ции целиком (подобно опертору inline) на месте вызова заменяя переменные шаблона на подходящие типы данных. Таким образом, если шаблон ф-ции был вызван несколько раз с разными типами данных, то и реализация ф-ции будет вставлена несколько раз. Каждая такая вставка называется **экземпляром шаблонов функций**. Например:
```cpp
 
template <typename T>
const T& max(const T& a, const T& b)
{
    return (a > b) ? a : b;
}
 
int main()
{
    int i = max(4, 8);              /* на самом деле тут стоит 
                                    const int& max(const int& a, const int& b)
                                    {
                                        return (a > b) ? a : b;
                                    }
                                    */
    std::cout << i << '\n';
 
    double d = max(7.56, 21.434);   /* на самом деле тут стоит 
                                    const double& max(const double& a, const double& b)
                                    {
                                        return (a > b) ? a : b;
                                    }
                                    */
    std::cout << d << '\n';
        
    char ch = max('b', '9');        /* на самом деле тут стоит 
                                    const ch& max(const ch& a, const ch& b)
                                    {
                                        return (a > b) ? a : b;
                                    }
                                    */
    std::cout << ch << '\n';
        
    return 0;
}
```

### Явная специализация шаблона ф-ции
Может возникнуть ситуация, что повидение шаблона для некоторого конкретного типа данных должно отличаться от общего шаблона. В этом случаии нужно использовать явную специализацию шаблона. При этом, явная специализация шаблона вегда имеет приоритет перед неявной (те компилятор сперва ищет явную реализацию, и лишь потом переходит к стандартному шаблону). Например, мы хотим сделать конкретную реализацию конструктора шаблона класса Repository для случая T=char*. 
```cpp
template <class T>
class Repository
{
private:
    T m_value;
public:
    /* В случаии T=char* мы напрямую скопируем адрес из указателя, вместо копипрования соответвующей строки */ 
    Repository(T value) : m_vlaue(value)
    {}
    // Тут деструктор и прочие дела
};

/* В этом случаии реализовано глубокое копирование */
template <>
Repository<char*>::Repository(char* value)
{
    // Определяем длину value
    int length=0;
    while (value[length] != '\0')
        ++length;
    ++length; // +1, учитывая нуль-терминатор
 
    // Выделяем память для хранения значения value
    m_value = new char[length];
 
    // Копируем фактическое значение value в m_value
    for (int count=0; count < length; ++count)
        m_value[count] = value[count];
}

/* Раз уж мы сделали глубокое копирования, нужно сделать и явный деструктор */
template <>
Repository<char*>::~Repository()
{
    delete[] m_value;
}
```
- `template <>` - пустой template указывает на то, что это шаблон, однако это релизация для конкретного типа данных (те параметр щаблона отсутвует). 
- `Repository<char*>::Repository(char* value)` - означает, что это реализация ф-ции конструктора, принимающего char* переменную (`...::Repository(char* value)`) для шаблона типа char* (`Repository<char*>::...`). 
- При глубоком копировании надо обязательно реализовать правильный деструктор, а то будет утечка памяти.

### Вывод аргументов (deduce)
Если компилятор может из контекста понять с каким типом данных вызывается шаблон, то нет необходимости явно указывать тип данных. Например, если ф-ция принимает 2 аргумента одного типа, то компилятор предположит, что нужен шаблон именно для этого типа. Например,
```cpp
// шаблон 1
template <typename Num >
Num square(Num n) { return n * n; }

// шаблон 2
template <typename Type >
void sort(Type * p, Type * q);

// шаблон 3
template <typename Type >
void sort(Array <Type > & ar);

void foo() {
	int a = square <int >(3);
	int b = square(a) + square(4); 		// square<int>(..)
	float *m= new float [10];
	sort(m, m + 10); 			// sort<float>(m, m + 10)
	sort(m, &a); 				// error: sort<float> vs. sort<int>
	Array < double > ad(100);
	sort(ad);				// sort<double>(ad)
}
```

### Перегрузка щаблонов
При перегрузке шаблона, компилятор выберет самую специфическую перегрузку для данного случая. Например, пусть у нас есть класс Array, который может содержать любой тип данных в тч и сам Array. Так например, может быть объект Arrya<int>, Array<double>, Array<Arrya<int> >, Array<Array<Arrya<int> > > и тд. Если мы хотим определить некоторую ф-цию foo() для работы с самым глубоким Array, то мы может сделать 2 перегрузки. При этом, 2я версия foo() более специфична, если в Array вложен другой Array. Поэтому мы будем рекурсивно капать, вызывая специфическую 2ю версию, пока не дойдем до 1й менее специфической, а она уже будет работать для Array не содержащего другие Arrya:
```cpp
// 1я версия
template <typename T>
void foo(const Array<T>& array))
{
	//что-то делаеться тут на нижем уровне
}
// 2я версия
template <typename T>
void foo(const Array<Array<T> >& array, std::ostream& out)
{
    const int size = array.size();
    for (int i = 0; i < size; i++)
    {	//рекурсивно капаем вглубь вложенных Array
        foo(array, out);
    }
}	
```

### Явная специализация VS перегрузка шаблона
**Перегрузка шаблона имеет приоритет** над явной специализацией. На самом деле, если не указан явно выбор шаблона ф-ции (те deduce, см. выше), то компилятор будет выбирать из наиболее подходящей перегрузки шаблона, а на явную сспециализацию забьет. Например,
```cpp
// 1. Шаблон для одного типа данных
template < class T >
void foo(T a, T b) {
	cout << "same types" << endl;
	}
// 2. Шаблон, где аргументы - 2 (не обязательно разных) типа данных
template < class T , class V >
void foo(T a, V b) {
	cout << "different types" << endl;
	}
// 3. Явная специализация шаблона
template <>
void foo<int , int >( int a , int b) {
	cout << "both parameters are int" << endl;
	}
	
int main() 
{
	foo(3, 4);		// компилятор выбирает между 1 и 2. Тк 1 подходит лучше, он выберет его
	foo<int, int>(5, 6);	// лишь, если мы явно укажем какой шаблон импользовать, компилятор выполнит 3
	return 0;
}
```

### Шаблоны методов (в основном для больщой 4ки)
Шаблоны методов для большой четверки (конструктор, деструктор, конструктора копирования и оператор присваивания (=)) имееют ограничения: им можно задавать шаблон параметра только, если этот оператор уже определен (стандартно) для этого класса. Например,
```cpp
template <class Type >
struct Array {
	// 1. Определяем стандартную версию 
	Array( Array const & other )
		: data_( new Type[other.size()])
		, size_(other.size()) 
	{
		for ( size_t i = 0; i != size_; ++i)
		data_[i] = other[i];
	}
	Array & operator =(Array const & other)
	{ 	// ваша реализация оператора тут
		return * this ; 
	}
	
	// 2. А теперь определяем шаблонную версию операторов
	template <class Other >
	Array( Array <Other > const & other )
		: data_( new Type[other.size()])
		, size_(other.size()) 
	{
		for ( size_t i = 0; i != size_; ++i)
		data_[i] = other[i];
	}
	template < class Other >
	Array & operator =(Array <Other > const & other);
	...
};

// Вынесли определение оператора за пределы класса, чтобы показать как это делать
template < class Type >
template < class Other >
Array <Type > & Array <Type >:: operator =(Array <Other > const & other)
{ 	// ваша реализация оператора тут
	return * this ; 
}
```
- Хотя очевидно, что реализации 1. и 2. совпадают (за исключением того, что в 2. - Array шаблонный). Это нужно для того, чтобы появилась возможность делать **скрытые преобразования типов**. Например,
	```cpp
	Array<int> a;
	Array<int> b;
	a = b; // тут будет вызвана 1я версия оператора =
	Array<double> с;
	a = с; // тут будет вызвана 2я версия оператора = (скрытое преобразование)
	```
	В данном примере, преобразование int <-> float простое и использует стандартное преобразование типов, поэтому мы можем оставить реализации обоих версий одинаковыми. Таким образом, стандарная реализация этих 4х операторов (1я версия) нужна для работы с собственным типом данных. В то время как, используя шаблонный метод (2я версия) можно получить способ скрытого преобразования типов. При этом, для того чтобы реализовать 2ю версию, нам необходимо сперва определить 1ю версию.
- Если реализациия шаблонного метода вынесена за тело класса, то надо не забыть все правильно оформить (включая шаблонный параметр). 
	```cpp
	// Вынесли определение оператора за пределы класса, чтобы показать как это делать
	template < class Type >
	template < class Other >
	Array <Type > & Array <Type >:: operator =(Array <Other > const & other)
	{ 	// ваша реализация оператора тут
		return * this ; 
	}
	```
	В нашем примере, так как мы спользуем 2 шаблонных параметра (один для класса, а другой для метода внутри этого класса), то мы должны сказать компилятору про оба:
	```cpp
	template < class Type >
	template < class Other >
	```
	Далее, мы определяем оператор =. Он возвращает ссылку на шаблонный класс `Array <Type > &`.  Полное наименование оператора: `Array <Type >:: operator =(...)`. А его аргумент - это шаблонный класс с другим (независимым) шаблонным параметром: `Array <Other > const & other`.

## Шаблоны классов
Синтаксис для шаблонов класса такой же как и для шаблонов ф-ций. Добавляется `template<class T>` и далее T используется там, где нужны вариации типа данных. Шаблоны классов работают точно так же, как и шаблоны функций: компилятор копирует шаблон класса, заменяя типы параметров шаблона класса на фактические (передаваемые) типы данных, а затем компилирует эту копию. Если у вас есть шаблон класса, но вы его не используете, то компилятор не будет его даже компилировать. Например, ниже представлен шаблон класса `Array<T>`. 
```cpp
/*** внутри файла Array.h (ниже будет почему это важно) ***/
template <class T> // это шаблон класса с T вместо фактического (передаваемого) типа данных
class Array
{
private:
    int m_length;
    T *m_data;                      //указатель на T 
public:
    Array(int length)
    {
        m_data = new T[length];     //динамически выделили память под массив типа T
        m_length = length;
    }
    ~Array()
    {
        delete[] m_data;
    } 
 
    T& operator[](int index)        //возврат ссылки на тип данных T
    {
        assert(index >= 0 && index < m_length);
        return m_data[index];
    }
 
    // Длина массива всегда является целочисленным значением, она не зависит от типа элементов массива
    int getLength(); // определяем метод и шаблон метода getLength() ниже
};
 
template <typename T> // метод, определенный вне тела класса, нуждается в собственном определении шаблона метода
int Array<T>::getLength() { return m_length; } // обратите внимание, имя класса - Array<T>, а не просто Array
```
- Это шаблон класса `Array<T>`, а не `Array`, хотя в названии класса не стоит `<T>`. При создании экземпляра всегда надо указывать тип данных в скобках (так, для примера выше `Array<int> intArray(10)`).
- Определение ф-ции getLength() мы вынести за тело класса. В этом случаии необходимо: 1) вновь указать компилятору, что мы используем параметр шаблона T: `template <typename T> `; 2) добавить <T> в название класса (в зоне видисоти): `Array<T>::getLength()`.
- Параметру шаблона можно дать **значение по умолчанию**. Напримре: `template <class Type , class SizeT = size_t , class CRet = Type >` (CRet по умолчанию совпадает с Type).

### Заголовочные файлы
Обычно класс реализуется в 2 файлах: объявление в .h и реализация методов в .cpp. В C++ компилятор компилирует отдельно каждый .cpp файл, а встречая .h просто копирует его содержимоев в соответсующий .cpp; затем линкер все соединяет. Так получается, что в main.cpp компилятор создает единственное объявление некоторого класса, а при работе программы вызывает реализацию из другого .cpp. Тут возникает проблема: каждый раз, когда мы создаем шаблон, компилятор копирует *весь* код объявляемого класса из .h, на место вызова. На этапе компиляции у него нет доступа к другим .cpp, включая файл с реалицаций методов шаблона класса. Поэтому, с точки зрения компилятора реализаций методов (из .cpp) не существует. Есть 3 решения у этой проблемы:
1. Использовать 1 файл: .h и всю реализацию оставить там. Если класс небольшой, то это лучший выход: просто определить все внутри .h.
2. Использовать 2 файла: .h для объявления, и файл `.inl` (от inline) c реализаций. Нужно просто переименовать MyName.cpp в MyName.inl, а затем подключить MyName.inl из нижней части файла MyName.h.
3. Использовать 3 файла: .h для объявления нашего класса, .cpp c реализаций нашего класса и еще один .cpp, где мы соберем все вместе, включив все файлы шаблонов этого и других классов. Вот пример 3го файла (templates.cpp):
    ```cpp
    /***  templates.cpp ***/
    // Таким образом, мы гарантируем, что компилятор увидит полное определение шаблона класса Array
    #include "Array.h"
    #include "Array.cpp" // мы нарушаем правила хорошего тона программирования, но только в этом месте

    // Здесь вы #include другие файлы .h и .cpp с определениями шаблонов, которые вам нужны

    template class Array<int>; // явно создаем экземпляр шаблона класса Array<int>
    template class Array<double>; // явно создаем экземпляр шаблона класса Array<double>

    // Здесь вы явно создаете другие экземпляры шаблонов, которые вам нужны
    ```
    Часть `template class` заставит компилятора явно создать указанные экземпляры шаблона класса. В примере, приведенном выше, компилятор создаст Array<int> и Array<double> внутри `templates.cpp`. Поскольку templates.cpp находится внутри нашего проекта, то он скомпилируется и удачно свяжется с другими файлами (пройдет линкинг).

### Явная специализация шаблона класса
- Полная специализация всегда имеет приоритет над частичной. Например, если мы сделали частичную специализацию для работы с любым указателем (`сlass MyClass<T*>`) и полную специализацию для работы с char* (`сlass MyClass<char*>`), то приоритет компилятора будет такой: char* > T* > общий шаблон. 
#### Полная специализация
Тут все то же самое, что и для явной специализации шаблона ф-ции. Например, пусть мы хотим сделать особую реализацию шаблона класса Repository для типа данных bool:
```cpp
/* Общий шаблон */
template <class T>
class Repository
{
private:
    T m_value;
public:
    // Тут конструктор, деструктор и прочие дела
};

/* Реализация для типа bool */
template <>
class Repository<bool>
{
private:
    bool m_value;
public:
    // Тут конструктор, деструктор и прочие дела, но уже для bool
};
```
- `template <>` - пустой template указывает на то, что это шаблон, однако это релизация для конкретного типа данных (те параметр щаблона отсутвует). 
- `class Repository<bool>` - конкретно указываем тип данных для данной явной реализации

#### Частичная специализация
Частичная специализация шаблона позволяет выполнить специализацию шаблона класса (но не функции!), где некоторые (но не все) параметры шаблона явно определены. В плане реализации все похоже на полную специализацию только вместо пустого template мы записываем переменные шаблона, которые не были опеределены явно. Например, 
```cpp
/* Общий шаблон */
template <class T, int size> // size является параметром non-type шаблона
class StaticArray
{
private:
    // Параметр size отвечает за длину массива
    T m_array[size]; 
public:
    T* getArray() { return m_array; }
    T& operator[] (int index) { return m_array[index]; }
    void print()
    {
        for (int i = 0; i < size; i++)
            std::cout << m_array[i] << ' ';
        std::cout << "\n";
	}
};

/* Частично специализированный шаблон */
template <int size> // убрали сlass T
class StaticArray<double, size> //double указываем явно
{
private:
    double m_array[size];
public:
    double* getArray() { return m_array; }
    double& operator[](int index) { return m_array[index]; }
 
    void print()
    {
        for (int i = 0; i < size; i++)
            std::cout << std::scientific << m_array[i] << " ";
        std::cout << "\n";
	}
};
```
- В `template <int size>` указываются только переменные шаблона. То, что явно специализируктся (в нашем случаии `class T`) убираем. 
- В названии шаблона (`class StaticArray<double, size>`) перечисляем все данные: как специализируемые, так и общие переменные шаблона. 
- Частичная спецификация для шаблона работающего с **указателями**: 1) создается общий шаблон для стандартных типов данных; 2) делается частичная спецификация для работы с указателями. Например:
	```cpp
	/* Общий шаблон */
	template <class T>
	class Repository
	{
	private:
	    T m_value;
	public:
	    // Тут конструктор, деструктор и прочие дела
	};

	/* Реализация для типа bool */
	template <typename T>
	class Repository<T*>
	{
	private:
	    T* m_value;
	public:
	    // Тут конструктор, деструктор и прочие дела, но уже для T* (deep copy и все дела)
	};
	```
- Однако нельзя сделать частичную реализацию шаблона ф-ции. Например, для случая сверу *нельзя* определить поведение метода print подобным образом:
	```cpp
	// Не сработает
	template <int size>
	void StaticArray<double, size>::print()
	{
		for (int i = 0; i < size; i++)
		    std::cout << std::scientific << m_array[i] << " ";
		std::cout << "\n";
	}
	/* Однако НЕЛЬЗЯ частично сделать*/
	```
	Нужно переопредеть весь шаблон класса целиком. 

##### Использование родительского класса для частичной специализации метода класса
Если мы хотим, чтобы лишь один (или нескольколько) методов класса имели явную частичную специализацию, но при этом не хотим переписывать для этого весь шаблон класса целиком, то можно сделать это через наследование от родительского класса. Для этого: 1) создаем шаблон родительского класса, где реализуем все общие методы; 2) наследуем для дочернего общего шаблона (и его используем для общих случаем); 3) наследуем для частичной специализации и специализируем дочерний класса, а в нем реализуем нужные нам методы. Например,
```cpp
/*  1) создаем шаблон родительского класса, где реализуем все общие методы; */
template <class T, int size> // size является параметром non-type шаблона
class StaticArray_Base
{
protected:
	// Параметр size отвечает за длину массива
	T m_array[size];
 
public:
	// Это шаблон статического массива, поэтому на не нужен конструктор и деструктор 
	T* getArray() { return m_array; }
	T& operator[](int index) { return m_array[index]; }
	virtual void print()
	{
		for (int i = 0; i < size; i++)
			std::cout << m_array[i] << ' ';
		std::cout << "\n";
	}
};

/* наследуем для дочернего общего шаблона (и его используем для общих случаем); */
template <class T, int size> // size является параметром non-type шаблона
class StaticArray: public StaticArray_Base<T, size>
{};

/* 3) наследуем для частичной специализации и специализируем дочерний класса, а в нем реализуем нужные нам методы */
template <int size> // size является параметром non-type шаблона
class StaticArray<double, size>: public StaticArray_Base<double, size>
{
public:
 
	virtual void print() override
	{
		for (int i = 0; i < size; i++)
			std::cout << std::scientific << this->m_array[i] << " ";
// Примечание: Префикс this-> на вышеприведенной строке необходим. Почему? Читайте здесь - https://stackoverflow.com/a/6592617
		std::cout << "\n";
	}
};
```

### typedef мета
Некоторые шаблоны чаще используется с определнными типами. Например, шаблон для класса векторной алгебры (Vec) будет иметь смысл только для чисел, те только для типов: int, float и double. В этом случаии, чтобы избежать необходимость каждый раз указывать тип данных для этого класса при создании объекта, их имена обозначают через typedef. Например, для класса Vec2 (двумерный вектор (x, y)) это выглядит так:
```cpp
template<class T>
class Vec2_ 
{
	//тут вся реализация класса
};

typedef Vec2_<int> Vei2;
typedef Vec2_<float> Vef2;
typedef Vec2_<double> Ved2;
```
- Теперь при создании шаблонного класса можно избежать указания Vec2_<int> и просто использовать Vei2 для int версии шаблона.
- Обозначения имен `typedef` идут вне класса в конце того же .h файла.

## none-type параметр
Параметр **non-type** в шаблоне — это специальный параметр шаблона, который заменяется конкретным значением, а не типом данных. Выглядит это так: `template <class T, int size>`. При этом, этот **параметр должен быть const at-compile-time** (иначе говоря, должен хранится в static памяти). Например, тут none-type параметр используется для задания размера массива:
```cpp
template <class T, int size> // size является параметром non-type в шаблоне класса
class StaticArray
{
private:
    // Параметр non-type в шаблоне класса отвечает за размер выделяемого массива
    T m_array[size];
public:
    T& operator[](int index)
    {
        return m_array[index];
    }
};
 

int main()
{
    // Объявляем целочисленный массив из 10 элементов
    StaticArray<int, 10> intArray;
    
    return 0;
}
```
 Non-type параметром может быть: 
 1. целочисленное значение или перечисление; 
 2. указатель или ссылка на объект класса; 
 3. указатель или ссылка на функцию; 
 4. указатель или ссылка на метод класса; 
 5. std::nullptr_t.
 
 ### Еще пример использования none-type параметра
 Нужно написать ф-цию, которая принимает только ссылку на статический массив (те не позволяет распадание в указатель) и возвращает размер массива:
 ```cpp
 template<typename T, int size>
size_t array_size(T (&arr)[size])
{
    return size;
}

int main()
{
	int ints[] = {1, 2, 3, 4};
	int *iptr = ints;
	double doubles[] = {3.14};
	array_size(ints); 	// вернет 4
	array_size(doubles); 	// вернет 1
	array_size(iptr); 	// тут произойдет ошибка компиляции
	return 0;
}
```
- `T (&arr)[size]` - передача по ссылке массива типа T и размера size. Если в ф-цию передать не статический массив, а что либо другое, то компилятор выдаст ошибку.
- Тк тут используются статические массивы, то их размер известен at-compile time. Поэтому, none-type парамет подходит для этого. Нам не надо явно указывать поля для шаблона, компилятор сделает deduce из контекста. Тк компилятор знает размер массива, то и сам сделает deduce параметра size. 

## template и функторы - союз созданный на небесах
Если у нас есть куча различных перегрузок одной ф-ции, реализация которых отличается очень мало, то удобно создать 1 шаблонную ф-цию и несколько функторовы, которые будут в эту ф-цю передаваться. Например, в ChiliFramework у нас есть несколько версий ф-ций DrawSprite, которые ресуют на экране спрайт с небольшими различиями (рисуеи как есть, хромокей, смена цвета пикселя и эффект призрака(прозрачность)):
```cpp
/*** В Graphics.h ***/
// this version of drawsprite draws all pixels as they are
void DrawSpriteNonChroma( int x,int y,RectI srcRect,const RectI& clip,const Surface& s );
// this version of drawsprite draws all pixels except chroma color
void DrawSprite( int x,int y,RectI srcRect,const RectI& clip,const Surface& s,Color chroma = Colors::Magenta );
// this version of drawsprite substitutes all drawn pixel colors with the supplied color
void DrawSpriteSubstitute( int x,int y,Color substitute,RectI srcRect,const RectI& clip,const Surface& s,Color chroma = Colors::Magenta );
// this version of drawsprite has 50% transparency
void DrawSpriteGhost( int x,int y,RectI srcRect,const RectI& clip,const Surface& s,Color chroma = Colors::Magenta );
```
В то же время, их реализация одинакова везде, кроме вызова ф-ции PutPixel(), рисующей пиксель заданного цвета на экране:
```cpp
/*** В Graphics.cpp ***/
assert( srcRect.left >= 0 );
	assert( srcRect.right <= s.GetWidth() );
	assert( srcRect.top >= 0 );
	assert( srcRect.bottom <= s.GetHeight() );
	if( x < clip.left )
	{
		srcRect.left += clip.left - x;
		x = clip.left;
	}
	if( y < clip.top )
	{
		srcRect.top += clip.top - y;
		y = clip.top;
	}
	if( x + srcRect.GetWidth() > clip.right )
	{
		srcRect.right -= x + srcRect.GetWidth() - clip.right;
	}
	if( y + srcRect.GetHeight() > clip.bottom )
	{
		srcRect.bottom -= y + srcRect.GetHeight() - clip.bottom;
	}
	for( int sy = srcRect.top; sy < srcRect.bottom; sy++ )
	{
		for( int sx = srcRect.left; sx < srcRect.right; sx++ )
		{	
		/*** Все эти ф-ции отличаются только этой частью кода ***/
			const Color srcPixel = s.GetPixel( sx,sy );
			if( srcPixel != chroma )
			{
				PutPixel( x + sx - srcRect.left,y + sy - srcRect.top,srcPixel );
			}
		/********************************************************/
		}
	}
}
```
В этом случаии идеальным решением будет создать по 1 функтору для каждой версии этой ф-ции:
```cpp
/*** В SpriteEffect.h ***/
namespace SpriteEffect
{
	class Chroma
	{
	public:
		Chroma( Color c )
			:
			chroma( c )
		{}
		void operator()( Color cSrc,int xDest,int yDest,Graphics& gfx ) const
		{
			if( cSrc != chroma )
			{
				gfx.PutPixel( xDest,yDest,cSrc );
			}
		}
	private:
		Color chroma;
	};
	class Substitution
	{
	public:
		Substitution( Color c,Color s )
			:
			chroma( c ),
			sub( s )
		{}
		void operator()( Color cSrc,int xDest,int yDest,Graphics& gfx ) const
		{
			if( cSrc != chroma )
			{
				gfx.PutPixel( xDest,yDest,sub );
			}
		}
	private:
		Color chroma = Colors::Magenta;
		Color sub;
	};
	class Copy
	{ // компилятор сам сгенерирует default конструктор
	public:
		void operator()( Color cSrc,int xDest,int yDest,Graphics& gfx ) const
		{
			gfx.PutPixel( xDest,yDest,cSrc );
		}
	};
	class Ghost
	{
	public:
		Ghost( Color c )
			:
			chroma( c )
		{}
		void operator()( Color src,int xDest,int yDest,Graphics& gfx ) const
		{
			if( src != chroma )
			{
				const Color dest = gfx.GetPixel( xDest,yDest );
				const Color blend = {
					unsigned char( (src.GetR() + dest.GetR()) / 2 ),
					unsigned char( (src.GetG() + dest.GetG()) / 2 ),
					unsigned char( (src.GetB() + dest.GetB()) / 2 )
				};
				gfx.PutPixel( xDest,yDest,blend );
			}
		}
	private:
		Color chroma;
	};
}
```
А сама реализация ф-ции DrawSprite будет сделана через шаблоны:
```cpp
template<typename E>
	void DrawSprite( int x,int y,RectI srcRect,const RectI& clip,const Surface& s,E effect )
	{
		assert( srcRect.left >= 0 );
		assert( srcRect.right <= s.GetWidth() );
		assert( srcRect.top >= 0 );
		assert( srcRect.bottom <= s.GetHeight() );
		if( x < clip.left )
		{
			srcRect.left += clip.left - x;
			x = clip.left;
		}
		if( y < clip.top )
		{
			srcRect.top += clip.top - y;
			y = clip.top;
		}
		if( x + srcRect.GetWidth() > clip.right )
		{
			srcRect.right -= x + srcRect.GetWidth() - clip.right;
		}
		if( y + srcRect.GetHeight() > clip.bottom )
		{
			srcRect.bottom -= y + srcRect.GetHeight() - clip.bottom;
		}
		for( int sy = srcRect.top; sy < srcRect.bottom; sy++ )
		{
			for( int sx = srcRect.left; sx < srcRect.right; sx++ )
			{
			/*** Функтор тут ***/
				effect(
					s.GetPixel( sx,sy ),
					x + sx - srcRect.left,
					y + sy - srcRect.top,
					*this
				);
			/********************************************************/
			}
		}
	}
```
Таким образом, вместо параметра шаблона effect будет вызываться нужный функтор (например, `SpriteEffec::Chroma(Color chorma)` или `SpriteEffec::Substitution(Color chorma, Color subst)`).    

В этом случаии важно помнить:
- Функтор - это класс, у которого переопределн опратор `()`, чтобы его можно было вызывать как ф-цию. Он может состоять только из этого оператора, если функтор простой (например, Copy класс в нашем случаии) или иметь свои внутренние поля, методы, конструкторы и деструкторы для нужд корректной работы. Однако, его единственная цель - это работать как ф-ция при вызове `()`. 
- Сигнатура функторов должна быть одинакова. Все различия скрыты внутри него. Таким образом, мы добиваемся единообразного вызова, чтобы создать на основе него шаблонный класс.

## Несколько фич связанныз с классами
### Как узнать тип параметра через typedef (Использование зависимых имён)
Может возникнуть ситуация, когда нам нужно внутри программы понять с каким типом данных был вызван данный шаблон, чтобы, например, корректно обработать его. Для этого можно использовать `typedef` следующим образом:
```cpp
template < class T >
struct Array {
	typedef T value_type ; 	// теперь вызвав Container :: value_type мы получим тип параметра T
	...
private :
	size_t size_ ;
	T * data_ ;
};

template < class Container >
bool contains ( Container const & c, typename Container :: value_type const & v );
int main ()
{
	Array <int > a (10);
	contains (a , 5);
	return 0;
}
```
- Указывая `Container :: value_type`, мы обращаемся к типу параметра шаблонного класса. Однако, компилятор не знает, что это и ожидает, что вызов `Container :: value_type` - это обращение какой-то static переменной. Поэтому, надо явно указать `typename` перед этим. Так компилятор поймет, что речь идет о типе данных.

### Использование функций для вывода параметров
Тк шаблонные классы не имею возможности использовать deduce (могут только шаблонные ф-ции), то при ссоздании шаблона класса *необходимо* явно указывать тип параметра, даже если 
это очевидно из контекста. В этом случаии используют следующую хитрость: создается шаблонная ф-ция обертка, цель который создать объект шаблонного класса (с использованием deduce), а затем вернуть его. Таким образом, мы вместо создание объекта класса вызываем ф-цию-обертку, которая сделает это. Для этой ф-ции разрешено использовать deduce. Например:
```cpp
// Сам класс. Нужно явно указывать типы для First и Second
template < class First , class Second >
struct Pair {
	Pair ( First const & first , Second const & second )
		: first ( first ) , second ( second ) {}
	First first ;
	Second second ;
};
// Ф-ция-обертка. Не нужно (когда однозначен контекст) явно указывать типы для First и Second 
template < class First , class Second >
Pair < First , Second > makePair ( First const & f , Second const & s) {
	return Pair < First , Second >(f , s );
}
void foo ( Pair <int , double > const & p );

void bar () {
	foo ( Pair <int , double >(3 , 4.5));	// Созадаем класса. Нужно явно указывать типа
	foo ( makePair (5 , 8.5));		// А так не нужно 
}
```
