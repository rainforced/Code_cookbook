# Chapter 14 Operator overload
Главное, что надо знать о перегрузке операторов - это то, что оператор можно перегрузить только, если хотя бы один из операндов - пользовательский тип. Например, можно перегрузить class Smth + int, но нельзя перегрузить int + int. Так классы это практически (?) едиственный сбособ создания пользовательских типов, то перегрузка в основном нужна для классов. Отсюда происходят 2 способа перегрузки:
1. Через внешние (обычные) ф-ции (или дружественные, если нужен доступ к скрытым членам)
3. Через ф-ции класса

В то же время сами операторы можно разделить на два типа:
1. Унарные (один опреанд)
2. Бинарные (два операнда)

Важно помнить, что для перегруженных операторов сохраняется тот же приоритет выполнения операторов, что и у стандартных типов.  

## Перегрузка через через обычне ф-ции
В этом случаии используется ключевое слово и символ оператора: `operator+`. В качестве аргументов принимаются как левая так и правая сторона: `operator+(const class_one& one, const class_two& two)`. Также, тк доступ к членам не прямой, то **возврат будет по-значению**. Например,
```cpp
class Dollars
{
private:
	int m_dollars;
public:
	Dollars(int dollars) { m_dollars = dollars; }
	int getDollars() const { return m_dollars; }    //создали геттер для доступа к членам
};
// Примечание: Эта функция не является ни методом класса, ни дружественной классу Dollars!
Dollars operator+(const Dollars &d1, const Dollars &d2)
{
	// Используем конструктор Dollars и operator+(int, int)
  // Здесь нам не нужен прямой доступ к закрытым членам класса Dollars
	return Dollars(d1.getDollars() + d2.getDollars());
}
 
int main()
{
	Dollars dollars1(7);
	Dollars dollars2(9);
	Dollars dollarsSum = dollars1 + dollars2;
 
	return 0;
}
```
### Перегрузка через дружественные ф-ции
Если требуется доступ скрытым членам ф-ции (не через геттер), то можно использовать `friend`:
```cpp
class Values
{
private:
	int a;
	int b;
 
public:
	Values() = default; 
   
  friend Values operator+(const Values &v1, const Values &v2);
	friend Values operator+(const Values &v, int value);
	friend Values operator+(int value, const Values &v);
};
 
Values operator+(const Values &v1, const Values &v2)
{
  int aa = v1.a + v2.a;
  int bb = v1.b + v2.b;
	return Values(aa, bb);
}
 
Values operator+(const Values &v, int value)
{
	int aa = v1.a + value;
  int bb = v1.b + value;
	return Values(aa, bb);
}
 
Values operator+(int value, const Values &v)
{
	// Вызываем operator+(Values, int)
	return v + value;
}
 
int main()
{
	Values v1(11, 14);
	Values v2(7, 10);
	Values v3(4, 13);
  // все будет работать ок даже в такой последовательности операций
	Values vFinal = v1 + v2 + 6 + 9 + v3 + 17;
 
	return 0;
}
```
Главное **удобство использования перегрузки через обычные/дружественные ф-ции - это симетрия**: те можно легко менять местами левый и правый операнды: `operator+(class Smth one, int two)` и `operator+(int two, class Smth one)`.
### Когда лучше использовать
- Для перегрузки бинарных операторов, которые не изменяют левый операнд (например, operator+).
- Важно, что **возврат по-значению**, а это значит, что цепочки операторов невозможны (точнее кодый разбудет создаваться и уничтожаться новый объект).

## Перегрузка через метод класса
В этом случаи нужно указывать только **левый операнд**, так как правый это указатель на данный экземпляр (`*this`): видим `operator+(int a)`, читаем `operator+(*this, int a)`. Например,
```cpp
class Dollars
{
private:
    int m_dollars;
public:
    Dollars(int dollars) { m_dollars = dollars; }
    // Выполняем Dollars + int
    Dollars operator+(int value);
};
// Примечание: Эта функция является методом класса!
// Вместо параметра dollars в перегрузке через дружественную функцию здесь неявный параметр, на который указывает указатель *this
Dollars Dollars::operator+(int value)
{
    return Dollars(m_dollars + value);
}
 
int main()
{
	Dollars dollars1(7);
	Dollars dollars2 = dollars1 + 3; 
	return 0;
```
Так как правый операнд всегда будет `*this`, то перегрузка симметричных операторов (например, class+int и int+class) будет невозможна.
### Как перегрузить симетричный оператор не теряя инкапсуляции 
**Использовать `friend` внутри класса** 
```cpp
class Integral
{
public:
  Integral() = default;
  Integral(const int value) : value{value}{};

  friend auto operator+(const int left, const Integral& right) -> Integral
  {
    return Integral{left + right.value};
  }

private:
  int value{};
};
```
**Делать явное преобразование нужного типа в класс**    
Вместо int+class,  int->class и class+class:    
```cpp
class Integral
{
public:
  Integral() = default;
  Integral(const int value) : value{value}{};

  auto operator+(const Integral& right) const -> Integral
  {
    return Integral{value + right.value};
  }

private:
  int value{};
};

auto x = Integral{12};
auto result1 = x + 2; // works
auto result2 = 2 + x; // also works
```
### Когда лучше использовать
- Для операторов присваивания (=), индекса ([]), вызова функции (()) или выбора члена (->).
- Для унарных операторов (например, ! или + и -).
- Для перегрузки бинарных операторов, которые изменяют левый операнд (например, operator+=).

### Создание цепочек операторов (operator chaining)
В этом случаи возврат значения должен быть по ссылке, а в ф-цию передаваться параметр (`*this`), те это надо делать через методы класса. Например,
```cpp
//Обычное умножение class * float, объект НЕ изменяется -> возвращаем по значению
Vec2 Vec2::operator*( float rhs ) const
{
	return Vec2( x * rhs,y * rhs );
}
// Умножение class *= float, объект изменяется -> возвращаем по ссылке
Vec2& Vec2::operator*=( float rhs )
{
	return *this = *this * rhs;
}
```

### Перегрузка унарных операторов
Никакой магии тут нет, все как для перегрузки других операторов. Возврат по-значению, тк используя операторы -,+,! мы не хотим менять наш объект, а хотим получить навый с нужным свойством.
```cpp
class Something
{
private:
	double m_a, m_b, m_c;
public:
	Something(double a = 0.0, double b = 0.0, double c = 0.0) 
		:
		m_a(a), 
		m_b(b), 
		m_c(c)
	{}
 	// Конвертируем объект класса Something в отрицательный 
	Something operator- () const
	{
		return Something(-m_a, -m_b, -m_c);
	}
 
	// Возвращаем true, если используются значения по умолчанию, в противном случае - false
	bool operator! () const
	{
		return (m_a == 0.0 && m_b == 0.0 && m_c == 0.0);
	}
}
```

## Перегрузка операторов сравнения
Тк операторы сравненения (`!=`, `==`, `<`, `<=` etc) - это бинарные оператор, то их имеет смысл реализовывать через обычные/дружественные ф-ции: если сраниваются объекты разных типов и нужна симмерия. Однако, если идет сравнение между объектами одного класса, то лучше использовать метод класса.
```cpp
class Dollars
{
private:
    int m_dollars;
public:
    Dollars(int dollars) { m_dollars = dollars; }
    //Опредилим эти операторы через дружественные ф-ции
    friend bool operator> (const Dollars &d1, const Dollars &d2);
    friend bool operator>= (const Dollars &d1, const Dollars &d2);
    //А этм через методы классов. Тк в обоих случаях сравниваются класса, то не важно, что использовать
    bool operator< (const Dollars &d2);
    bool operator<= (const Dollars &d2);
};
 
bool operator> (const Dollars &d1, const Dollars &d2)
{
    return d1.m_dollars > d2.m_dollars;
}
 
bool operator>= (const Dollars &d1, const Dollars &d2)
{
    return d1.m_dollars >= d2.m_dollars;
}
//Не забыть Dollars:: тк это метод класса, определенный вне класса
bool Dollars::operator< (const Dollars &d2)
{
    return m_dollars < d2.m_dollars;
}
 
bool Dollars::operator<= (const Dollars &d2)
{
    return m_dollars <= d2.m_dollars;
}
```

## Перегрузка инкремента и декремента
На самом деле, операции `++a` (версия **префикс**) и `a++` (**постфикс**) отличаются принципиально: `++a` возвращает (a+1), в то время как `a++` возвращает a и лишь потом прибавляет 1. Поэтому реализации у них тоже разные.
```cpp

class Number
{
private:
    int m_number;
public:
    Number(int number=0)
        : m_number(number)
    {
    }
 
    Number& operator++(); // версия префикс
 
    Number operator++(int); // версия постфикс
};
 
Number& Number::operator++()
{
    // Если значением переменной m_number является 8, то выполняем сброс на 0
    if (m_number == 8)
        m_number = 0;
    // В противном случае просто увеличиваем m_number на единицу
    else
        ++m_number;
 
    return *this;
}
 
Number Number::operator++(int)
{
    // Создаём временный объект класса Number с текущим значением переменной m_number
    Number temp(m_number);
 
    // Используем оператор инкремента версии префикс для реализации перегрузки оператора инкремента версии постфикс
    ++(*this); // реализация перегрузки
 
    // Возвращаем временный объект
    return temp;
}
```
1. `++a` работает как от нее и ожидаешь: принимает скрытый указатель (`*this`), делает инкремент и возвращает ссылку на `*this`.
2. `a++` работает сложнее. 
	- Во-первых компилятр должен различить префикс и постфикс версии оператора: для этого в аргументы ставится "заглушка" просто тип данных int (`operator++(int)`), это не несет в себе никакого другого смысла кроме как сказать компилятору, что это постфикс версия.
	- Во-вторрых, мы возвращаем по значению новый обыъект-копию, который был создан до инкремента. Тк return закончит выполнение ф-ции, а мы должны при этом еще успеть сделать инкремент, то это удобный способ. Мы создали копию, сделали инкремент к оригиналу (переданному по сслыке), и вернули копию (по значению). В это же время оригинал уже был изменен.

## Перегрузка операторов ввода и вывода
Перегрузка операторов ввода и вывода всегда делается через обычные/дружественные ф-ции тк **левый операнд - всегда объект потока**. Если это поток вывода то левый операнд - `std::ostream &out`(объект потока вывода). Если поток ввода, то левый операнд - `std::istream &in` (объект потока ввода). Правый опреанд в обоих случаях - наш класс. 

```cpp
class Point
{
private:
    double m_x, m_y, m_z;
public:
    Point(double x=0.0, double y=0.0, double z=0.0): m_x(x), m_y(y), m_z(z)
    {}
 
    friend std::ostream& operator<< (std::ostream &out, const Point &point);
    friend std::istream& operator>> (std::istream &in, Point &point);
};
 
std::ostream& operator<< (std::ostream &out, const Point &point)
{
    // Поскольку operator<< является другом класса Point, то мы имеем прямой доступ к членам Point
    // Мы передали объект вывода во ссылке (out), теперь обращаемся к нему через имя out
    out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ")";
 
    return out;
}
 
std::istream& operator>> (std::istream &in, Point &point)
{
    // Поскольку operator>> является другом класса Point, то мы имеем прямой доступ к членам Point
    // Обратите внимание, параметр point (объект класса Point) должен быть не константным, чтобы мы имели возможность изменить члены класса
    in >> point.m_x;
    in >> point.m_y;
    in >> point.m_z;
 
    return in;
}
```
- Возврат происходит по ссылке на объект поток: по сути, внутри нашей ф-ции мы меняем содержимое потока, и возвращаем его назад. Важно, чтобы потом поддерживал цепочки вызвов, поэтому он **ВСЕГДА возвращается по ссылке** (возврат по значению запрещен).     
- Поток является самостоятельным классом (`ostream`), поэтому перегрузить его как метод нашего класса (например, так `std::ostream& operator<< (const Point &point);`) нельзя. Можно только вделать перегрузку оператора `<<` как обычной/дружественной ф-ции.
- Нет ничего плохого в перегрузке через дружественные ф-ции (см подробнее [тут](https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/Chapter6_Classes.md#does-friend-violate-encapsulation)).

## Перегрузка оператора индекса []
Перегрузка оператора индексации обычно используется для обеспечения прямого доступа к элементам массива, который находится внутри класса (в качестве переменной-члена). Имеет смысл определить оператор[] для обычного и константного случая, тк если будет создан константный экземпляр (`const IntArray carray`), то использование неконстантого[] вызовет ошибку. 
```cpp
class IntArray
{
private:
    int m_array[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // указываем начальные значения
 
public:
    int& operator[] (const int index);
    const int& operator[] (const int index) const;
};
 
int& IntArray::operator[] (const int index) 
// для неконстантных объектов: может использоваться как для присваивания значений элементам, так и для их просмотра
{
    return m_array[index];
}
 
const int& IntArray::operator[] (const int index) const 
// для константных объектов: используется только для просмотра (вывода) элементов массива
{
    return m_array[index];
}

int main()
{
    IntArray array;
    array[4] = 5; 		//вызывается неконстантная версия operator[]
    std::cout << array[4];	//вызывается неконстантная версия operator[]
 
    const IntArray carray;
    std::cout << carray[4];	//вызовет константную версию []
 
    return 0;
}
```
Поскольку приоритет оператора индексации выше приоритета оператора присваивания, то сначала выполняется часть `array[4]. array[4]` приводит к вызову функции перегрузки оператора [], которая возвратит `array.m_array[4]`. Поскольку оператор [] использует возврат по ссылке, то он возвращает фактический элемент `array.m_array[4]`. Наше частично обработанное выражение становится `array.m_array[4] = 5`, что является прямой операцией присваивания значения элементу массива. Поскольку результат выполнения оператора [] может использоваться в левой части операции присваивания (например, `array[4] = 5`), то возвращаемое значение оператора [] должно быть **l-value**. Ссылки же всегда являются **l-values**, так как их можно использовать только с переменными, которые имеют адреса памяти.    

Если известны размеры массива, то имеет смысл внутри определения опрератора[] сделать проверку выхода за границы массива: `assert(index >= 0 && index < size)`.     

### Указатели на объекты и перегруженный оператор []
По привычке работы с обычными массивами, можно ошибиться попытавшись вызвать [] на ссылку на класса, содеражащий массив:
```cpp
class IntArray
{
private:
    int m_array[10];
 
public:
    int& operator[] (const int index);
};
 
int& IntArray::operator[] (const int index)
{
    assert(index >= 0 && index < 10);
 
    return m_array[index];
}
 
int main()
{
    IntArray *array = new IntArray;
    array[4] = 5;    	/* ошибка. Тут мы пытаемся проиндексировать ссылку на класс IntArray, а не сам экземпляр. 
    			Тк это пользовательский тип, то не происходит автоматического разыменовывания укащателя,
			как в случаии обычного массива */
    (*array)[4] = 5; 	// сначала разыменовываем указатель для получения объекта array, затем вызываем operator[]
    delete array;
 
    return 0;
}
```
### Три совета
- Перегружать const и обычный виды операторов[]
- Принимаемый индекс не обязательно должен быть int, он может быть любым другим типом данных (главное чтобы это имело смысл), обработка все равно происходит внутри ф-ции.
- Быть аккуратным с указателями на класс и собственноручно их разименовывать

### Упоротрая перегрузка [][]
Можно создать такую перегрузку, чтобы работал оператор `smth[][]`. Тк такого оператора нет, то суть тут в том, чтобы первый вызов `smth[]` возвращал буфферный подкласс объектра `smth`. У буферного подкласса также есть перегрузка оператора []. Например,
```cpp
class ArrayOfArrays {
public:
    ArrayOfArrays() {
        _arrayofarrays = new int*[10];
        for(int i = 0; i < 10; ++i)
            _arrayofarrays[i] = new int[10];
    }

    class Proxy {
    public:
        Proxy(int* _array) : _array(_array) { }

        int operator[](int index) {
            return _array[index];
        }
    private:
        int* _array;
    };

    Proxy operator[](int index) {
        return Proxy(_arrayofarrays[index]);
    }

private:
    int** _arrayofarrays;
};
```
Вызов же будет таким:
```cpp
ArrayOfArrays aoa;
aoa[3][5]
```

## Перегрузка оператора ()
Вообще, это оператор вызова ф-ций, но при перегрузке он не несет какого-то сокрального смысла. Это единственный оператор, у которого **не ограничено кол-во аргументов**, в остальном его действие может быть любым. Так же он всегда перегружается через методы класса (скрытый `*this` - самый левый операнд). Например в ниже он используется для доступа к элементу двумерной матрицы (те оператор [] можно перегрузи только для одномерной матрицы, нельзя использовать [][]):
```cpp
class Matrix
{
private:
    double data[5][5];
public:
    Matrix() = default; 
    double& operator()(int row, int col);		//тут принимает 2 параметра
    const double& operator()(int row, int col) const;
    void operator()();					//тут принимает 0 параметров
};
 
double& Matrix::operator()(int row, int col)
{
    assert(col >= 0 && col < 5);			//хорошая идея проверить границы массива
    assert(row >= 0 && row < 5);
 
    return data[row][col];
}
 
const double& Matrix::operator()(int row, int col) const
{
    assert(col >= 0 && col < 5);
    assert(row >= 0 && row < 5);
 
    return data[row][col];
}
 
void Matrix::operator()()
{
    // Сбрасываем значения всех элементов массива на 0.0
    for (int row=0; row < 5; ++row)
        for (int col=0; col < 5; ++col)
            data[row][col] = 0.0;
}
 
int main()
{
    Matrix matrix;
    matrix(2, 3) = 3.6;
    matrix(); // выполняем сброс
    std::cout << matrix(2, 3);
 
    return 0;
}
```

### Функторы
**Функтор (fucntor)** (или ещё «функциональных объектов») - это класс, у которого переопределн опратор `()`, чтобы его можно было вызывать как ф-цию. Он может состоять только из этого оператора, если функтор простой или иметь свои внутренние поля, методы, конструкторы и деструкторы для нужд корректной работы. Однако, его единственная цель - это работать как ф-ция при вызове `()`. В основном перегрузка оператора `()` делается для создания функторов.  Например,
```cpp
class Accumulator
{
private:
    int m_counter = 0;
 
public:
    Accumulator()
    {
    }
 
    int operator() (int i) { return (m_counter += i); }
};
 
int main()
{
    Accumulator accum;
    std::cout << accum(30) << std::endl; // выведется 30
    std::cout << accum(40) << std::endl; // выведется 70
 
    return 0;
}
```
По сути, действие этой ф-ции аналогично обычной ф-ции со static параметром: она имеет поле, которое запоминает все между вызовами (тк это просто экземпляр класса). При этом вызовы у него аналогичны вызовам обычной ф-ции: `accum(40)`. 

### Где использовать
- Вместе с шаблонами ф-ций, где функтор выступает в качестве параметра шаблона. Подробнее [в главе про шаблоны](https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/Chapter17_Templates.md#template-%D0%B8-%D1%84%D1%83%D0%BD%D0%BA%D1%82%D0%BE%D1%80%D1%8B---%D1%81%D0%BE%D1%8E%D0%B7-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BD%D0%B0-%D0%BD%D0%B5%D0%B1%D0%B5%D1%81%D0%B0%D1%85).   
- В остальных случаях - лучше создать какой-нибудь метод, тк вызовы типа `matrix()` чтобы обнулить матрицу - плохо, потому что непонятно. Лучше использовать метод типо `matrix.clean()`.

## Перегрузка операций преобразования типа
Ф-ция перегрузки не возвращает значения тк компилятор и так понимает какой тип будет возвращен. Определяется так: `operator int(){}` (через пробел).
```cpp
class Dollars
{
private:
    int m_dollars;
public:
    Dollars(int dollars=0)
    {
        m_dollars = dollars;
    }
 
    // Перегрузка операции преобразования значений типа Dollars в значения типа int 
    operator int() { return m_dollars; }
 
    int getDollars() { return m_dollars; }
    void setDollars(int dollars) { m_dollars = dollars; }
};
```
Что важно, компилятор теперь будет сам автоматически преобразовывать class Dollars->int, когда это необходимо. 
```cpp
Dollars dollars(9);
//пусть ф-ция определена как printInt(int smth)
printInt(dollars); // ОК! Выведется 9. Компилятор автоматически вызовет перегруженное преобразование типа

int d = static_cast<int>(dollars); //Тоже ОК! А тут мы явно преобразовали тип
```
Таким образом **можно определить преобразование и в пользовательские типы данных**. Например, для класса выше преобразование в class Cents:
```cpp
class Cents
{
private:
    int m_cents;
public:
    Cents(int cents=0)
    {
        m_cents = cents;
    }
 
     // Выполняем конвертацию Cents в Dollars
     operator Dollars() { return Dollars(m_cents / 100); }
};
```

## Перегрузка оператора ->
Для этого оператора существует синтаксическое требование (иначе компилятор будет ругаться): этот **оператор должен возвращать указатель на объект**. Этот **оператор всегда используется для доступа к полям класса**, поэтому если есть необъходимость его перегрузки (например для работы с памятью), то надо соблюдать эту логику. Пример,
```cpp
//если некий класс Data
Data * data_;
Data * operator->() const {return data_;}
```

## Перегрузка оператора присваивания = 
(скоприронно из [главы про классы](https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/Chapter6_Classes.md), раздел про конструктор копирования, для удобства и чтобы не нарушалась логика повествования)           
Логически оператор присваивания = тесно связан с конструктором копирования. Принципиальная разница в том, что конструтор копирования вызывается на новый объект, если некий объект уже существует, то это просто присвивание.
- Если новый объект создан во время выполнением операции копирования, то используется конструктор копирования (передача или возврат объектов выполняются по значению). Например, `Data dt = Data{1,2,3};`
- Если создания нового объекта не было, а работа ведётся с уже существующим объектом, то используется оператор присваивания. Например,
	```cpp
	Data dt1{1,2,3};
	Data dt2;	//объект создан конструктором по-умочанию, заполнен по-умолчанию
	Data dt2 = dt1; //присваивние
	
	Data dt3 = dt1	//копирование, тут вызывается конструктор копирования
	```
### Присваивание по-умолчанию     
Как и в случаи конструктора копирования, если оператор = не переопределн, то компилятор сам произведет почленное копирование.      

### Проблемы при работе с памятью      
При копировнии одного экзепляра класса с динамической памятью в другой произойдет утечка памяти, так как мы потеряем указатель на один из их участков динмической памяти (оба указателя будут указывать на второй участок). Решить это можно перегрузкой оператора присваивания. Например,
```cpp
IntArray & operator =(IntArray const & a)
{
	if ( this != &a)	//проверяем чтобы не произошло самоприсваивание; типо a=a;
	{
		delete [] data_;
		size_ = a.size_;
		data_ = new int[size_];
		for ( size_t i = 0; i != size_; ++i)
			data_[i] = a.data_[i];
	}
return * this ;
}
```
Важно убедиться, чтобы не произошло **самоприсваивание** (те когда объект присваивается сам себе: a=a). Если это не проверить, то первой строчкой delete [] мы сами себя удалим, и вернем указатель на пустой объект. Обработать это случай можно как в примере выше:
```cpp
if(*this != a){//тело оператора}
return *this;
```
Мы всегда возвращаем `*this`, чтобы можно было создавать цепочки вызовов, например, `dt1 = dt2 = dt3 = dt4;`. При этом копирование в левосторой объект происходит внутри тела оператора (для этого мы и передаем про объект по ссылке, чтобы его менять).

### delete    
Аналогично конструктору копирования, можно запретить использования оператора присваивания, например, если мы не хотим его переопределять, но и не хотим, чтобы компилятор производит автоматическое почленное копирование:
```cpp
IntArray & operator =(IntArray const & a) = delete; //теперь любая попытка присвоить объект вызовет ошибку
```
