# Chapter 15: Inheritance
## Общее
В C++ логика наследования потроена на принципе "является", те пусть есть класс Human(имеет age, name) и класс Employee (имеет age, name, id, salary). В этом случаии логично сделать Employee подклассом Human (те Employee является Human, тк у них совпадают поля age, name). Реализовывается это так: `ChildClassName :access_specifier ParetClassName` (`access_specifier`: `public`, `private` или `proteсted`) Например,
```cpp
class Human
{/*опустим его тело*/}

class Employee: public Human    //Employee наследует от класса Human (со спецификатором public)
{/*опустим его тело*/}
```
### Liskov Substitution Principle (LSP) (или Принцип подстановки Барбары Лисков)
Это правило по которому следует выбирать: наследование или агрегация. *"Ф-ции, работающие с базовым классом, должны иметь возмодность работать с подклассами не зная об этом"*. Это значит, что базовые ф-ции должны иметь полную совместимость с дочерним классом (работать без изменений). Также нельзя сокращать функционал/закрывать доступ к ф-циям базового класса из для объектов дочернего. Если эти условия не выполнены, то следует использовать агрегацию вместо наследования (подробнее про агрегацию [тут](https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/Chapter1_General.md#c%D0%B2%D1%8F%D0%B7%D0%B8-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0%D0%BC%D0%B8-%D0%B2-c)). 

## Порядок построения дочерних классов
При наследовании Child класс не копирует поля и методы Parent класса. Вместо этого можно рассматривайь Child как класс, который состоит из двух частей: первая — Parent, вторая — Child. При этом у них свои отдельные поля, методы, конструкторы и декструкторы. Пусть, например, у нас есть следующие Parent и Child классы:
```cpp
class Parent
{
public:
    int m_id;                             //поля Parent
 
    Parent(int id=0)                      //констркутор Parent
        : m_id(id)
    {
        std::cout << "Parent\n";
    }
 
    int getId() const { return m_id; }     //методы Parent
};
 
class Child: public Parent                 //Child наследует от Parent
{
public:
    double m_value;                        //поле Child
  
    Child(double value=0.0)                //конструктор Child
        : m_value(value)
    {
        std::cout << "Child\n";
    }
 
    double getValue() const { return m_value; }
};
 
int main()
{
    std::cout << "!!!Instantiating Parent!!!:\n";
    Parent dParent;    // Создаем экземпляр класса Parent 
    
    std::cout << "!!!Instantiating Child!!!:\n";
    Child dChild;      // Создаем экземпляр класса Parent 
 
    return 0;
}

/* Будет выведено *******************************
!!!Instantiating Parent!!!:
Parent
!!!Instantiating Child!!!:
Parent    //те сначала выполнился конструктор Parent
Child     //потом выполнился конструктор Child
************************************************/
```
**Создаем экземпляр класса Parent**      
Что происходит:
1. выделяется память для объекта parent;
2. вызывается соответствующий конструктор класса Parent (если его нет, то компилятор вызовет конструктор по умолчанию);
3. список инициализации инициализирует переменные;
4. выполняется тело конструктора;
5. точка выполнения возвращается обратно в caller.

**Создаем экземпляр класса Child**
Что происходит: 
1. выделяется память для объекта дочернего класса (достаточная порция памяти для части Parent и части Child объекта класса Child);
2. вызывается соответствующий конструктор класса Child;
3. создаётся объект класса Parent с использованием соответствующего конструктора класса Parent (как указано выше). Если такой конструктор программистом не предоставлен явно, то будет использоваться конструктор по умолчанию класса Parent;
4. список инициализации инициализирует переменные класса Child;
5. выполняется тело конструктора класса Child;
6. точка выполнения возвращается обратно в caller.

### Инициализация членов родительского класса при наследовании
Для членов уникальных для Child класса (не наследованных) все инициализуется как обычно. Однако инициализация членов Parent класса имеет свои особенности: они всегда должны быть инициплизованны через список инициализации *используя конструктор класса Parent* (см. выше: шаг 3 создания экземпляра Child). Если у Parent нет подходящего конструктора, то компилятор сгенерирует сам, однако его повидение может не соответствовать ожиданиям, поэтому лучше самому написать хороший. Ниже представлены три варианта попытки инициализировать члены класса Parent при создании Child (1я правильная, 2я и 3я - неправильно!):    

1. 
    ```cpp
    // 1й пример (ОК!): используя список инициализации и конструктор Parent
    class Child: public Parent
    {
    public:
        double m_value;

        Child(double value=0.0, int id=0)
            : Parent(id), // вызывается конструктор Parent(int) со значением id!
                m_value(value)
        {
        }

        double getValue() const { return m_value; }
    };
    ```
    Тут все правильно, но нужно убедиться, что у Parent есть хороший конструктор. C++ запрещает дочерним классам инициализировать наследуемые переменные-члены родительского класса в списке инициализации своего конструктора. Другими словами, **значение переменной может быть задано только в списке инициализации конструктора, принадлежащего к тому же классу, что и переменная-член** (ошибка в примере 2). Тут так же не возникнет проблемы с доступом к членам Parent (они могут и, скорее всего, будут private), как в примере 3. Таким способом можно и нужно инициализировать члены Parent, как public, так и private.
2. 
    ```cpp
    //2й пример (ОШИБКА!): используя список инициализации и прямую инициализацию члена Parent
    class Child: public Parent
    {
    public:
        double m_value;

        Child(double value=0.0, int id=0)
            // Не сработает
            : m_value(value), m_id(id)
        {
        }

        double getValue() const { return m_value; }
    };
    ```
    Как было сказано выше, C++ запрещает инициализировать напрямую члены класса Parent. Для этого надо использовать конструктор. Таким образом не нарушается проблема инициализации private членов Parent класса. Инкапсуляция!

3. 
    ```cpp
    //3й пример (ОШИБКА!): используя тело конструктора
    class Child: public Parent
    {
    public:
        double m_value;

        Child(double value=0.0, int id=0)
            : m_value(value)
        {
            m_id = id;
        }

        double getValue() const { return m_value; }
    };
    ```
    До тела конструктора Child мы доходим уже после вызова конструктора Parent класса и списка инициализации Child (см. шаги выше). Это значит, что m_id уже был создан дефолтным конструктором Parent, а теперь в теле мы пытаемя его инициализировать, но мы не знаем, может он private. Вообще говоря, код скомпилируется, если m_id - public, но будет ошибка, если он private. В любом случаии - это плохой код!

### Цепочка наследований
#### Конструкторы
Пусть у нас есть Parent класса A, от него наследуют B. От B наследует C. В этом случаии цепочка расскручиваестя следующим образом: C вызывает конструктор для B, тот в свою очередь вызывает конструктор для A. 
```cpp
class A
{
public:
    A(int a)
    {
        std::cout << "Construct A" << std::endl;
    }
    ~A()
    {
        std::cout << "Destruct A" << std::endl;
    }
};
 
class B: public A
{
public:
    B(int a, double b)
    : A(a)
    {
         std::cout << "Construct B" << std::endl;
    }
    ~B()
    {
       std::cout << "Destruct B" << std::endl; 
    }
};
 
class C: public B
{
public:
    C(int a , double b , char c)
    : B(a, b)
    {
         std::cout << "Construct C" << std::endl;
    }
    ~C()
    {
        std::cout << "Destruct C" << std::endl;
    }
};

int main()
{
    { //construct C
        C c(1, 2.2, 'a');
    } //destruct C
}

/* Будет выведено **************
Construct A
Construct B
Construct C
Destruct C
Destruct B
Destruct A
*******************************/
```

#### Деструкторы
При уничтожении дочернего класса, каждый деструктор вызывается в обратном порядке построения классов: "изнутры-наружу". В примере выше, при уничтожении объекта класса С, сначала вызывается деструктор класса C, затем деструктор класса B, а затем уже деструктор класса A.

### Приведение (преобразование) классов
При наследовании возможно преобразование к родительскому типу (те Child -> Parent), но не наоборот (Parent -> Child нельзя). При этом сохраняется только срез (те часть класса родителя). Пусть, например, у нас есть родительский класса Person (поля: Name, Age) и наслединик Student (поля: Name, Age, University). Тогда,
```cpp
Student s("Alex", 21, "Oxford");
Person & l = s; 	// Student & -> Person & (ссылка на класс Person)
Person * r = &s; 	// Student * -> Person * (указатель на класс Person)
//объекты класса-наследника могут присваиваться объектам родительского класса:
Person p = s; // Person("Alex", 21); // инициализация копированием класса Person классом Student. вызывается конструктор копирования Person
```
При этом копируются только поля класса-родителя (срез). Т.е. в данном случае вызывается конструктор копирования `Person(Person const& p)`, который не знает про поле University.

## Спецификаторы наследования
### Спецификаторы доступа
Классы имеют 3 вида спецификаторов доступа: public, private и protected (имеет смысл лишь в контексте наследования). **Protected** - это спецификатор, который ведет себя как private (запрещает доступ к челенам извне), однако, когда класс наследуется, то Child класс имеет доступ к protected членам Parent. Еще раз, пусть у нас есть некоторый член в классе Parent (my_field). Если переменная имеет следующий спецификатор доступа, то:
1. `public` - Child имеет доступ к ней. Child также предоставляеть к ней доступ извне: `child.my_field`.
2. `private` - Child не имеет доступ к ней. Child не может предоставить к ней доступ извне.
3. `protected` - Child имеет доступ к ней. Однако, Child *не может предоставить к ней доступ извне*.

Например,
```cpp
class Parent
{
public:
    int m_public;           // доступ к этому члену открыт для всех объектов
private:
    int m_private;          // доступ к этому члену открыт только для Parent
protected:
    int m_protected;        // доступ к этому члену открыт для Parent и для дочерних классов (Child)
};
 
class Child: public Parent
{
public:
    Child()
    {
        m_public = 1;       // МОЖНО: доступ к открытым членам родительского класса из дочернего класса
        m_private = 2;      // НЕЛЬЗЯ: доступ к закрытым членам родительского класса из дочернего класса
        m_protected = 3;    // МОЖНО: доступ к защищённым членам родительского класса из дочернего класса
    }
};
 
int main()
{   // При доступе извне дочернего класса
    Parent parent;
    parent.m_public = 1;    // МОЖНО: доступ к открытым членам класса извне
    parent.m_private = 2;   // НЕЛЬЗЯ: доступ к закрытым членам класса извне
    parent.m_protected = 3; // НЕЛЬЗЯ: доступ к защищённым членам класса извне
    
    Child child;
    child.m_public = 4;     // МОЖНО: доступ к открытым членам класса извне
    child.m_private = 5;    // НЕЛЬЗЯ: доступ к закрытым членам класса извне
//  child.m_protected = 6;  // НЕЛЬЗЯ: доступ к защищенным членам класса извне
}
```
### Типы наследований
При этом используются те же 3 типа наследования: public, private и protected. Они могут накладывать свои особенности и Parent спецификаторы доступа.
#### public (открытое наследование)
```cpp
class Child: public Parent // открытое наследование
```
Если Child наследуют открыто, то Parent спецификаторы доступа действуют так же, как обычно (см. выше). 
| Тип члена в Parent | Какой тип этот член имеет в Child |
|:-------------------|:----------------------------------|
| public | public |
| private | недоступен |
| protected | protected |     

Те, если Child унаследовал protected член через public наследование, то он так же может передать его следующему классу-наследнику (в цепочке наследования) как protected.

#### private (закрытое наследование)
При закрытом наследовании все члены родительского класса наследуются как закрытые. Это означает, что члены private остаются недоступными, а члены protected и public становятся private в дочернем классе (те, Child имеет к ним доступ, но нет доступа извне через экземпляры Child). 

| Тип члена в Parent | Какой тип этот член имеет в Child |
|:-------------------|:----------------------------------|
| public | private |
| private | недоступен |
| protected | private |

#### protected (ащищённое наследование)
С защищённым наследованием, члены public и protected становятся protected, а члены private остаются недоступными.
| Тип члена в Parent | Какой тип этот член имеет в Child |
|:-------------------|:----------------------------------|
| public | protected |
| private | недоступен |
| protected | protected |

#### Тип наследования по дефолту (без явного указания)
Для структур дефолтный тип (без явного указания) наследования - `public`. Для классов дефолтный тип - `private`.
```cpp
class C : B 	// B private by default
{ / ... / }; 
struct S : B 	// B public by default
{ / ... / }; 
```

#### Пример цепочки
```cpp
class Parent
{
public:
	int m_public;
private:
	int m_private;
protected:
	int m_protected;
};

class D2 : private Parent  // закрытое наследование
{
	// Закрытое наследование означает, что:
	// члены m_public и m_protected становятся private в дочернем классе;
	// члены m_private недоступен для дочернего класса.
public:
	int m_public2;
private:
	int m_private2;
protected:
	int m_protected2;
};

class D3 : public D2
{
	// Открытое наследование от D2 означает, что:
	/* Члены из D2: */
    // m_public2 остается public в D3 классе;
    // m_private2 остается private в D3 классе;
    // m_protected2 остается protected в D3 классе;
    
    /* Члены из Parent: */
	// m_public, m_protected и m_private - недоступны в D3 
public:
	int m_public3;
private:
	int m_private3;
protected:
	int m_protected3;
};
```

## Переопределение методов родительского класса 
При вызове метода через объект дочернего класса, компилятор сначала смотрит, существует ли этот метод в дочернем классе. Если нет, то он начинает продвигаться по цепочке наследования вверх и проверяет, был ли этот метод определён в любом из родительских классов. Использовать компилятор будет первое найденное определение.     

Чтобы переопределить родительский метод в Child классе, надо просто определить его как обычный метод, будто родительского метода и не было:
```cpp
class Parent
{
public:
    {
    }
 
    void identify() { std::cout << "I am a Parent!\n"; }
};

class Child : public Parent
{
public:
    Child()
    {
    }
    // Вот наш изменяемый метод родительского класса. Просто определяем его будто и не видели его никогда
    void identify() { std::cout << "I am a Child!\n"; }
};
```
- Когда мы переопределяем родительский метод в дочернем классе, то *дочерний метод не наследует спецификатор доступа родительского метода с тем же именем*. Используется тот спецификатор доступа, который указан в дочернем классе. Таким образом, метод, определённый как private в родительском классе, может быть переопределён как public в дочернем классе, или наоборот!
- Чтобы "расширить" родительский метод (те не переписывать его заново, а просто добавить что-то), можно просто внутри Child метода вызвать родительский метод:
	```cpp
	void identify()
	{
        	Parent::identify(); // сначала выполняется вызов Parent::identify() 
        	std::cout << "I am a Child!\n"; // затем уже вывод этого текста
	}
	```
- Если мы переопределяем ф-цию чтобы она принимала другой тп данных, но все же хотим, чтобы можно было зываеть ее и со сатрыи типом данных, то нужно включить протопип родительского метода. Наример,
	```cpp
	struct File {
		void write( char const * s);
	...
	};
	struct FormattedFile : File {
		void write(int i);
		void write( double d);
		...
	};

	int main()
	{
		FormattedFile f;
		f.write(4);		//ОК вызовет write(int i);
		f.write("Hello");	//НЕ ОК. Ф-ция write была переопределена и теперь у нее нет сигнатуры write(char *s);
	}
	```
	Можно это поправить дополнив прототипом нужной сигнатуры (`using File::write;`):
	```cpp
	struct FormattedFile : File {
		void write(int i);
		void write( double d);
		using File::write;
		...
	};
	```

### Изменение спецификатора доступа при переопределении метода (и сокрытие метода)
C++ предоставляет возможность изменить спецификатор доступа родительского члена в дочернем классе помощью using declaration. Например, можено сменить protected в родительском на public в Child (в примере, printValue()). **Сокрытие** - если мы хотим скрыть доступ какому-то открытому методу, то можно переопределить его доступ в private (в примере, doSmth()). Пример,
```cpp
class Parent
{
private:
    int m_value;
 
public:
    Parent(int value)
        : m_value(value)
    {
    }
 
protected:
    void printValue() { std::cout << m_value; }
    void doSmth() {std::cout << "Ain't doing anything;}
};

class Child: public Parent
{
public:
    Child(int value)
        : Parent(value)
    {
    }
    
    // Parent::printValue является protected, поэтому доступ к нему не является открытым для всех объектов
    // Но мы можем это исправить с помощью using declaration
    using Parent::printValue; // обратите внимание, нет никаких скобок

private:
    using Parent::doSmth; // скрыли метод doSmth
};
```

## Множественное наследование
Множественное наследование позволяет одному дочернему классу иметь несколько родителей. Предположим, что мы хотим написать программу для отслеживания работы учителей. Учитель — это Human. Тем не менее, он также является Сотрудником (Employee). Реализуется как и обычная, но через запятую (для каждого указываем тип наследования):
```cpp
class Teacher: public Human, public Employee
{//опустим тело}
```
На самом деле, надо избегать этот случай тк может могут возникнуть множество проблем. Например, проблема конфликта имен у родителських методов. Если у родителей совпали имена методов, а у Child его нет, то возникнет ошибка: компилятор не будет знать какому из родителей отдать предпочтение: он равны в иерархии наследования. 

### Diamond of doom
<img src="https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/images/Diamond_inheritance.png" alt="Diamond_of_doom" width="200"/>
Это проблема возникает, когда два родителя (B и C) наследуют от одного про родителя (D). И в итоге они все встречаются в Child классе (A), те он наследует прородителя дважды. 

### Виртуальный базовый класс
При образовании цепочки наследований может возникнуть ситуация "алмаз сметри": когда некоторый класс наследует от двух дочерних, которые имеют общего родителя. В этом случаии поведение класса непредсказуемо. Например:
```cpp
class PoweredDevice
{
public:
    PoweredDevice(int power)
    {
		std::cout << "PoweredDevice: " << power << '\n';
    }
};
 
class Scanner: public PoweredDevice
{
public:
    Scanner(int scanner, int power)
        : PoweredDevice(power)
    {
		std::cout << "Scanner: " << scanner << '\n';
    }
};
 
class Printer: public PoweredDevice
{
public:
    Printer(int printer, int power)
        : PoweredDevice(power)
    {
		std::cout << "Printer: " << printer << '\n';
    }
};
 
class Copier: public Scanner, public Printer
{
public:
    Copier(int scanner, int printer, int power)
        : Scanner(scanner, power), Printer(printer, power)
    {
    }
};
```
В этом случаии программист ожидает, что класс Copier будет иметь 1 PowerDevice в наследуемой части (1й рисунок). На самом же деле, родительские классы Printer и Scanner каждый сконструирует по одному PowerDevice для себя и получится, что у класса Copier будет 2 PowerDevice (2й рисунок).       

<img src="https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/images/diamond-of-death-cpp.jpg" alt = "diomon_of_death" width = "1000" />    

Так, результатом следующего кода будет:
```cpp
int main()
{
    Copier copier(1, 2, 3);
}
/***
PoweredDevice: 3
Scanner: 1
PoweredDevice: 3
Printer: 2
***/
```
Решением данного безобразия является **виртуальный базовый класс**. **Виртуальный базовый класс** — это класс, объект которого является общим для использования всеми дочерними классами.
```cpp
class PoweredDevice
{//ваш код мог бы быть здесь};

class Scanner: virtual public PoweredDevice
{//ваш код мог бы быть здесь};
 
class Printer: virtual public PoweredDevice
{//ваш код мог бы быть здесь};
 
class Copier: public Scanner, public Printer
{//ваш код мог бы быть здесь};
```
Теперь, при создании класса Copier, мы получим только одну копию PoweredDevice, которая будет общей как для Scanner, так и для Printer (1й рисунок). 

#### Особенности
1. В отличии от обычного наследования, тут конструктор виртуального базового класса вызывается самым дочерним классом, а нижлежащие классы игнорируют его у констрктор у себя. Те в нашем примере, при создании Copier коструктор Copier напрямую вызовет коструктор PowerDevice (это единственный случай, когда класс может вызывать конструтор чужого класса). При этом конструкторы Scanner и Printer не будут вызывать конструктор PowerDevice (хотя в обычном случаии вызвали бы). Важно отметить, что если бы мы создавали объекты класса Scanner или Printer, то конструктор PowerDevice вызывался бы по-нормальному.
2. Самый дочерний класс вызывает конструктор виртуального базового класса. То если в нашем случаии Copier. Это работает даже в случае одиночного наследования: когда Copier наследует только Printer, а Printer виртуально наследует PoweredDevice, то Copier по-прежнему ответственный за создание PoweredDevice.
3. Виртуальные базовые классы всегда создаются перед не виртуальными базовыми классами, что обеспечивает построение всех базовых классов до построения их производных классов.

## Обрезка объектов (object slicing)
Как упоминалось выше любой дочерний объект имеет родительскую и собственную части. Если указателю или ссылке на родителський класс присвоить объект дочернего класса, то этот указатель/ссылка будет указывать на родительскую часть дочернего класса (не создаст новый объект):
```cpp
class Parent
{ //some code here };

class Child: public Parent
{ //some code here };

int main()
{	
	Child ch;
	Parent &par = ch;	//все ок
	Parent *pptr = &ch;	//все ок
}
```
Если скопировать объект типа Child в объект типа Parent, то скопируется только Parent часть. При этом возникнет проблема с тем, что объект потеряет указатель на виртуальную таблицу и, соответвенно, не сможет использовать виртуальные ф-ции. Например:
```cpp
class Parent
{
protected:
    int m_value;
public:
    Parent(int value)
        : m_value(value) 
    {}
    virtual const char* getName() const { return "Parent"; }
    int getValue() const { return m_value; }
};
 
class Child: public Parent
{
public:
    Child(int value)
        : Parent(value)
    {}
    virtual const char* getName() const { return "Child"; }
};

int main()
{
    Child child(7);
    Parent parent = child; // простое копирование (не указатель или ссылка) -> простое копирование -> невозможность вызвать виртуальную ф-цию 
    std::cout << "parent is a " << parent.getName() << " and has value " << parent.getValue() << '\n';
 
    return 0;
}

/*** Выведет
parent is a Parent and has value 7
***/
```
Более толковым примерои будет передача аргумента в ф-цию по значению:
```cpp
void printName(const Parent parent) // примечание: передача по значению
{
    std::cout << "I am a " << parent.getName() << '\n';
}
```
Тут произойдет обычное копирование, при этом наш класс потеряет возможность вызывать виртуальные ф-ции.      
**Вывод: никогда не использовать передачу по значению для классов, а также не присваивать объект дочернего классов объекту родительского**. Это не полиморфично! **Надо всегда передавать классы в ф-цию по ссылке (или по указателю)**.

## dynamic_cast и static_cast
Пусть у нас есть указатель Parent класса, указывающий на объект Child класса, но мы хотим получить указатель типа Child на этот объект. В этом случаии нам нужно использовать преобразование типов: те надо преобразовать указатель Parent в указатель Child. Тут подойдет любой из этих двух операторов: `dynamic_cast<>()` и `static_cast<>()`. Например, 
```cpp
Parent* getObject(bool bReturnChild)
{
	if (bReturnChild)
		return new Child(1, "Banana");
	else
		return new Parent(2);
}
int main()
{
	Parent *p = getObject(true); 		//возвращает объект класса Child
	Child *ch1 = dynamic_cast<Child*>(p);	//преобразовываем указатель
	Child *ch2 = static_cast<Child*>(p);	//получим то же самое
	return 0;
}
```
В этом примере конвертация:
- Из Child в Parent - это **приведение к базовому типу** (или ещё **повышающие приведение типа**).
- Из Parent в Child - это **приведение к дочернему типу** (или ещё **понижающие приведение типа**).

### dynamic vs static 
Если невозможно совершить конвертацию объекта, то оба оператора не вызовут ошибки и программист может не понять, что произошел косяк. Разница между ними в том, что, если `dynamic_cast<>()` не может совершить конвертацию объекта (например, если указатель Parent указывает на объект Parent, а конвертируем мы в указатель Child), то он возвращает нулевой указатель, в то время как `static_cast<>()` не дает возможность проверки результата. Так, например, можно проверить получилось ли преобразование или нет:
```cpp
int main()
{
	Parent *p = getObject(true);
        Child *ch = dynamic_cast<Child*>(p); // используем dynamic_cast для конвертации указателя класса Parent в указатель класса Child
        if (ch) // выполняем проверку ch на нулевой указатель
            std::cout << "The name of the Child is: " << ch->getName() << '\n';
	return 0;
}
```
- Несмотря на то, что, `dynamic_cast<>()` работает немного медленнее, `static_cast<>()` стоит использовать только, когда очевидно, что будет получен желаемый результат (например, при конвертации стандартных и совместимых типов: int->float и тп). **Если же идет работа с наледованием, а тем более с виртуальными ф-ция, то следует использовать `dynamic_cast<>()`**.
- Для корректной работы `dynamic_cast<>()` нужно, чтобы радительский тип **содержал хотябы один виртуальный метод** (те был полиморфным).
