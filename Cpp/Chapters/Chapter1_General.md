# Chapter 1 General 
## Важные понятия и термины
- **Integral data type** - типы данных основанных на целых числах (char, short, int, long, long long, enum). 
- **Блок стейтментов** (или ещё **«составной оператор»**) обрабатывается компилятором так, как если бы это был один стейтмент. Составные операторы помещаются в фигурные скобки ({ и }) и используются почти везде. Блок ({}) может выделять локальные области сам по себе (т.е. не являясь частью ф-ции).
- **Литеральные константы** (или просто **«литералы»**) — это значения, которые вставляются непосредственно в код (напр., 3.141 - это литерал типа float, 'A' - это литерал типа char. Т.е. литерал чистай все что угодно в коде(?))   
- **Магические числа (magic numbers)** - числа, которые встречаются в коде без пояснения и непонятно что они делают. Это делает код нечитаемым. Поэтому лучше всегда присвоить значение переменной с ясным названием, чем использовать голые числа.   

---

- **Время компиляции**: когда вы находитесь в процессе компиляции программы, то это время компиляции (англ. «compile time»). Компилятор проверяет вашу программу на синтаксические ошибки и, если их нет, конвертирует код в объектные файлы. **Константы времени компиляции**: их значения определяются во время компиляции программы. Например, переменная, значение которой было задано до с самого начала.   
- **Время выполнения**: когда вы находитесь в процессе запуска вашей программы или когда ваша программа уже выполняется, то это время выполнения (англ. «runtime»). Код выполняется строка за строкой. **Константы времени выполнения**: их значения определяются только во время выполнения программы (например, если пользаватель вводит данные через cin или программа сама высчитывает какое-то значение.     

---

- Переменные с **автоматической продолжительностью** создаются в точке определения и уничтожаются при выходе из блока, в котором определены. Это - обычные локальные переменные.   
- Переменные со **статической продолжительностью** создаются, когда программа запускается, и уничтожаются при её завершении. Это - глобальные переменные, статические локальные переменные.   
- Переменные с **динамической продолжительностью** создаются и уничтожаются по запросу программиста.   

- **Статическое выделение памяти** выполняется для статических и глобальных переменных. Память выделяется один раз, при запуске программы, и сохраняется на протяжении работы всей программы.
- **Автоматическое выделение памяти** выполняется для параметров функции и локальных переменных. Память выделяется при входе в блок, в котором находятся эти переменные, и удаляется при выходе из него.    
В обих случаях (1 и 2) память выделяется из **стека (stack)**. Его рамер зависит от компилятора, но всегда очень мал (порядка 1-2 МБ).
- **Динамическое выделение памяти** - это способ запроса памяти из операционной системы запущенными программами по надобности. Эта память не выделяется из ограниченной памяти стека программы, а из гораздо большего хранилища, управляемого операционной системой — **кучи** (порядка n-Гб).     

---

- **Dummy parameter** (параметр "заглушка"). Параметр, который не используется в ф-ции и нужен лишь для того, чтобы компилятор мог отличичать ф-ции по их типу: `int my_funct(char);` char - "заглушка".
- **Circular dependence** - когда несколько файлов для работы терубют подключить друг друга. Например, one.h подключает two.h, в то время как two.h требудет подключения one.h для работы. В этом случаии произойдет ошибка компиляции.

---

- **Shallow copying** (поверхностное копирование) - использование конструктора копирования и оператора присваивания по-умолчанию (те почленное копирование). В простых классах, которые не работают с памятью - это нормальная практика. Однако, в более сложных классах это может повлечь утекчу памяти.

- **Deep copying** (глубокое копирование) - переопределение конструктора копирования и оператора присваивания для работы со сложными классами, чтобы избежать утечки памяти.

## General structure
```cpp
#include <iostream>
using namespace std;

int x;                              //global variables
int z = 4;

int main() {
    x = 2;          
    int y = 3;                      //local variable (хотя и для main)
    cout << "Size of int: " << sizeof(int) << endl;  
    cout << (x - y)*z;
    return 0;
}
```
### Общий цикл написания программы
1. Пишем код в соответствии синтаксису. Сохраняем в формате *name.cpp*.
2. Компилятор: преобразует команды С++ в объектный файл (*.o*, машинный код). Из *name.cpp* создается *name.o* (или *name.obj*). Каждый файл *.cpp* конвертируется в свой *.o*. (Пока они не связаны).  Если в системе стоит компилятор, то из консоли можно это сделать (`-c`): `g++ -c file1.cpp file2.cpp file3.cpp`.
3. Линкер ("компоновщик"): объектные файлы и вызовы библиотек связываются в исполняемый файл (один). Т.е. до этого момента все файлы и библиотеки не видят друг друга, во время компановки они начинают взаимодействовать (передавать ф-ции и тд). На этом этапе происходит ошибка, если переменная или функция была объявлена, но не определена. Из консоли можно это сделать (`-o`): `g++ -o prog file1.o file2.o file3.o` (если из уже скомпилированы) или `g++ -o prog file1.cpp file2.cpp file3.cpp` (если еще не скомпилированы).

## Preprocessor -> compiler -> linker -> executable
![cpp_to_exe](https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/images/COMPILE.gif)
### Этапы преобразования .cpp -> .exe
Этапы **preprocessing** и **compilation** производит компилятор. Этап **linking** производит отдельная программа - **linker**.  

1. **Preprocessing** - это этап на котором препроцессор просматривает файл программы, ищет и выполняет все дерективы `#`. Препроцессор "не понимает" синтаксис c++ и читает все будто это обычный текст. Например, 
  ```
  #define sqr(x) x*x`
  int main()
  {
    return sqr(5);                  // вернет "5*5" (как текст)
    //return sqr(balls and cocks);  //вернет "balls and cocks*balls and cocks" (как текст)
  }
  ```
  Также препроцессор удаляет комментарии из файла. Обработанный препроцессором файл называется **translation unit** (or module), он далее передается компилятору.  
  - *Чтобы вывести translation unit в Visual Studio, нужно сделать следующее: project properties -> C++ -> preprocessing -> preprocess to a file. Выходной файл надо искать в папке проекта, в папке debug*.
  - *Чтобы получить translation unit вызывая компилятор из терминала, нужно сделать следующее: `g++ -E file_name.cpp -o preroc_file_name.cpp` (или `gcc` вместо `g++`). Тут `-E` команда для препроцессора, `-o` - команда чтобы создать output file.

2. **Compilation** - это этап на котором translation unit преобразуется в .obj файл, те преобразуется в машинный кода. Вообще говоря, этот код не human readable, но его можно сделать таковым, если включить assembly listing (т.е. human readable машинный код).
*Чтобы вывести object file на асемблере (т.е. human readable) в Visual Studio, нужно сделать следующее: project properties -> C++ -> outpit files -> assembler output -> on. Выходной файл надо искать в папке проекта, в папке debug*. В каждом объектном файле строиться последовательность команд, где на месте внешних ф-ций ожидается их адрес (будет добавлен на линковке).

3. **Linking** - это этап на котором происходит связка всех отдельных файлов в один. По сути линкер идет через файл и смотрит, есть ли вывозы объектов не входящих в данный файл. Если есть, то он начинает искать определение этого объекта в других файлах и стандартных библиотеках. Найдя это определение, линкер вставляет адрес данной ф-ции в место вызвова. Например,
```
int foo(int b)    //сама ф-ция лежит в другом файле
int main()
{
  foo(4);         //на этапе линкинга, сюда будет вставлен адрес ф-ции foo()
}
```   
Таким образом создается стэк вызовов. Некоторые библиотеки автоматически подключены и линкер будет искать ф-ции там (можео поменять в настройках VS). Однако, корректный способ подключать сторонние библиотеки - это использовать дерективу `#pragma comment(lib, "user32.lib")` тк это универсальный способ независящий от настроек IDE. 
 
### Facts about compilation
1. Компилируются только .cpp файлы. Header files (.h) не компилируются, они только добавляются в .cpp, когда это необходимо (`#include`). При добавлении, на этапе *препроцессинга*, все содержимое из .h просто копируется в .cpp на место, где находится деректива `#include`. Если один и тот же .h добавлется несколько раз в один .cpp, то возникнет проблема. Чтобы .h добавлялся лишь единожды в каждый .cpp используется деректива `#pragma once`.
2. Каждый .cpp файл компилируется отдельно от других. Вообще говоря, отдельные .cpp могут быть скомпилированы в разное время, на разные компьютерах. Таким образом он не знает о существовании других .cpp файлов до этапа *линкинига*. Отсюда вытекает необходимость делать **прототипы объектов** (функций, классов и т.д.), тк на этапе компиляции компилятор должен знать, что за функция используется в файле (те ее название, что она принимает и что она возвразает), чтобы проверить имеет ли ее вызов смысл. Однако, если вызываемая ф-ция из другого cpp файла с косяком, но ее прототип объявлен верно, то проблем на компиляции не будет. Возникнет проблема на этапе линкинга. 
3. На этапе компиляции имена ф-ций кодируются, чтобы все ф-ции имели уникальные имена. В C ф-ции с одинаковыми именами и так запрещены, но в C++ можно имень несколько ф-ций с одинаковым именем, если у них разные параметры. Поэтому компилятор кодирует ф-ции включая в назавания типы их параметров, чтобы создать уникальные имена для всех ф-ций. Например, `int foo(int a, double b)` будет закодирована как `_Z3fooid` (где `_Z` - какой-то код-префикс, `3` - длинна названия (те foo), `foo` - название, `id` - типы параметров (int и double)).
4. Стандартные библиотеки подключаются с помощью .h файлов, где просто перечислены прототипы соответствующих ф-ций, в то время как их реализация лежит в уже скомпилированом .cpp файле. Поэтому при подключении библиоте компиляция не замедляется, взаимодействие с библиотекой происходит на этапе линкинга. Таким образом основной код библиотек - уже хранится в виде машинного кода. Это способствует быстроте и помогает скрыть код, чтобы его не украли. Задача реверс инжиниринга (Decompilation/Reverse compilers) из машинного кода в ассембер, а потом в какой-либо язык высокого уровня - очень сложная, и скорее даже невозможная, тк будут утеряны многие элементы кода, такие как названия ф-ций, классов, переменных и тд.

### Компиляция из терминала

- **Preprocessing** Чтобы получить translation unit вызывая компилятор из терминала, нужно сделать следующее: `g++ -E file_name.cpp -o preroc_file_name.cpp` (или `gcc` вместо `g++`). Тут `-E` команда для препроцессора, `-o` - команда чтобы создать output file.
- **Compilation** Чтобы скомпилировать файлы по-отдельности нужно использовать команду `-c`: `g++ -c file_name.cpp`. На выходе получатся objective files (.o). Его можно сделать human readable (т.е. в assembly listing) используя команду на полученный .o файл:`objdump -d file_name.o`. Чтобы сразу скомпилировать human readable .o файл надо использовать команду `-S`: `g++ -S file_name.cpp`. Выдаст `file_name.s` - это assembly listing. На этом этапе, ф-ции кодируются, чтобы иметь уникальные имена. Чтобы раскодировать например ф-цию *_Z3fooid* надо: `c++filt -n _Z3fooid` (выдаст *foo(int, double)*).
- **Linking** Чтобы связать отдельные объектные файлы после компиляции, нужно натравить на всех них компилятор: `g++ main.o file_one.o file_two.o -o my_program` (получится один .exe).
- **Все вместе** Чтобы компилятор сделал все сам, надо просто натравить его на главный файл (с main()): `g++ main.cpp -o my_program`.
- *Раскодировать закодиро

## Сегментация памяти в C++
- По архитектуре фон Неймана (те все совремнные компьютеры) память - **однородна**: это значит, что команды (код) хранится в той же памяти, что и данные. Внешне эти участки памяти неразделимы. Вся память разделена на пронумерованные (т.е. с уникальным адресом) ячейки (это **принцип адресности**).   
- При выполнении программы C++ память разделяется на 3 сегмента (+сигмент, где лежит текст программы): 1. сегмент глобальных/static данных, 2. Стек (Stack), 3. Куча (Heap). Также можно потребовать от системы выделить динамическую память под нужды программы.

<img src="https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/images/Memory_map.png" alt="Memory_map" width="500" />

### Memory segments
#### Code (text) segment
Это сегмент постоянного размера, который выделяется для хранения текста программы.

#### Static segment
- Это сегмент постоянного размера. 
- Заполняется в момент запуска программы и очищается, когда она заканчивает работу.
- Сюда записываются все static и глобальные переменные/ф-ции. Поэтому их можно вызывать в любом месте программы, не создавая их экземпляры: они уже созданы и хранятся тут.

**Pros**     
- Большой участок памяти (до порядка нескольких гб)
- Быстрый доступ

**Cons**   
- Все, что туда записывается должно быть посчитанно at compile time.
- Все, что там записано - globally accessible (Danger! Danger!)
- Все, что там записано - занимает память до закрытия программы.

#### Stack segment 
##### Как хранит стек     
- Это сегмент данных, используемый для хранения локальных переменных и временных значений. 
- Стек выделяется при запуске программы и имеет небольшой по размеру (~ 4Мб).
- Стек заполняется "сверху-вниз" те из более высоких значений адресов в более низкий (см картинку) 

##### Что хранит стек     
- Функции хранят свои локальные переменные на стеке.
- При выходе из функции соответствующая область стека объявляется свободной (автоматическая чистка).
- Промежуточные значения, возникающие при вычислении сложных выражений, также хранятся на стеке.

##### Последовательность заполнения стека
![Stack_cpp](https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/images/Stack_cpp.jpg)
Тут зеленым выделено то, что отностится к ф-ции main, а фиолетовым то, что отнотися к foo. Последовательнотсь заполнения стека следущая:
1. *(1-2 ячейки)* Выделятся и заполняется место для локальных переменных данной ф-ции (те main). 
2. *(3-5 ячейки)* Выделяется место для переменных передоваемых в foo(int a, int b, bool c). Причем последовательность сохранения в стеке - обратная (те сначала bool c, потом int b и в конце int a). Это нужно, чтобы можно было вызывать ф-ции с непредопределенным кол-вом аргументов.  
3. *(6-8 ячейки)* Выделяется место для возвращаемого значения (ret val): сюда будет сохранен результат возврощаемый ф-цией. Место для адреса возврата (ret addr): т.е. адреса куда вернется выполнение программы после завершения данной ф-ции. Также резервируется память для регистров (reserved registers): эти регистры (и их память) будут использоваться для всяких операций (например математических) внутри блока (см подробнее в [assembly](https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm). 
4. *(9-10 ячейки)* Это уже переменные внутри ф-ции foo(). Пока она будет выполнятся выделится также временные ячейки для сохранения результатов внутренних вычислений. 
5. Когда foo() завершится, ее ячейки (9-10) будут освобождены, а возвращаемое значение сохранено в ячейку ret val.
6. В конце произойдет чистка: ячейки с информацией о foo() (т.е. ячейки 6-8) будут удалены, а значение из ret val сохранено в ячейку с локальной переменной x. Также будут удалены ячейки 3-5, где были переменные, с которыми вызывалась foo(). В итоге останутся только ячейки 1-2. 

----

- **Важно!** После отчистки стека от вызова предшествующих ф-ций, память не отчищается, а просто перезаписывается следующей ф-цией. Поэтому, если новая переменная объявлена, но не инициализированная, то в ней будет не мусор, а значение схожей переменной из предшествующих ф-ций. 
- **Перезапись стека**. Память стека заполняется последовательно (плотно). Поэтому существует шанс случайно/специально выйти за границы памяти, отведенной данному объекту (например, выйти за границы массива), и перезаписать "чужой" участок памяти. На этом простоена "уязвимость переполнения буфера": специально выйдя за границу массива, можно попасть в ячейке ret addr и записать тут адрес вредоносной ф-ции. Поэтому при выходе и данной ф-ции, программа попадет не назад в main, а в вредоносную ф-цию и выполнет ее.
- **Pointers** Есть 3 указателя (на картинке 2): 1) *Frame pointer* (он же *base pointer* он *же ebp*) - определяет границы локальный видимости данной ф-ции. Те в его пределах сохраняются только локаные переменные этой ф-ции. 2) *Stack pointer* (он же *esp*) - указывает на нижнюю границу стэка, ниже память пуста. 3) *Indication pointer* (или как-то так) - указывает на участок памяти (те какой-то объект), обрабатываемый в данный момент.       
##### frame pointer он же base pointer он же ebp
Так как на стэке память выделяется последовательно всем объектам внутри блока (frame), то адреса этих объектов отсчитываются от frame pointer. Те пусть мы вызываем из ф-ции A() другую ф-цию B(), а вней создаем 2 переменные типа int (4 байта каждая):
```cpp
B() //вызвана из A()
{
    int a = 5;
    int b = 10;
}
```
Таким образом при входе в B() frame pointer: `ebp` устанавливается на начало ф-ции B(). При этом вся ф-ция A() лежит ниже по стэку. Теперь, выдется память на int a: 4 байта, те 4 ячейки память (тк каждая из них - это 1 байт). Те переменная a сохраняется по адресу: `[ebp - 4]` (вычитаем тк стэк отсчитывается "сверху-вниз" те заполение идет к более низким адресам). Далее еще 4 байта выделсяется для int b. Адрес переменной b: `[ebp - 8]`. Те **отсчет адреса внутри блока идет от frame pointer, указывающего на начало блока**.

## Проблемы неоднозначности кода
В C++ существует парадигма: **Если что-то похоже на объявление функции, то это и есть объявление функции**.
```cpp
/* Пусть есть некоторый класс Point с двумя констректорами: дефолтный (не принимает ничего)
и конструктор принимающий один параметр */

Point p1;   // определение переменной (вызов дефолтного конструктора)
Point p2(); // объявление функции
double k = 5.1;
Point p3(int(k));   // объявление функции
Point p4(( int)k);  // определение переменной (вызов конструктора)
```

## Cвязи между объектами в C++
**Композиция**(Composition) - отношения прямой зависимости простых переменных от класса-хозяина.
-    Используются обычные переменные-члены.
-    Используются указатели, если класс реализовывает собственное управление памятью (происходит динамическое выделение/освобождение памяти).
-   Класс ответственный за создание/уничтожение своих частей.     

**Агрегация**(Aggregation) - отношения, где один отдельный класс зависим от другого по типу "Имеет". Иначе говоря, объект некоторого класса является полем другого класса. Например, класс Vec2 для описания координат персонажа, является полем в классе Character.
- Внешний класс несёт ответственности за создание/уничтожение своих полей.
- Когда лучше пользоваться наследованием, а когда агрегацией? См [Liskov Substitution Principle (LSP)](https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/Chapter15_Inheritance.md#liskov-substitution-principle-lsp-%D0%B8%D0%BB%D0%B8-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8-%D0%B1%D0%B0%D1%80%D0%B1%D0%B0%D1%80%D1%8B-%D0%BB%D0%B8%D1%81%D0%BA%D0%BE%D0%B2).

**Ассоциация**(Association) - отношения, где два отдельных класса связаны через указатели или некоторые переменны, нужные для идентификации класса. Например, класса Офис и класса Работник. Они независимы, имеют свои конструкторы/деструкторы и тд, но связаны через переменную employer_ID.

## Раннее и позднее связывание ( Early binding and late binding )
При компиляции команды c++ заменяются на машинный код. Каждая ф-ция имеет свой адрес в памяти. Таким образом, когда caller доходит до ф-ции, он переходит ее адресу, выполняет машинный код там, а потом возвращается на место вызова ф-ции. Принципиальная разница в том, знает ли компилятор адрес ф-ции при компиляции или ему нужно узнать адрес ф-ции при выполнении программы.    
### Ранне связвание
Это классический случаий, когда ф-ция вызвается по своему имени, а ее адрес и место вызова известны at-compile-time. Например,
```cpp
void printValue(int value)
{
    std::cout << value;
}
 
int main()
{
    printValue(7); // это прямой вызов функции
    return 0;
}
```
В этом случаии при компиляции, в месте вызова ф-ции вставляется инструкция "перейти по этому адресу" (соответсвующему этой ф-ции).
### Позднее связывание 
В этом случаии используются указатели на ф-ции. Так компилятор не знает какая ф-ция будет вызвана в месте, где находися указатель, и он должен заглянуть в содержимое указателя, чтобы узнать адрес вызываемой ф-ции. Например,
```cpp
int add(int a, int b)
{
    return a + b;
}
 
int main()
{
    int (*pFcn)(int, int) = add;     // Создаём указатель на функцию add
    std::cout << pFcn(4, 5) << std::endl; // вызов add(4 + 5)
 
    return 0;
}
```
В этом случаи компилятор не знает какой адрес содержит pFcn, ему нужно туда заглянуть и перейти по этому адресу.    

- Позднее связывание является более медленным, тк коспилятор должен узнавать содердимое указателя на ф-цию, вместо исполнения заранее сгенерированной команды (как в случаии Раннего связывания). Однако, указатели на ф-ции позволяют писать более гибкий код.
