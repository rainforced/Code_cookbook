# Chapter 6 Class
## Общее
### Initialization
Если мы инициализируем объект класса внутри объявления другого класса (class definition), мы не можем использовать direct initialization (например, `Vec2 pos(400.0f, 300.f)`), хотя в обычном случаии (вне объявления класса) это сделать можно. В этом случаии надо воспользоваться либо 1) uniform initializaton, либо 2) через анонимный объект: we first create a anonymous object of class Vec2 (right hand side) and then assign it to Vec2 pos, initialized by default constructor (left hand side). 
```cpp
//inside Dude class
  Vec2 pos(400.0f, 300.0f); 		// ERROR! direct initialization
  Vec2 pos(400.0f, 300.0f); 		// 1)OK! uniform initializaton
  Vec2 pos = Vec2(400.0f, 300.0f);	// 2)OK! через анонимный объект
```

## Struct (a public class)
Essentially, it is a class but less secure, since:
1. Members of a class are private by default and members of a struct are public by default.
2. When deriving a struct from a class/struct (inherit), default access-specifier for a base class/struct is public. And when deriving a class, default access specifier is private.    

**Используйте ключевое слово struct для структур, используемых только для хранения данных. Используйте ключевое слово class для объектов, объединяющих как данные, так и функции.**   

Как и любой другой тип данных его можно передавать ф-йии и возвращать.     
```cpp
struct Person{                                 // initialisation of a struct
    string name;                               // these are publicly accessible
    string lastname;			       // переменные структур - поля структур
    int age;
/* Можно делать default присвоение. Их надо ставить в конце, чтобы при инициализации их не переписать, оставив
объявленные без данных. Для них не работает uniform инициализация (способ 3) */
//    double salary = 4000;
};

vector<Person> staff;                          //create vector of Person(s)
staff.push_back({"Ivan","Ivanov", 24});       //initialisation of a instance of Person
staff.push_back({"Petr","Petrov", 100});
cout << staff[0].name;                         //prints "Ivan". Calling a variable of a stuct
```
### Присвоение значений полям
```cpp
Person vasya;			// создаем example vasya структуры person
/* 1й способ: объявляем и присваиваем значение каждому полю вручную */
vasya.name = 'Vasya';                            
vasya.lastname = 'Pupkin';			       
vasya.age = 32;

/* 2й способ: инициализация структуры с параметрами */
struct Employee
{
    short id;
    int age;
    float salary = 0.0;
};

Person john = { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
Person james = { 6, 29}; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)

/* 3й способ:  инициализацию uniform (C++ 11 и выше) */
Person john { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
Person james { 6, 29 }; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)

/* 4й способ: объявили, а потом присвоили используя список инициализаторов (С++ 11 и выше)*/
Person john;
john = { 5, 27, 45000.0 }; // {} - это список инициализаторов
```
### Вложенные структуры 
```cpp
struct Employee
{
    short id;
    int age;
    float salary;
};
 
struct Company
{
    Employee CEO; 				// Employee является структурой внутри структуры Company 
    int numberOfEmployees;
};
 
Company myCompany = {{ 3, 35, 55000.0f }, 7 };  // Инициализация {{stuct Employee}, numberOfEmployees}

myCompany.CEO.salary 				// Обращение к вложенной структуре
```
### Размер   
Обычно это сумма размеров его полей + несколько байт, которые добавляет компилятор для своей внутренней работы. 

**Хотя структуры ведут себя подобно классам (в C++, не в C), за исключением дефолтного спецификатора доступа, рекомендуется использовать их только в случаии, если нужно сгрупировать простые данные под одним логическим признаком (например, серию из переменных int). Если нужны методы и более сложная архитектура, то надо использовать классы. 

---
## Классы
### Анатомия класса
**Спецификатор доступа** определяет, кто имеет доступ к членам этого спецификатора. Eсть 3 уровня доступа:
- `public:` делает члены открытыми
- `private:` делает члены закрытыми
- `protected:` открывает доступ к членам только для дружественных и дочерних классов    
По умолчанию у классов спецификатор private, а у структур public. *Контроль доступа работает на основе класса, а не на основе конкретного экземпляра*. Это означает, что когда метод имеет доступ к закрытыми членам класса, то он может обращаться к закрытым членам любого объекта этого класса:
```cpp
class DateClass // члены класса являются закрытыми по умолчанию 
{
	int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
	int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
	int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса
public:
	void copyFrom(const DateClass &b)
	{
		// Мы имеем прямой доступ к закрытым членам объекта b
		m_day = b.m_day;
		m_month = b.m_month;
		m_year = b.m_year;
	}
}

int main()
{
DateClass date;
date.setDate(12, 11, 2018); // ок, так как setDate() имеет спецификатор доступа public
	
DateClass copy;
copy.copyFrom(date); // ок, так как copyFrom() имеет спецификатор доступа public
/* была создана копия экземпляра date и сохранена в copy */
}
```
**Функция доступа (Access functions)** 
Это короткая открытая функция, задачей которой является получение или изменение значения закрытой переменной-члена класса. Функции доступа обычно бывают двух типов:
- **Геттеры** — это функции, которые возвращают значения закрытых переменных-членов класса. Рекомендуется держать их константными `const`.   
- **Сеттеры** — это функции, которые позволяют присваивать значения закрытым переменным-членам класса.

**Память**. Классы, структуры, энумераторы - это тип данных, поэтому при объявлении типа данных не выделятеся память (подобно тому, что память не выделяется встроеным типам данных, например, int). Память выделится при объявлении экземпляра этого класса. Компилятор даже не создает никакого кода, при объявлении класса. Те когда создается экземпляр, компилятор "подглядывает" в это объявление, выделяет память и создает нужную структуру. Однако, в том месте, где программист написал объявление класса, там в ассеблероном листинге ничего не будет.


### Объявление методов вне класса
Парадигма разделения класса на часть, где он объявляется (.h файл) и где реализуется (.cpp файл), позволяет реализовать методы класса вне блока его объявления. В примере ниже прототипы методов `copyFrom` и `ShowDate` должны быть объявлены внутры класса, а реализация может быть вне (как внутри файла, так и в другом файле. Например, объявление класса и все прототипы в .h, а реализации в .cpp:
```cpp
class DateClass 
{
	int m_day;  
	int m_month;  
	int m_year;  
public:
	void copyFrom(const DateClass &b);	/* метод должен быть объявлен внутри класса,
	void ShowDate();			но реализация его лежит за его пределами */
}

// Может быть в том же файле, а может быть в .cpp (если объявление класса в .h)
void DateClass::copyFrom(const DateClass &b)	/* реализация метода за пределами класса; можно в том же файле, 
{						а можно разделить объявление в .h и реализацию в .cpp */
	m_day = b.m_day;
	m_month = b.m_month;
	m_year = b.m_year;
}
void DateClass::ShowDate()			// важно указать принадлежность к классу через оператор ::
{ 
	std::cout << m_day <<'/'<< m_month <<'/'<< m_year;
}
```


### Конструктор
**Конструктор** — это особый тип метода класса, который автоматически вызывается при создании объекта этого класса. Конструкторы обычно используются для инициализации переменных-членов класса значениями, которые предоставлены по умолчанию/пользователем, или для выполнения любых шагов настройки, необходимых для используемого класса (например, открыть определённый файл или базу данных). В отличие от обычных методов, конструкторы имеют определённые правила по поводу их имён: 
1. Конструкторы всегда должны иметь то же имя, что и класс (учитываются верхний и нижний регистры).
2. Конструкторы не имеют типа возврата (даже void-а).   
```cpp
class Fraction
{
private:
    int m_numerator;
    int m_denominator;
 
public:
    Fraction() // конструктор по умолчанию (default constructor)
    {
         m_numerator = 0;
         m_denominator = 1;
    }
 
    // Конструктор с двумя параметрами, один параметр имеет значение по умолчанию
    Fraction(int numerator, int denominator=1)
    {
        assert(denominator != 0);
        m_numerator = numerator;
        m_denominator = denominator;
    }
 }
Fraction empty; // вызов Fraction(0, 1) - конструктора по умолчанию
Fraction drob(4, 5); // инициализируем напрямую, вызывается конструктор Fraction(int, int)
Fraction seven(7); // вызывается конструктор Fraction(int, int), второй параметр использует значение по умолчанию
```
В примере выше **конструктор со значениями по умолчанию**, который будет вызываться, если мы не предоставим значения, и конструктор с параметрами, который будет вызываться, если мы предоставим значения. Эти два конструктора могут мирно существовать в одном классе благодаря перегрузке функций. Фактически, вы можете определить любое количество конструкторов до тех пор, пока у них будут уникальные параметры (учитывается их количество и тип). Однако в этом случаи проще использовать один конструктор с параметрами по-умолчанию: `Fraction(int numerator=0, int denominator=1)`.
```cpp
 Fraction(int numerator=0, int denominator=1)
{
	assert(denominator != 0);
        m_numerator = numerator;
        m_denominator = denominator;
}
// любая из инициализаций сработает соответствующим образом
Fraction drob; // вызов Fraction(0, 1)
Fraction seven(7); // вызов Fraction(7, 1)
Fraction sixTwo(6, 2); // вызов Fraction(6, 2)
```

#### Implicitly generated (or default) constructor
Если ваш класс не имеет других конструкторов, то C++ автоматически сгенерирует для вашего класса открытый конструктор по умолчанию. Его иногда называют **неявным конструктором (implicitly generated constructor)**. Его еще ингда называют **default constructor**. При запуске default конструктор просто вызывает default конструкторы своих подклассов. При этом, обычные переменные он оставляет неинициализованными (поэтому в примере ниже им изначально дали значение по умолчанию, иначе бы они остались с мусором). 
```cpp
// что пишем и видим мы
class Date
{
private:
    int m_year = 1900;
    int m_month = 1;
    int m_day = 1;
};
// что видит компилятор
class Date
{
private:
    int m_year = 1900;
    int m_month = 1;
    int m_day = 1;
 
public:
    Date() // implicitly generated constructor
    {
    }
};
```
Если у этого класса есть зависимые подклассы, то они тоже должны иметь дефолтные констуркторы (можно создать их так: `my_class()=default;`. 

#### Default constructors
Начиная с C++ 11, для дефолтных конструторов введен специальный синтаксис: `Somthing() = default;`.   
Существует разница между дефолтным конструктором сделаным так: 1) `Somthing() {}` и так 2) `Somthing() = default;`. Оба конструктора являются дефолтными и будут вызваны, если при создании экземпляра классу ничего не передается. Однако, будет разное поведение. В первом случаи просто выделяется место в памяти под экземпляр и ничего больше не делается. Во втором случаи, выделится место для экщемпляра и конструктор проинициализирует переменные нулями. Например,
```cpp
class A 
{
public:
    int y;
    A(){}
};

class B 
{
public:
    int y;
    B()=default;
};


int main() 
{ 
    int x = 5;
    
    new(&x)A(); 	// (1) Call for empty constructor, which does nothing
    cout << x << endl; 	// 5
    
    new(&x)B; 		// (2) Call for default constructor
    cout << x << endl; 	// 5
    
    new(&x)B(); 	// (3) Call for default constructor + Value initialization (0)
    cout << x << endl; 	// 0
    
    new(&x)A(); 	// (4) Call for empty constructor, which does nothing
    cout << x << endl;	// 0
    return 0; 
} 
```
В примере выше есть класс с конструктором типа 1) (класс А) и типа 2) (класс В). Конструкция `new(&x)A()` требует, что экземпляр был создан именно по адресу, где хранится перемнная x. Таким образом вызов (1) - просто создает класс A по адресу, где была переменная x. Тк это "плохой" (тип 1) дефолтный конструктор, то он не инициализирует y, поэтому y теперь имеет значение оставшееся от x (т.е. 5). Аналогично происходит и в случаях (2) и (4). В случаии (3) вызывается "хороший" дефотный конструктор (тип 2). Он инициализирует y нулем. Теперь по адресу y находится ноль. Поэтому "плохой" конструктор опять просто запишет y (класса A) поверх y (класса B).      

#### Список инициализации членов класса
Члены класса могут быть определены присвоением при создании класса (внутри конструктора и, с C++11, внутри тела класса):
```cpp
class Values
{
private:
    int m_value1;
    char m_value3 = 'd';  // можно использовать дефолтную инициализацию.
 
public:
    Values()
    {
        // Это всё операции присваивания, а не инициализация
	// m_value3 будет использовать дефолтную инициализацию
        m_value1 = 3;	// присвоение с помощью конструктора
    }
};
```
Хотя это работает для простых переменных, это не лучший способ это делать тк тут все объекты объявляются, а потом идет присвоение. Таким способом нельзя создать ссылки и константные переменные, тк они должны быть инициализированы (а присвоить им ничего нельзя). Грамотно это делать через **список инициализации**, тогда это будет инициализация всех объектов. В нем, после оператора (`:`) идет инициализация членов класса (не обязательно всех):

```cpp
#include <iostream>

class Values
{
private:
	int m_value1;
	double m_value2;
	char m_value3;

public:
	Values() : m_value1(10), m_value2(11.5), m_value3('a') // напрямую инициализируем переменные-члены класса
	{
		// Нет необходимости использовать присваивание
	}

	Values(int value1, double value2, char value3 = 'd')
		: m_value1(value1), m_value2(value2), m_value3(value3) // напрямую инициализируем переменные-члены класса
	{
	}

	void print()
	{
		std::cout << "Values(" << m_value1 << ", " << m_value2 << ", " << m_value3 << ")\n";
	}

};

int main()
{
	Values valueOne;	 // value1 = 10, value2 = 11.5, value3 = 'a' (все - дефолтная инициализация)
	Values valueTwo(3, 4.5); // value1 = 3, value2 = 4.5, value3 = 'd' (значение по умолчанию)
	valueOne.print();
	valueTwo.print();
	return 0;
}
```
Тут используются два альтернативных конструктора: 1) дефолтный конструктор. У него в списке инициализации прописаны все данные для инициализаци. 2) Конструктор требующий данные для инициплизации (и одно значение берется по умолчанию). Если создается экземпляр класса без данных для инициализации, то вызывается первый конструктор, если есть, то вызывается второй.     

**Инициализация константы**    
Так как инициализация констат происходит при создании нового экземпляра, то возможны все три вида инициализции внизу:
```cpp
class Values
{
private:
    const int m_value1 = 11.;	//1. инициализовали прям на месте (дефолтная)
    const int m_value2;		
    const int m_value3;
 
public:
    Values(): m_value2(7),	//2. инициализация константы при вызове конструктора
    {
    } 
    
    //3. алтернативынй конструктор, который инициализирует все константы полученым значением. А у  m_value3 есть дефолтное значение
    Values(int value1, int value2, int value3 = '444')
		: m_value1(value1), m_value2(value2), m_value3(value3)
    {
    }
};
```

**Инициализация массива**    
```cpp
class Values
{
private:
    const int m_array_zero[10]; 	//const можно инициализировать не только тут, но и в списке инициализваторов
    int m_array[7];
 
public:
    Values(): m_array { 3, 4, 5, 6, 7, 8, 9 },	// используем uniform инициализацию для инициализации массива.
	      m_array {}			// А так обнуляем массив m_array {} 
    {
    } 
};
```

**Инициализация всего подряд**     
Еще пример. Тут инициализируется все в перемешку: переменные класса, подклассы, классы из подключенных библиотек и тд.:
```cpp
// Ниже снипет из главного игрового класса для игры змейка. Один экмепляр на всю игру
Game::Game( MainWindow& wnd )	// Конструктор принимает (по ссылке) экмепляр wnd класса MainWindow 
	:		 // символ того, что это список инициализации 
	m_value1(3), 	 // инициализация переменной типа int из класса Game (из прошлого примера)
	m_value3('d'),	 // инициализация переменной типа char из класса Game(из прошлого примера)
	brd (gfx),	 // инициализация экземпляра класса Board (Board brd) вложенного в класс Game 
	snek({ 20,20 }), /* инициализация экземпляра класса Snake (Snake snek) вложенного в класс Game 
			  при этом вызывается конструктор класса Snake и принимает два int параметра */
	rng(std::random_device()()), /* инициализация экземпляра класса std :: mt19337 (std :: mt19337 rng - ГСЧ), в
				     ложенного в класс Game. При этом конструктор rnd принимает объект 
				     std::random_device()(), который объявлен внутри класса Game по дефолту */
	double m_value2(2.71)	     /* инициализация переменной типа double из класса Game 
				     все инициализации разделены запятой, последняя инициализация без нее */
{
	/* Тут посшло тело конструктора. Здесть можно что-нибудь присвоить или написать нужный код, 
	который будет исполнен разово при объявлении/инициализации экземпляра класса */
	
	std::uniform_int_distribution<int> xDist(2, brd.getWidth());
	std::uniform_int_distribution<int> yDist(2, brd.getHeight());
	
	x_value4 = 3; 	// Это уже операции присваивания, а не инициализация
        x_value5 = 4.5;	
}
```
Такое объявление гораздо удобнее т.к. это все инициализация, поэтому так можно 1) инициализовать подклассы. При инциализации подкласса вызывается его конструктор. При присвоении конструктор не вызовется. 2) Можно инициализцировать const переменные класса, а присваивать им ничего нельзя.   

**Важно!** Порядок инициализации устанавливается не в списке инициализации (не в конструкторе), а при объявлении объектов внутри класса (обычно в .h файле класса).

#### Инициализация по умолчанию
Приведенный выше пример можно было инициализировать по дефолту внутри тела класса (хотя и это не очень решение). Ниже приведены два идентичных способа инициализации: 1) списком инициализации, 2) просто инициализацией переменной по дефолту. Оба способа дают идентичный результат. Однако, конструктор (и соответственно список) имеет приоритет, поэтому если конструктор требует инициализирует какие-то значения, то они будут переписаны. 
```cpp
class Game{
public:
	// 1й способ: список инициализации
	Game( MainWindow& wnd )	// Конструктор принимает (по ссылке) экмепляр wnd класса MainWindow 
		:		 // символ того, что это список инициализации 
		m_value1(3), 	 // инициализация переменной класса Game типа int (из прошлого примера)
		const m_value3('d'),	 // инициализация переменной класса Game типа char (из прошлого примера)
		brd (gfx),	 // инициализация экземпляра класса Board (Board brd) вложенного в класс Game 
		snek({ 20,20 }),
		// и так далее ...

private:
	// 2й способ инициализациия переменных по дефолту
	// этот код - избыточен, тк конструктор имеет приоритет
	int m_value1 = 3;
	const char m_value3 = 'd'';
	Board brd = {gfx};	 // инициализация экземпляра класса Board (Board brd) вложенного в класс Game 
	Snake snek = { 20,20 }; 
	// и так далее ...
}
```

#### Делегирующие конструкторы
Бываеют случаи, когда у альтернативных конструкторов совпадают части кода. Например (совпадает "Часть кода X"), 
```cpp
class Boo
{
public:
    Boo()
    {
        // Часть кода X
    }
 
    Boo(int value)
    {
        // Часть кода X
        // Часть кода Y
    }
};
```
В этом случаи есть два подхода:
1. Сделать метод инициализации (`void Init()`). Тогда любой класс сможет вызывать ее, и это позволит избежать повторяющегося кода. Желательно держать этот метод в `private`, чтобы соблюсти инкапсуляцию. Однако, если нужен механизм, который отбрасывает экземпляр к дефолтным значениям, то можно сунуть его в `public`:
```cpp
class Boo
{
private:
    void Init()
    {
        // Код инициализации Boo
    }
    
public:
    Boo()
    {
        Init();
    }
 
    Boo(int value)
    {
        Init();
        // Делаем что-либо с value
    }
/* делать так, только если нужен механизм сброса экзепляра к дефолтному значению
    void Init()
    {
        // Код инициализации Boo
    }
*/
};
```

2. **Делегирующие конструкторы** (C++ 11 и старше)
Это мезанизм позволяющий конструктору вызвать свою альтернативу, используя списки инициализации:
```cpp
class Boo
{
private:
 
public:
    Boo()
    {
        // Часть кода X
    }
 
    Boo(int value)
    	:
    	Boo() // используем конструктор по умолчанию Boo() для выполнения части кода X
    {
        // Часть кода Y
    }
 
};
```
Важно, что конструктору, который вызывает другой конструктор, не разрешается выполнять какую-либо инициализацию членов класса. Поэтому конструкторы могут либо вызывать другие конструкторы, либо выполнять инициализацию, но не всё сразу.     
Вот еще пример,
```cpp
#include <iostream> 
#include <string>
 
class Employee
{
private:
    int m_id;
    std::string m_name;
 
public:
    Employee(int id=0, const std::string &name=""):
        m_id(id), m_name(name)
    {
        std::cout << "Employee " << m_name << " created.\n";
    }
 
    // Используем делегирующие конструкторы для сокращения дублированного кода
    Employee(const std::string &name) 
    	: 
	Employee(0, name) { }
};
 
int main()
{
    Employee a; 
    Employee b("Ivan");
 
    return 0;
}
```

### Порядок действий в конструкторе
- Если мы работаем с явным конструктором, то порядо инициализации членов класса следующий. Сначала идет инициализация списком. В списке порядок инициализации соответствует порядку, в котором экземпляры объявлены (например, в .h файле). После этого выполнятеся код в теле конструктора.       
- Если же компилятор генерирует дефолтный конструктор, то все инициализации происходят как инициализации списком. Те до тела дефолтного конструктора (те если он объявлен как `my_class() {//some code`, а не так `my_class() = default`) программа дойдет только после создания всех его внутренних объектов, включая создание входящих в него подклассов. При этом, у подклассов так же должен быть дефолтный конструктор.

### Вызов конструктора при определении класса (.h файл)
Если мыс оздаем объект внутри определния класса то можно испальзовать: 1. Копирующий конструктор, 2. Uniform конструктор (`{}`). Обычный вызов конструктора использовать нельзя,
```cpp
/* Внутри определения класса Poo (Poo.h) */
#include "Surface.h"
Surface surf_poo1{path};		//OK
Surface surf_poo2 = Surface(path);	//OK
Surface surf_poo3(path);		//НЕ OK! Error!
```

### Копирующий конструктор
**Конструктор копирования** - это спец вид конструктора, который вызывается в следующих случаях:
1. Инициализация копированием. Например,
	```cpp
	//пусть есть класс IntArray
	IntArray a1{1,2,3,4,5}; //uniform инициализация
	
	IntArray a2 = a1; 	// инициализация копированием. Будет вызван конструктор копирования
	IntArray a3 = IntArray{6,7,8,9,10}; /*инициализация копированием. В этом случаи содается сначала анонимный объект 						    IntArray{6,7,8,9,10}, а потом вызывается конструктор копирования и 
					    инициализирует a3 копированием */
	```
	Сюда же входит иициализация через анонимные объекты. Например, ниже экземпляр smthTwoDigit инициализируется анонимным объектом, он далее будет скопирован через копирующий конструктор (Хотя скорее всего компилятор проигнорирует его - см. далее *элизия*). 
	```cpp
	Smth smthTwoDigit(Smth(6, 7));
	```
	
2. Передача класса в ф-цию **по значению**
3. Возвращенеи класса из ф-ции **по значению**
	```cpp
	My_class makeNegative(My_class exmpl); 	//для создания экземпляра exmpl вызывается констурктор копирования
						//также вызывается конструктор копирования при возврате из ф-ции
	```
	В ф-ции выше конструктор копирования будет вызван 2 раза: при передаче аргумената и и при возврате класса по значению.

#### Определение конструктора копирования
**По умолчанию**    
Если он не определен специально, то компилятор **генерирует его по умолчанию**. В этом случаи он просто будет копировать все поля, **вызывать копирующие контрукторы для всех подклассов** и, таким образом, создаст идентичный экземпляр (это называется **почленная инициализация**). Это включает идентичные указатели, адреса и динамическую память, отсюда могут быть проблемы в некоторых классах, например, использующих динамическую память.    
**Определение**
Сам же копирующий конструктор задается следующим образом:
```cpp
{//объявление класса
public:
	IntArray(IntArray const & a)
	{
		//тело конструктора 
	 	// важная работа с памятью и тд
	 }
}
```

#### Пример копирующего конструктора 
Пусть у нас есть некоторый класс для хранения массивов (хранит массив данных, его размер и всякие методы). Пусть память в нем выделяется динамически. Экземпляр a3 будет инициализирован дефолтным копирующим конструктором -> повлечет потерю памяти. Также оператор присваивания по дефолту просто копирует данные из полей, никак не регулируя память и адреса -> аналогичная проблема. В этом случаии нужно сделать конструктор копирования, который скоприрует данные и позаботиться о динамической памяти. Например,
```cpp
class IntArray {
public:
	//дефолтный конструктор
	IntArray() = default;
	//конструктор копирования
	IntArray(IntArray const & a)
	: size_(a.size_), data_(new int[size_]) //в новом экземпляре инициализируются поле размера и новый массив
	{
		for ( size_t i = 0; i != size_; ++i)	//а тут идет копировние
		data_[i] = a.data_[i];
	}// на выходе получаем два незаписимых экземпляра, у каждого свой динамически выделенный участок памяти
private :
	size_t size_;
	int * data_;
};
int main() 
{
	IntArray a1(10);
	IntArray a2(20);
	IntArray a3 = a1; 	// копирование (вызываем конструктор копирования)
	a2 = a1; 		// присваивание
	
	return 0
}
```

#### Элизия (компилятор может проигнорировать конструктор копирования)
Компилятор может проигнорировать конструктор копирования - это называется **элизией**. Например, в примере ниже мы создаем
```cpp
//мы ввели
Smth smthTwoDigit(Smth(6, 7));
//копилятор сделал
Smth smthTwoDigit(6, 7);
````

#### Перегрузка оператора присваивания =
Логически оператор присваивания = тесно связан с конструктором копирования. Принципиальная разница в том, что конструтор копирования вызывается на новый объект, если некий объект уже существует, то это просто присвивание.
- Если новый объект создан во время выполнением операции копирования, то используется конструктор копирования (передача или возврат объектов выполняются по значению). Например, `Data dt = Data{1,2,3};`
- Если создания нового объекта не было, а работа ведётся с уже существующим объектом, то используется оператор присваивания. Например,
	```cpp
	Data dt1{1,2,3};
	Data dt2;	//объект создан конструктором по-умочанию, заполнен по-умолчанию
	Data dt2 = dt1; //присваивние
	
	Data dt3 = dt1	//копирование, тут вызывается конструктор копирования
	```
**Присваивание по-умолчанию**    
Как и в случаи конструктора копирования, если оператор = не переопределн, то компилятор сам произведет почленное копирование.      

**Проблемы при работе с памятью**     
При копировнии одного экзепляра класса с динамической памятью в другой произойдет утечка памяти, так как мы потеряем указатель на один из их участков динмической памяти (оба указателя будут указывать на второй участок). Решить это можно перегрузкой оператора присваивания. Например,
```cpp
IntArray & operator =(IntArray const & a)
{
	if ( this != &a)	//проверяем чтобы не произошло самоприсваивание; типо a=a;
	{
		delete [] data_;
		size_ = a.size_;
		data_ = new int[size_];
		for ( size_t i = 0; i != size_; ++i)
			data_[i] = a.data_[i];
	}
return * this ;
}
```
Важно убедиться, чтобы не произошло **самоприсваивание** (те когда объект присваивается сам себе: a=a). Если это не проверить, то первой строчкой delete [] мы сами себя удалим, и вернем указатель на пустой объект. Обработать это случай можно как в примере выше:
```cpp
if(*this != a){//тело оператора}
return *this;
```
Мы всегда возвращаем `*this`, чтобы можно было создавать цепочки вызовов, например, `dt1 = dt2 = dt3 = dt4;`. При этом копирование в левосторой объект происходит внутри тела оператора (для этого мы и передаем про объект по ссылке, чтобы его менять).    

**delete**    
Аналогично конструктору копирования, можно запретить использования оператора присваивания, например, если мы не хотим его переопределять, но и не хотим, чтобы компилятор производит автоматическое почленное копирование:
```cpp
IntArray & operator =(IntArray const & a) = delete; //теперь любая попытка присвоить объект вызовет ошибку
```

#### Как задать конструктор копирования через оператор присваивания
Тк обе ф-ции при Deep копировании выполняют практически одну и ту же задачу, то можно выразить оду через другую, чтобы избавиться от дублирования кода. Пусть у нас есть какая-то ф-ция с динамической память. Тогда, в `operator=` мы реализуем основной код, а клпируюзий конструктор будет вызывать его,
```cpp
MyClass& operator=(const MyClass& rhs)
{
	//1. Убедиться, что нет самоприсваивания
	//2. Удалить динамический оюъект связанный с this (lesft hand side)
	//3. Сделать копирование rhs в lhs
	return *this;
}

MyClass(const MyClass& rhs)
{	
	/*надо убедиться, что есть грамотныя совместимость ф-ций. Например, что в шаге 1) опреатора = 
	мы не пытаемся удалить необъявленные/неопределенные объекты (те они должны быть определены по умолчанию) */
	return *this = rhs;
}
```

#### Правило 3х и правило 0
**Правило 3х** (rule of 3) - если приходится руками реализовывать действия хотя бы одного из 3х операторов (**деструктор**,**копирующий конструктор**, **оператор присваивания**), то надо реализовывать все три. Если программа работает с динамической памятью, то нужно регулировать все три.      

**Правило 0** - если нет необходимости регклировать поведение ни одного из этих трех операторов, те есть работа идет с простыми типами данных, без опасности утечки данных, то не надо реализовывать ни один из них (сойдут и предоставленные компилятором).

### Неявное преобразования при вызове конструктора (conversion constructor)
- По умолчанию, компилятор будет обрабатывать любой вызов конструктора используя неявное преобразование, если аргументы конструктора в точности не совпали. Преобразование будет сделано неявно, если это родственные типы данныъ и не происходить потеря данных (те "сужения" типа данных, например, float/double -> int). Так преобразование int->float или char->int будет сделано неявно.

- Также при необходимости будет создан анонимный экземпляр класса для копирующей инициализации. Те:
	```cpp
	//Явно создан анонимный объект, а потом произведена копирующая инициализация
	Segment s1 = Segment{20, 30};
	//Неявно создан анонимный объект, а потом произведена копирующая инициализация
	Segment s2 = {20, 30};
	```

- Кол-во аргументов не имеет значения, до тех пор пока их хватает для работы конструктора. Например, если конструктор принимает 3 аргумента, но 1 из параметров определен по умолчанию, то все изложенное верно для вызова с 2 или 3 аргументами будет верно.

- Неявное преобразование с первого взгляда может быть бессмысленно с точки зрения класса. Например, в примере ниже класс хочет принят 2 или 3 аргумента типа double, но мы можем "скормить" ему float, int, char, он все сконвертирует сам:  
```cpp
class Segment 
{
public:
	Segment() {}
	Segment( float in_x, float in_y, float in_z = 0)
		: x(in_x), y(in_y), z(in_z)
	{}
private:	
    float x;
    float y;
    float z;
    
    friend std::ostream& operator<<(std::ostream& out, const Segment& seg)
    {
    	out << seg.x <<" / " << seg.y <<" / " << seg.z <<std::endl;
    }
};

int main()
{
/* Прямая и unifor инициализация. Вызовет обычный конструктор */
	Segment s1(22.6f, 30, 'g');	//float, int, char 	
	std::cout << s1 <<std::endl;	//			|| выведет: x=22.6, y=30, z=103
	Segment s2{2.4f, 3, 'h'};       //float, int, char 	
	std::cout << s2 <<std::endl;	//			|| выведет: x=2.4, y=3, z=104

/* Копируюшая инициализация. Вызовет копирующий конструктор, после неявного создания анонимного экземпляра*/
	Segment s3 = {20, 30}; 		// int, int 		
	std::cout << s3 <<std::endl;	//			|| выведет: x=20, y=30, z=0
	Segment s4(10.0f, 90, 28.2); 	// float, int, double 	
	std::cout << s4 <<std::endl;	//			|| выведет: x=10, y=90, z=28.2
	Segment s5 = {20.2f, 2.5f};   	// float, float 	
	std::cout << s5 <<std::endl;	//			|| выведет: x=20.2, y=2.5, z=0
	Segment s6 = {'a', 'b'};       	// char, char 		
	std::cout << s6 <<std::endl;	//			|| выведет: x=97, y=98, z=0
	Segment s7 = {'a', 2, 299.5f}; 	// char, int, float 
	std::cout << s7 <<std::endl;	//			|| выведет: x=97, y=2, z= 299.5
    
    return 0;
}
```

#### Как запретить компилятору неявно преобразовывать аргументы
Есть 3 способа запретить компилятору делать неявные преобразования:
1. **expilict** -ключевое слово запрещаеющее компилятору делать неявные преобразования, включая неявное создание анонимных объектов. Например, 
	```cpp
	class Segment 
	{
	public:
		Segment() {}
		explicit Segment( float in_x, float in_y, float in_z = 0)
		: x(in_x), y(in_y), z(in_z)
		{}
	private:
    		float x;
    		float y;
   		float z;
	};
		int main()
	{
	/* Можно. Все все задется явно */
		Segment s1{20.4f, 9.5f}; 
		Segment s2(20.4, 9.5);			//хотя это double, double. Тут коспилятор не ругается
		Segment s3 = Segment(20.4f, 9.5f);		
	/* Нельзя! Все ниже влечет неявные преобразования */		
		Segment s4 = {20.4f, 9.5f, 9.3f}; 	//Неявное создание анонимного объекта
		Segment s5 = {2, 'a'};			//НЕ ОК! Неявное преобразование из int, char
	}
	```
2. Сделать явный конструктор нужного типа и спрятать его в private. Например,
	```cpp
	class Segment 
	{
	public:
		Segment() {}
		Segment( float in_x)
		: x(in_x)
	{}
	private:
		Segment( char ){};
		Segment( int ){};
    		float x;
	};
	```
	Тут мы определили пустые конструкторы принимающиее char и int. Теперь, когда коспилятор будет вызывать конструктор для этих типов, он его найдет, но из вне класса к нему нет доступа (например, из main()), поэтому произойдет ошибка доступа. При этом можно поставить "заглушки" типов данных. Неявного преобразования не произойдет. Однако: 1) Это не запретит анонимные классы. 2) Внутри класса все еще можно обратиться к этому конструктору.  

3. **delete** - ключевое слова (с C++11), которое делает аналогичное действие, что и пункт 2, но тут любое обращение к этому конструктору вызовет ошибку.
	```cpp
	class Segment 
	{
	public:
		Segment() {}
		Segment( float in_x)
		: x(in_x)
	{}
	private:
		Segment( char ) = delete;
    		float x;
	};
	```
	**delete также можно использовать для прегруженных операторов и ф-ций** - эффект тот же самый: при вызове произойдет ощибка.

### Вложенные enum
```cpp
enum FruitList
{
	AVOCADO,
	BLACKBERRY,
	LEMON
};
 
class Fruit
{
private:
	FruitList m_type;
public:
 	Fruit(FruitList type) :
		m_type(type)
	{
	}
 
	FruitList getType() { return m_type;  }
};
 
int main()
{
	Fruit avocado(AVOCADO);
	
	if (avocado.getType() == AVOCADO)
		std::cout << "I am an avocado!";
	else
		std::cout << "I am not an avocado!";
	
	return 0;
}
```
Надо отметить, что следующие обращение к enum из данного класса будут эквивалентны: `Fruit::FruitList::AVOCADO` и `Fruit::AVOCADO`. Однако в случаи вложенных классов надо указавать полный путь пространств: `Snake::Segment::Somthing`.

### Вложенные классы
Одни классы могут содержать другие классы в качестве переменных-членов. По умолчанию, при создании внешнего класса, для переменных-членов будут вызываться конструкторы по умолчанию. *Это произойдёт до того, как тело конструктора выполнится*. 

#### Scopes вложенных классов   
Хотя сам любой экземпляр класса обладает доступом ко всем его объектам, экзепляр не будет иметь доступа к объектам  вложенного класса (если он private). Например, 
```cpp
class Snake
{
public:
	// some Snakes fucntions 
private:
	class Segment
	{
	public:
		char get_color(); 	// getter for colors
		int get_loc(); 		// getter for loc
		// some Segment variables
	private:
		char color;
		int loc;
	};

	int nSegments = 4; 
	int segColorCounter = 1;
	Segment snake[nSegmentsMax];
};
```
В этом случаии любой экземпляр `Segment` имеет доступ к `color` и `loc`, однако `Snake` не имеет к ним доступа (для этого ему потребуется использовать `get_color()` и `get_loc()`). Таким образом, тот факт, что `Segment` является объектом внутри класса `Snake`, это не дает `Snake` права на доступ к внутренностям класса `Segment`. Экземпляры `Snake` имеют доступ только к своим объектам, но не их внутренностям. 

### Деструктор 
Когда объект автоматически выходит из **области видимости** или **динамически выделенный** объект явно удаляется с помощью ключевого слова `delete`, вызывается деструктор класса (если он существует) для выполнения необходимой очистки до того, как объект будет удалён из памяти. Для простых классов (тех, которые только инициализируют значения обычных переменных-членов) деструктор не нужен, так как C++ автоматически выполнит очистку самостоятельно.    
Однако, если объект класса содержит любые ресурсы (например, динамически выделенную память или файл/базу данных), или, если вам необходимо выполнить какие-либо действия до того, как объект будет уничтожен, деструктор является идеальным решением, поскольку он последнее, что происходит с объектом перед его окончательным уничтожением. Не смотит забывать, что если для завершения программы используется `exit()`, то деструктор не будт вызван и прогрмма завершится без сохранения данных.

- Деструктор должен иметь то же имя, что и класс, со знаком тильда (`~`) в самом начале.
- Деструктор не может принимать аргументы. Деструктор не имеет типа возврата. Это значит, что деструктор может быть только один.

**Идиома RAII** (англ. «Resource Acquisition Is Initialization» = «Получение ресурсов есть инициализация»)  — это идиома объектно-ориентированного программирования, при которой использование ресурсов привязывается к времени жизни объектов с автоматической продолжительностью. В C++ идиома RAII реализуется через классы с конструкторами и деструкторами. Ресурс (например: память, файл или база данных) обычно приобретается в конструкторе объекта (хотя этот ресурс может быть получен и после создания объекта, если в этом есть смысл). Затем этот ресурс можно использовать, пока объект жив. Ресурс освобождается в деструкторе при уничтожении объекта. Основным преимуществом RAII является то, что это помогает предотвратить утечку ресурсов (например, память, которая не была освобождена), так как все объекты, содержащие ресурсы, автоматически очищаются.    

**Пример ниже соответсвует идиоме RAII**, тк выделение и вызвращение динамической памяти происходит внутри класса. Такии образом нет опасности утечки памяти. 

```cpp
#include <iostream>
#include <cassert>

class Massiv
{
private:
	int *m_array;
	int m_length;
 
public:
	Massiv(int length) // конструктор
	{
		assert(length > 0);
 
		m_array = new int[length];
		m_length = length;
	}
 
	~Massiv() // деструктор
	{
		// Динамически удаляем массив, который выделили ранее
		delete[] m_array ;
	}
 
	void setValue(int index, int value) { m_array[index] = value; }
	int getValue(int index) { return m_array[index]; }
 
	int getLength() { return m_length; }
};
 
int main()
{
	Massiv arr(15); // выделяем 15 целочисленных значений
	for (int count=0; count < 15; ++count)
		arr.setValue(count, count+1);
 
	std::cout << "The value of element 7 is " << arr.getValue(7);
 
	return 0;
} // Объект arr удаляется здесь, поэтому деструктор ~Massiv() вызывается тоже здесь
```

**Пример ниже НЕ соответсвует идиоме RAII**, так тут память выделяется и возвращается вне класса, и значит, программист обязан позаботиться об этом сам:
```cpp
class Another
{
private:
    int m_nID;
 
public:
    Another(int nID)
    {
        std::cout << "Constructing Another " << nID << '\n';
        m_nID = nID;
    }
 
    ~Another()
    {
        std::cout << "Destructing Another " << m_nID << '\n';
    }
 
    int getID() { return m_nID; }
};
 
int main()
{
    // Выделяем объект класса Another из стека
    Another object(1);
    std::cout << object.getID() << '\n';
 
    			// Выделяем объект класса Another динамически из кучи
    Another *pObject = new Another(2);
    std::cout << pObject->getID() << '\n';
    delete pObject;	// Возвращаем память в кучу. Вызывается деструктор для pObject 
 
    return 0;
} // Объект object выходит из области видимости здесь. Вызывается деструктор для object
```
#### Порядок действий в деструкторе (инь и янь)
**Конструктор - инь, а деструктор - янь**     
Порядок действий деструктора **обратный действиям конструктора**. Те если мы, например, имеем класс Master и его подкласс A,
```cpp
class A
{
public:
	A() {std::cout << "The first rule of Fight Club is: you do not talk about Fight Club"<< std::endl;}
	~A() {std::cout << "I wanted to destroy everything beautiful I’d never have" << std::endl;}
};	
class Master
{
private:
    A a;
public:	
	Master() {std::cout << "I'mma Master"<< std::endl;}
	~Master() {std::cout << "Master is dead"<< std::endl;}
};

int main()
{
    Master M;
    return 0;
}
```
Что выведет программа в консоль:
```
The first rule of Fight Club is: you do not talk about Fight Club
I'mma Master
Master is dead
I wanted to destroy everything beautiful I’d never have
```
Сгенерированный конструтор Master создает экземпляр класса A, используя его дефолный конструктор, в списке инициализации (это первая строка). Затем он доходит до своего тела (это вторая строка). Когда объект класса Master уничтожатеся, сначала выполнятеся тело его деструктора (третья строка), а затемы выполняются деструкторы всех ключенных в него классов в обратном порядке от того, как они были созданы (четвертая строка). 

#### Implicitly generated (or default) destructor
Агалогично автоматически сгенерированному конструктору, коспилятор сгенирирует default деструктор. Все что он делает, это вызывает деструкторы подклассов данного класса. Так конструктор не принимает аргументов, то у подклассов могут быть манулально написанные деструкторы (и лучше бы им быть).

### Скрытый указатель *this ->
Пусть у нас есть метод bar() некоторого класса. **Тогда:** `this->bar()`** то же самое, что и **`(*this).bar()`          

#### Что такое ->
Это синтаксис обозначающий обращение к полю экземпляра, если экземпляр представлен указателем. Те `a->b` означает: если указатель на некоторый экзепляр класса (`ptr_a = &a`) и у этого класса поле (`b`). Тогда, чтобы обратиться к полю `b` экзепляра `a`, на который указывает `ptr_a`, надо его разыменовать, а потом обратиться к полю через опретор точка (`.`): `(*ptr_a).b`. Для этого придумали короткую запись: `a->b`.        

#### *this 
Любой метод класса работает аналогично обычным ф-циям. Главное отличие это то, что компилятор неявно (скрыто) подставляет туда указать на экземпляр, который вызвал этот метод. Например, ниже идет простой пример класса с геттером и сеттером.
```cpp
/* Это пишем и видем мы */
class Another
{
private:
    int m_number;
 
public:
    Another(int number)	
    {
        setNumber(number);
    }
 
    void setNumber(int number) { m_number = number; }	//обычный сеттер
    int getNumber() { return m_number; }		//обычный геттер
};
 
int main()
{
    Another another(3);		//объявили класса, инициализовали m_number = 3
    another.setNumber(4);	//присвоили m_number = 4
    std::cout << another.getNumber() << '\n';	//выведет "4"
 
    return 0;
}
```
А так компилятор видет методы этого класса:
```cpp
// весто "void setNumber(int number) { m_number = number; }"
void setNumber(Another* const this, int number) { this->m_number = number; }
// весто "int getNumber() { return this->m_number; }"
    int getNumber(Another* const this) { return this->m_number; }
};
 
int main()
{
    Another another(3);		//объявили класса, инициализовали m_number = 3
    setNumber(&another, 4); 	/* Вместо  "another.setNumber(4)". Объект another конвертировался из объекта, 								который находился перед точкой, в аргумент функции! */ 
    std::cout << getNumber(&another) << '\n';	//вместо "another.getNumber()"
 
    return 0;
}
```
- Все методы видятся компилятору как вызовы обычных ф-ций, куда неявно передали ссылку на экземпляр класса, который вызвал этот метод: ` another.setNumber(4);` -> `setNumber(&another, 4)`. Более того, при объявлении ф-ции компилятор неявно добавляет в аргументы константный указатель на этот экземпляр (`Another* const this`). Указатель `*this` — это **скрытый константный указатель**, что содержит адрес объекта, который вызывает метод класса.   
- К любым переменным-членам внутри setNumber() добавляется префикс `this->`. Поэтому, когда мы говорим `m_number = number`, компилятор фактически выполняет `this->m_number = number`. 

#### *this всегда указывает на текущий объект
Каждый метод имеет в качестве параметра указатель *this, который указывает на адрес объекта с которым в данный момент выполняется операция.
```cpp
int main()
{
    Another X(3); // *this = &X внутри конструктора Another
    Another Y(4); // *this = &Y внутри конструктора Another
    X.setNumber(5); // *this = &X внутри метода setNumber
    Y.setNumber(6); // *this = &Y внутри метода setNumber
}
```
 Указатель *this поочерёдно содержит адрес объектов X или Y в зависимости от того, какой метод вызван и сейчас выполняется.
 
 #### Когда использовать *this
Все описанные выше вещи с `*this` происходят "под капотом" неявно. Однако есть два случая, когда `*this` используется явно:

1. **Чтобы избежать конфлик имен в классе**. Когда локальная переменная/переданная имеет такое же имя, что и поле поле класса:
	```cpp
	class Something
	{
	private:
	    int data;			//это поле класса Something

	public:
	    Something(int data)  	//а тут - это передаваемая в ф-цию локальаня переменная
	    {
		this->data = data;	//а тут был бы конфлик имен, если бы не *this
	    }
	};
	```
2. **Цепочки методов класса**. Метод получает возможность возвращать указатель на этот экземпляр (`*this`), чтобы следующий метод мог быть вызван "последовательно" через оператор точка (`.`). Ниже идет простой класса, который имеет три метода (add, sub, multiply). Они возвращают void, и поэтому, чтобы провести действия над экземпляром operation, нужно вызывать их каждую по отдельности:
	```cpp
	class Mathem
	{
	private:
	    int m_value;

	public:
	    Mathem() { m_value = 0; }

	    void add(int value) { m_value += value; }
	    void sub(int value) { m_value -= value; }
	    void multiply(int value) { m_value *= value; }

	    int getValue() { return m_value; }
	};

	int main()
	{
	    Mathem operation;
	    operation.add(7); 		// возвращает void
	    operation.sub(5); 		// возвращает void
	    operation.multiply(3); 	// возвращает void

	    std::cout << operation.getValue() << '\n';
	    return 0;
	}
	```
	Однако, если каждая функция будет возвращать `*this`, то мы сможем связать эти вызовы методов в одну цепочку. Перепишем пример сверху:
	```cpp
	class Mathem
	{
	private:
	    int m_value;

	public:
	    Mathem() { m_value = 0; }

	    Mathem& add(int value) { m_value += value; return *this; }		//возвращает указатель на этот экземепляр
	    Mathem& sub(int value) { m_value -= value; return *this; }		//возвращает указатель на этот экземепляр
	    Mathem& multiply(int value) { m_value *= value; return *this; }	//возвращает указатель на этот экземепляр

	    int getValue() { return m_value; }
	};

	int main()
	{
	    Mathem operation;
	    operation.add(7).sub(5).multiply(3);	//это позволяет использовать точку для последовательного вызова методов

	    std::cout << operation.getValue() << '\n';
	    return 0;
	}
	```
	
	**std::cout <<** - это и есть цепочка вызовов методов. А точнее оператор `<<` действует на `std::cout` и возвращает указатель на 	тот же`std::cout`:    
	`std::cout << "Hello, " << userName;` можно представить как `(std::cout << "Hello, ") << userName;`. После операции вывода 		строки Hello, оператор `<<` возвращает объект, на который он был вызван (те `std::cout`) назад: `(std::cout) << userName;`. И 		так далее, пока не кончится поток.

###  Const методы
**Константный метод** — это метод, который гарантирует, что *не будет изменять объект* или *вызывать неконстантные методы класса* (поскольку они могут изменить объект). Для того, чтобы определить метод как константный нужно добавить в конце `const`:
```cpp
class Anything
{
public:
    int m_value;
 
    Anything() { m_value= 0; }
 
    void resetValue() { m_value = 0; }
    void setValue(int value) { m_value = value; }
 
    int getValue() const; 	// обратите внимание на ключевое слово const здесь
};
 
int Anything::getValue() const 	// и здесь. Оно должно быть и в объявлении прототипа, и в реализации
{
    return m_value;
}

int main()
{
    const Anything anything; // вызываем конструктор по умолчанию
 
    anything.m_value = 7; 	// ошибка компиляции: нарушение const
    anything.setValue(7); 	// ошибка компиляции: нарушение const
    anything.getValue();	// ОК, тк это конст метод
 
    return 0;
}
```
В примере выше, мы создали константный экземпляр класса. В этом случаии, если мы будем вызывать какие-либо неконстантные методы класса (например, `setValue`) или попытаемся менять поля напрямую через оператор точка (`.`), то это вызовет ошибку компиляции. Если константный метод что-то изменяет в вызываемом объекте, то это вызовет ошибку компиляции.     

Также, если константный метод вызывает неконтсантную метод/ф-цию (даже если те ничего не меняют), то это вызовет ошибку компиляции. Например, для того же случая что и вышел (`const Anything anything` - константный экземпляр):
```cpp
class Anything
{
public:
	int m_value;
	Anything() { m_value = 0; }	// конструктор
	
	int regetValue();		// не const метод
	int getValue() const; 		// const метод
};

int Anything::regetValue()		/* ничего не меняет, просто возвращает значение
{					 Однако, его нельзя использовать для const объектов и/или
	return m_value;			 внутри const методов */
}

int Anything::getValue() const 		/* компилятор выдаст ошибку тк const метод вызывает не const метод
{					 насмотря на то, что этот метод ничего не пробует менять */
	return regetValue();
}
```
Ошибка, которую выдвет компилятор в этом случаи, звучит так: `'int Anything::regetValue(void)': cannot convert 'this' pointer from 'const Anything' to 'Anything &'`. Те метод `regetValue` хочет получить сслыку на обычный экземпляр (те `this`), а тут ему передают `const this` (с которым работает метод `getValue`), а конвертация одного в другого невожможна.

#### mutable
Если переменная объявлена как `mutable`, то ее можно изменять внутри константных методов: `mutable int a;`

#### Константные ссылки и классы
Аналогичная проблема возникнет, если передавать в ф-цию const ссылку, а внутри вызывать неконстантные ф-ции (даже если они ничего не меняют), тк проблема не в изменении, а в том, что ф-ции ожидают опреденные (в данных случаях разные) виды данных:
```cpp
class Date
{
private:
    int m_day;
    int m_month;
    int m_year;
 
public:
    Date(int day, int month, int year)
    {
        setDate(day, month, year);
    }
 
    void setDate(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
    }
 
    int getDay() { return m_day; }
    int getMonth() { return m_month; }
    int getYear() { return m_year; }
};
 
// Примечание: Мы передаём объект date по константной ссылке, дабы избежать создания копии объекта date
void printDate(const Date &date)
{//Однако, геттеры данного класса не константные, а значит возникнет конфликт описанный выше и компилятор выдаст ошибку
    std::cout << date.getDay() << "." << date.getMonth() << "." << date.getYear() << '\n';
}
 
int main()
{
    Date date(12, 11, 2018);
    printDate(date);		/* независимая от класса ф-ция просто хочет, чтобы ей передали объект по константной ссылке,
    				 но внутри она хочет использовать его же методы, которые не константы. Это вызовет ошибку */ 
    return 0;
}
```

#### Перегрузка константных и неконстантных функций
Хотя это делается не очень часто, но функцию можно перегрузить таким образом, чтобы иметь константную и неконстантную версии одной и той же функции. Константная версия функции будет вызываться для константных объектов, а неконстантная версия будет вызываться для неконстантных объектов.
```cpp
class Anything
{
private:
    std::string m_value;
public:
    Anything(const std::string &value="") { m_value= value; }
 
    const std::string& getValue() const { return m_value; } // getValue() для константных объектов
    std::string& getValue() { return m_value; } // getValue() для неконстантных объектов
};

int main()
{
	Anything anything;
	anything.getValue() = "Hello!"; // ОК, вызывается неконстантный getValue()
 
	const Anything anything2;
	anything2.getValue(); 		// ОК, вызывается константный getValue()
 
	return 0;
}
```

------

## Static 
### Static переменные класса
В отличие от обычных переменных-членов, статические переменные-члены являются *общими для всех экеземпляров* класса. Более того, статические члены существуют, даже если объекты класса не созданы! Подобно глобальным переменным, *они создаются при запуске программы и уничтожаются, когда программа завершает своё выполнение*. 
```cpp
class Anything
{
public:
    static int s_value;
};
 
int Anything::s_value = 3;
 
int main()
{
    Anything first;
    Anything second;
 
    first.s_value = 4;
 
    std::cout << first.s_value << '\n';	// оба экземпляра имеют доступ к static value
    std::cout << second.s_value << '\n';
    return 0;
}
```

- Поскольку статические переменные-члены не являются частью отдельных объектов класса (они обрабатываются аналогично глобальным переменным и инициализируются при запуске программы), то вы должны явно определить статический член вне тела класса: в глобальной области видимости. Если класс определён в заголовочном файле, то определение статического члена обычно помещается в файл с кодом класса (например, в Anything.cpp). Если класс определён в файле .cpp, то определение статического члена обычно пишется непосредственно под классом:
	```cpp
	class Anything
	{
	public:
	    static int s_value;	// объявляем статическую переменную-член
	};

	int Anything::s_value = 3; // определяем статическую переменную-член

	int main()
	{
	    // Примечание: Мы не создаём здесь никаких объектов класса Anything
	    Anything::s_value = 4;
	    std::cout << Anything::s_value << '\n';	//выведет "4"
	    return 0;
	}
	```
- Есть несколько обходных путей определения статических членов внутри тела класса. Во-первых, если статический член является константным интегральным типом (к которому относятся и char, и bool) или константным перечислением, то статический член может быть инициализирован внутри тела класса. Также с C++11 статические члены constexpr любого типа данных, поддерживающие инициализацию `constexpr`, могут быть инициализированы внутри тела класса:
	```cpp
	class Anything
	{
	public:
	     static const int s_value = 5; // статическую константную переменную типа int можно объявить и инициализировать напрямую

	     static constexpr double s_value = 3.4; // хорошо
	     static constexpr std::array<int, 3> s_array = { 3, 4, 5 }; // это даже работает с классами, 													// которые поддерживают инициализацию constexpr
	};
	```
- Можно определить статическую переменную-член, даже если она является private.
	```cpp
	class IDGenerator
	{
	private:
	    static int s_nextID; // объявление статической переменной-члена
	};

	int IDGenerator::s_nextID = 1; // все ОК

	int main()
	{
		std::cout << IDGenerator::s_nextID; // ERROR! Тут private уже не позволит получить доступ к s_nextID
		return 0;
	}
	```

#### Static методы
Подобно статическим переменным-членам, статические методы не привязаны к какому-либо одному объекту класса. Те их можно вызывать не через экземпляр, а непосредственно через классовое пространство имен (`::`). Те вызов аналогичен вызову static полей класса:
```cpp
class Anything
{
private:
    static int s_value;
public:
    static int getValue() { return s_value; } // статический метод
};
 
int Anything::s_value = 3; // определение статической переменной-члена класса
 
int main()
{
    std::cout << Anything::getValue() << '\n';
}
```
- Поскольку статические методы не привязаны к объекту, то они не имеют скрытого указателя `*this`! Здесь есть смысл, так как указатель `*this` всегда указывает на экземпляр, с которым работает метод. Статические методы могут не работать через экземпляр, поэтому и указатель `*this` не имеет смысла.
- Статические методы могут напрямую обращаться к другим статическим членам (переменным или функциям), но не могут к нестатическим членам. Это связано с тем, что нестатические члены принадлежат объекту класса, а статические методы — нет! Что это значит: если мы хотим что-то сделать с нестатическми полями класса, то нам нужно явно передать в этот метод объект (сссылку на объект) этого класса, и для него мы можем что-то делать с его полями.

## Special member functions (implicitly generated functions)
Просто просуммировать вышесказанное. В C++ 6 специальных ф-ций. Они особенны тема, что если программист мануально не создал их, то их сгенерирует компилятор. Это:
1. default ctor `MyClass()` - конструктор.
2. copy ctor `MyClass(const MyClass&)` - копирующий конструктор
3. dtor `~MyClass()` - деструктор
4. copy assign `MyClass& operator=(const& MyClass&)` - оператор копирования
5. move ctor
6. move assign

## friend (дружественные класса и ф-ции)
**Дружественная функция** — это функция, которая имеет доступ к закрытым членам класса, как если бы она сама была членом этого класса. Во всех других отношениях дружественная функция является обычной функцией. Ею может быть как обычная функция, так и метод другого класса. Для объявления дружественной функции используется ключевое слово `friend` перед прототипом функции, которую вы хотите сделать дружественной классу. Неважно, объявляете ли вы её в public или в private зоне класса. 
```cpp
class Anything
{
private:
    int m_value;
public:
    Anything() { m_value = 0; } 
    void add(int value) { m_value += value; }
 
    // Делаем функцию reset() дружественной классу Anything
    friend void reset(Anything &anything);
};
 
// reset() теперь является другом класса Anything
void reset(Anything &anything)
{
    // И мы имеем доступ к закрытым членам объектов класса Anything
    anything.m_value = 0;
}
 
int main()
{
    Anything one;
    one.add(4); // добавляем 4 к m_value
    reset(one); // сбрасываем m_value к 0
 
    return 0;
}
```

### Дружественные функции и несколько классов
Функция может быть другом сразу для нескольких классов. Например,
```cpp
class Humidity; 
 
class Temperature
{
private:
    int m_temp;
public:
    Temperature(int temp=0) { m_temp = temp; }
 
    friend void outWeather(const Temperature &temperature, const Humidity &humidity);
};
 
class Humidity
{
private:
    int m_humidity;
public:
    Humidity(int humidity=0) { m_humidity = humidity; }
 
    friend void outWeather(const Temperature &temperature, const Humidity &humidity);
};
 
void outWeather(const Temperature &temperature, const Humidity &humidity)
{
    std::cout << "The temperature is " << temperature.m_temp <<
       " and the humidity is " << humidity.m_humidity << '\n';
}
 
int main()
{
    Temperature temp(15);
    Humidity hum(11);
 
    outWeather(temp, hum);
 
    return 0;
}
```
Тут надо отметить, что важно внчале указать прототип класса идущего не первым (тут `class Humidity;`) тк при первом упоминании ф-ции в первом классе компилятор зайдет в нее и увидет, что там ссылаются на необъявленный класс. Он будет недоволен.

### Дружественные классы
Один класс можно сделать дружественным другому классу. Это откроет всем членам первого класса доступ к закрытым членам второго класса. Например, 
```cpp
class Values
{
private:
    int m_intValue;
    double m_dValue;
public:
    Values(int intValue, double dValue)
    {
        m_intValue = intValue;
        m_dValue = dValue;
    }
 
    // Делаем класс Display другом класса Values
    friend class Display;
};
 
class Display
{
private:
    bool m_displayIntFirst;
 
public:
    Display(bool displayIntFirst) { m_displayIntFirst = displayIntFirst; }
 
    void displayItem(Values &value)
    {
        if (m_displayIntFirst)
            std::cout << value.m_intValue << " " << value.m_dValue << '\n';
        else // или сначала выводим double
            std::cout << value.m_dValue << " " << value.m_intValue << '\n';
    }
};
 
int main()
{
    Values value(7, 8.4);
    Display display(false);
 
    display.displayItem(value);
 
    return 0;
}
```
На самом деле, даже если Display является другом Values, это не означает, что Values также является другом Display. Если вы хотите сделать оба класса дружественными, то каждый из них должен указать в качестве друга противоположный класс. Наконец, если класс A является другом B, а B является другом C, то это не означает, что A является другом C.    

#### Дружественные методы (вместо целого класса)
Вообще делать классы дружественными - это плохая идея (ломает всю инкапсуляцию). Если все же надо, что какой-то из методов одного класса мог добраться до закрытых методов другого класса, то лучше использовать дружественные методы.  Лучшим решением было бы поместить каждое определение класса в отдельный заголовочный файл с определениями методов в соответствующих файлах .cpp. Таким образом, все определения классов стали бы видны сразу во всех файлах .cpp. В этом случаии объявление будет аналогичным примеру сверху, только вместо `friend class Display;` будет `friend void Display::displayItem(Values& value);` (те только нужный нам метод).

### Does "friend" violate encapsulation?
Источник [Страуструп FAQ](https://www.stroustrup.com/bs_faq2.html#friend).      
**Does "friend" violate encapsulation?**      
No. It does not. "Friend" is an explicit mechanism for granting access, just like membership. You cannot (in a standard conforming program) grant yourself access to a class without modifying its source. For example:
```cpp
class X 
{
	int i;
public:
	void m();		// grant X::m() access
	friend void f(X&);	// grant f(X&) access
	// ...
};
void X::m() { i++; /* X::m() can access X::i */ }
void f(X& x) { x.i++; /* f(X&) can access X::i */ }
```

- Дружественное отношение открывает доступ ко всем члена класса (в тч и закрытым), в то время как наследование открывает доступ только public и protected члена. Таким образом **friend сильнее наследования**.

## void * или история про злого близница
Существует такая уезвимость у закрытых членов классов/структур: доступ к ним можно получить через злого близница.   
Допустим, есть такой класс: 
```cpp
class Cls{

public:
	Cls() = default;
private:
	char c = 'a';
    	double d = 3.14;
	int i = 101;
};
```
Все его члены (c, d, i) закрыты а мы хотим получить к ним доступ используя ф-ции вида: `char& get_c(Cls& cls)` те в нее передается экщемпляр класса по ссылке и возвращается ссылка на этот элемент. Чтобы это сделать, нам нужно сделать подставного "злого брата-близница", который будет более сговорчив:
```cpp
class Cls_bro {

public:
	Cls_bro() = default;
	char c;			//Он более сговорчив
	double d;		//делаем нужные нам поля открытыми 
	int i;
};
```
Теперь идет хитрость внутри ф-ции `get_c`. В нее мы будем передавать экземпляр класса `Cls`, но она должна думать, что работает с классом `Cls_bro`. Хитрость в том, что когда происходит насильственное преобразование типов (`static_cast`) из чего-то в указатель на void, то компилятор забывает, чем переменная была до этого. Поэтому преобразование типа `const int` -> `any_type` невозможны (компилятор сравнивает их и говорит, что такое преобразование невозможно), а `const int` -> `void *` -> `any_type` возможны (компилятор не помни, что было до `void *`). Итого, целиком код выглядит так:
```cpp
class Cls{

public:
	Cls() = default;
	char getter()
	{
		return c;
	}
private:
	char c = 'a';
    double d;
	int i;
};

class Cls_bra {

public:
	Cls_bra() = default;
	char c;
	double d;
	int i;
};

char& get_c(Cls& cls) {

	void* ptr = static_cast<void*>(&cls);
	Cls_bra* cls_ptr = static_cast<Cls_bra*>(ptr);
	return cls_ptr->c;
}

// аналогично можно написать ф-ции доступа и к другим полям
```

## Circular dependency (and forward declaration)
Может возникнуть ситуация, когда два класса зависимы друг от друга (например, когда методы этих классов хотят получить экземпляр другого класса). Например, пусть есть два класса Worker и Boss, которые реализвоаны в двух .h файлах: Worker.h и Boss.h соответсвенно. 
**Boss.h**
```cpp
#include "Worker.h"
class Boss{
public:
    Worker worker;
};
```
**Worker.h**
```cpp
class Boss; 	//forward declaration
class Worker{
    Boss* boss;
};
```
Тк Boss.h подключает Worker.h, то класса Boss не вознивает вопроса: "Что такое Worker?" - тк определение класса Worker вставляется впереди дерективой #include. Однако, для класса Worker не известно что такое Boss (тк его определение будет лежать ниже по коду). В этом случаи будет ошибка. Исправить все можно использую **forward declaration**: `class Boss;` перед первым его упоминанием. Мы как бы говорим компилятору: "Boss - это класс, это все, что тебе надо знать сейчас. Его оперделение ты увидишь далее".     
Аналогично можно сделать forward declaration, когда нам надо передать в метож экземпляр ф-циию. Например,
```cpp
/* Есть класс Snake. Его метод Eat принимает экземпляр класса Apple. Тк Snake не знает про Apple,
нам надо сказать компилятору, что это класса. Можно просто добавть слов class в аргументе */
void Snake::Eat(class Apple RedDelicious) {//тут что-то происходит}
```
