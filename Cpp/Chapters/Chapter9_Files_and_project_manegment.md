# Chapter 9 Files and project magement 

## Файлы 
### Добавление файла в проект
1. Файл добавляется в проект через IDE ( «File» -> «New» -> «File…» -> «C/C++ source»), а затес в вызывающем файле делается прототип вызываемой функции (т.е. просто объявление).
2. `#include "my_file.cpp"` - копирует my_file *целиком* сразу этой инструкции внутрь ф-ции, в которой выполнятеся инструкция. Поэтому так делать *плохо* (т.к. теряется весь смысл разбивать на файлы)! Инструкция `#include ..` нужна для headr files (см. ниже).

## Заголовочные файлы (header file) (`.h`)
Это файл состоящий из прототипов функций и все (технически, можно и определять ф-ции, но это табу!). При вызове (`#include ..`) записывает все своем содержимое (т.е. все прототипы) сразу за инструкцией и все портотипы оказываются в зоне видимости функции.
- `#include <iostrem>` - зывов header file из *стандартной библиотеки* ( 1. используются <> и 2. опущена .h)
- `#include "my_header.h"` - зывов *собственного* header file   
### Содержимое
Header file состоит из 2х частей:
1. **директивы препроцессора**, в частности, header guards, которые предотвращают вызов заголовочного файла больше одного раза с одного и того же файла;
2. **содержимое заголовочного файла**: набор объявлений.   
```cpp
// Начинаем с директив препроцессора. ADD_H – это произвольное уникальное имя (обычно используется имя заголовочного файла)
#ifndef ADD_H
#define ADD_H
 
// А это уже содержимое заголовочного файла
int add(int x, int y); // прототип функции add() (не забывайте точку с запятой в конце!)

// Заканчиваем директивой препроцессора
#endif
```
### Директивы препроцессора
**Препроцессор** лучше всего рассматривать как отдельную программу, которая выполняется перед компиляцией. При запуске программы препроцессор просматривает код сверху вниз, файл за файлом, в поиске директив. **Директивы** — это специальные команды, которые начинаются с символа # и НЕ заканчиваются точкой с запятой. Препроцессор проходит файл сверху вниз и игнорирует все инстрекции без #. Поэтому не важно где их писать (вначале файла, внутри функции и т.д.), он не видит границ у ф-ций.
- `#include <filename>` которая сообщает препроцессору искать файл в системных путях (standard library). `#include "filename"` - которая сообщает препроцессору искать файл в текущей директории проекта (собственный файл). Если его там не окажется, то препроцессор начнёт проверять системные пути и любые другие, которые вы указаны в настройках IDE. 
- `#define ` - создает макросы. **Макрос** — это правило, которое определяет конвертацию идентификатора в указанные данные. Есть два основных типа макросов: **макросы-функции** и **макросы-объекты**.	**Макросы-функции** ведут себя как функции и используются в тех же целях. Они считается опасным, и почти всё, что они могут сделать, можно осуществить с помощью простой (линейной) функции. **Макросы-объекты** можно определить одним из двух следующих способов:   
	`#define identifier` -  любое дальнейшее появление *identifier*  заменяется «ничем» (пустым местом)! 
	`#define identifier substitution_text` - любое дальнейшее появление *identifier* заменяется на *substitution_text*. (такое использование #define считается плохой практикой, т.к. замены будут в глобальной области видимости всей программы. Вместо этого лучше использовать const: `const int smth = 30` и по мере необходимости меня все в ней).
	```cpp
	#define MY_NUMBER 9
 
	std::cout << "My number is: " << MY_NUMBER << std::endl;  //Результат выполнения: "My number is: 9"
	```
- Директивы условия компиляции   
	`#ifdef` Директива #ifdef (англ. «if defined» = «если определено») позволяет препроцессору проверить, было ли значение ранее #define. Если да, то код между `#ifdef` и `#endif` скомпилируется. Если нет, то код будет проигнорирован. Например:
  	```cpp
	#define PRINT_JOE
	
	#ifdef PRINT_JOE                   //скомпилируется и выполнится
	std::cout << "Joe" << std::endl;  
	#endif
 
	#ifdef PRINT_BOB		   //поскольку PRINT_BOB не был #define, будет проигнорована (не скомпилируется)
	std::cout << "Bob" << std::endl;
	#endif
	```
	Директива `#ifndef` (англ. «if not defined» = «если не определено») — это полная противоположность #ifdef, которая позволяет 	проверить, не было ли значение ранее определено. В примере вышe: выполнится часть PRINT_BOB, так как PRINT_BOB ранее никогда 	 	 не был #define. PRINT_JOE не выполниться, так как есть #define PRINT_JOE.   
	
	- В принципе, т.к.  препроцессор игнорирует все кроме #, то не важно, где писать #define PRINT_JOE (внутри функции или вне). Однако, принято писать их вне функций для читабельности кода.
	- Директивы, определённые в одном файле кода, не влияют на директивы, определённые внутри других файлов этого же проекта (т.е. область видимости ограничена файлом).
### header guards
1. Это конструкция из директив, которые предотвращают повторное подключение файла (и соответственно повторного определения функции/переменной). Например, в *main* - файле есть вызов *math.h* - файл и *geometry.h* (а в ней повторый вызов *math.h*. В итоге в *main* будет дважды скопированно содержимое *math.h*, что приведет к ошибке компиляции. Решение head guard:
	```cpp
	#ifndef UNIQUE_NAME_HERE		/* код ниже выполнится ниже, только если UNIQUE_NAME_HERE не была 
	определена (т.е. не было вызова #define UNIQUE_NAME_HERE), иначе проигнорирует */
	#define UNIQUE_NAME_HERE		/* тут мы определили UNIQUE_NAME_HERE, далее этот файл будет 
	ассоциироваться с UNIQUE_NAME_HERE, и в дальнейшем не пройдет проверку #ifndef UNIQUE_NAME_HERE	*/

	// основная часть кода 

	#endif
	```
	Так, если UNIQUE_NAME_HERE не была определена, то код выполниться. При повторном вызове, UNIQUE_NAME_HERE уже определена и дальше код не пойдет (не будет второго вызова). Обычно UNIQUE_NAME_HERE называют по названтю файла +_H (напр, файл *math*: MATH_H: `#ifndef MATH_H`)

2. Более простой способ добиться того же результата - это использование дерективы `#pragma once`. Она так же убедится, что содержимое файла добавлено только один раз. 
	```cpp
	#pragma once
	
	// основная часть кода 
	```

## Рефакторинг классов
Обычно сложные/объемные классы разбивают на два файла: объявление класса, его поля, а также протатипы методов (файлы .h) и реализацию методов (файлы .cpp). Файл .h подключается к .cpp с main(), а файл .cpp должне просто находится в проекте. После компиляции с ним будет разбираться линковщик. Это делает код более гибким. Например, если требуется поменять часть кода в одном их методов, то надо просто поменять содержимое .cpp и скомпилировать только его, вместо того, чтобы перекомпилировать весь проект.    

### Область принадлежности (::)
Если какой-либо метод был вынесен за пределы объявления класса, то надо указать его область принадлежности (`::`) (даже если метод остался в том же файле):
```cpp
class Date
{
private:
    int m_day;
    int m_month;
    int m_year;
 
public:
    Date(int day, int month, int year);		 //прототип конструктора находится внутри зоны объявления класса
 
    void SetDate(int day, int month, int year);	 //прототип находится внутри зоны объявления класса
 
    int getDay() { return m_day; }
    int getMonth() { return m_month; }
    int getYear()  { return m_year; }
};
 

// Конструктор класса Date 
Date::Date(int day, int month, int year)	 //а реализация вне зоны объявления, поэтому нужно указать пренадлежность к классу
{
    SetDate(day, month, year);
}
 
// Метод класса Date 
void Date::SetDate(int day, int month, int year) //аналогично 
{
    m_day = day;
    m_month = month;
    m_year = year;
}
```
Тут конструктор и метод вынесены за пределы зоны объявления класса, поэтому компилятор не знает кому пренадлежат эти ф-ции. Поэтому необходимо указать их пренадлежность к классу: `Date::SetDate()` - те метод `SetDate()` класса `Date`. `Date::Date()` - метод `Date()`(конструктор) класса `Date`.
