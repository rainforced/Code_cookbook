# Chapter 2 Operators

## Assiment and initialisation
1. Есть в C++ все переменные являются **l-values**, т.е. стоят слева от оператора присвоения. L-values имеют ячейку в памяти (и адрес), куда записываются значения. **r-value** (спарава) — это значение, которое не имеет постоянного адреса в памяти. Так числа не имеют места в памяти. Например:  
```cpp
int a=5;  	
a = 4 + 6;	// в обоих случая a - l-value

int b;		// тут b - это l-value
b = a;		// тут b - l-value, a - r-value (не переменная, а число 10) т.е. это тоже самое что просто `b = 10;`
b = b + 2;	// тут b и l-value (слева) и r-value(справа): `b = 10 + 2;`
```
2. При **объявлении (declare)** переменной ей присваивается некоторая ячейка памяти (определенного рамеза, в зависимости от типа данных). При **присваивании (assigment)** происходит полное копирование объекта. **Инициаллизация (initialization)** - это объявление и присвоение за раз.
```cpp
vector<int> x = {1,2,3,4}	//Инициализация
vector<int> y;                  //Объявление
y = x                           /*Присвоение. Создаст новую копию (выделит место в памяти). 
                                Т.е. будет 2 независимых вектора x и y, а не 2 указателя на 1 объект как в python */
```
3. Есть 3 типа инициализации:
	1. `int nValue = 5; // копирующая инициализация` - работает не со всеми типами данных 
	2. `int nValue(5);  // прямая инициализация` - работает не со всеми типами данных 
	3. `int value{5};   // uniform инициализация` - - работает со всеми типами данных (начиная с C++ 11). `int value{}; // инициализация переменной по умолчанию - нулём`.  
```cpp
double d(5.0); // 5.0 - это тип данных с плавающей точкой (по умолчанию double)
float f(5.0f); // 5.0 - это тип данных с плавающей точкой, "f" от "float"
```
4. присваивание - только копирующее `int nValue; nValue = 5; // копирующее присваивание`   
5. Для нескольких переменных разом:   
```cpp
int x, y;		// объявление нескольких переменных разом (только для перемен. одного типа)
int a = 5, b = 6;	// инициализация нескольких переменных разом 
int c(7), d(8);		// (всеми 3мя способами)
int e{9}, f{10};
// смешаный случай (можно, но не рекомендуется)
int a, b(5); 		// значение 5 присваивается только переменным b и d.
int c, d{5};
```    
6. **Правило:** Определяйте переменные как можно ближе к их первому использованию:
```cpp
int main()
{
    std::cout << "Enter a number: ";
    int x; // мы используем x в следующей строке, поэтому объявляем эту переменную здесь: как можно ближе к её первому использованию
    std::cin >> x; // первое использование переменной x
 
    std::cout << "Enter another number: ";
    int y; // переменная y понадобилась нам только здесь, поэтому здесь её и объявляем 
    std::cin >> y; // первое использование переменной y
 
    std::cout << "The sum is: " << x + y << std::endl;
    return 0;
}
```
Это улучшает читаемость: сразу понятно где и для чего нужна переменная, не надо держать ее в голове до первой встречи и т.д.

## Виды инициализации
С прямой и uniform инициализациями создаваемый объект непосредственно инициализируется. В случаии копирующей инициализации сначала создается анонимный объект, а потом он копируется в инициализируемый объект с помощью конструктора копирования.
1. **Прямая инициализация** 
	```cpp
	int a(7); // прямая инициализация целочисленной переменной
	Drob sixSeven(6, 7); // прямая инициализация объекта класса Drob, вызывается конструктор Drob(int, int)
	```
2. **Uniform** (начиная с С++11
	```cpp
	int a { 7 }; // uniform инициализация целочисленной переменной 
	Drob sixSeven {6, 7}; // uniform инициализация объекта класса Drob, вызывается конструктор Drob(int, int)
	```
	Uniform initialization **точнее**, чем прямая. Это значит, что прямая инициализация позволяет сужающее неявное преобразования, а uniform - нет. Например,
	```cpp
	class MyClass
	{public: 
		MyClass(int in_a) : a(in_a) {}
		int a; 
	}
	//сужающее преобразование: предотавляем float, а класс ждет int
	MyClass A(20.4f); //компилятор сделает предупреждение, но все стработает и 20.4f "сузят" до 20 
	MyClass B{20.4f}; //Ошибка! Компиятор запрещает неявное сужение при uniform initialization 
	```
3. **Копирующая инициализация**
	```cpp
	int a = 7; // копирующая инициализация целочисленной переменной
	Drob eight = Drob(8); // копирующая инициализация объекта класса Drob, вызывается Drob(8, 1)
	Drob nine = 9; /* копирующая инициализация объекта класса Drob. Компилятор будет искать способ конвертации 9 в объект класса Drob, что приведёт к вызову конструктора Drob(9, 1) */
	```
	Важно, что при копирующей инициализации компилятор может решить не вызывать копирующий конструктор (подробнее см. в [разделе про классы](https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/Chapter6_Classes.md)).

## Оператор запятая (,)
`x, y` - Вычисляется x, затем вычисляется y, а затем возвращается значение y. (Зачем он нужен - неясно, т.к. читается он плохо).
```cpp
z = foo(), bar(); // выполняются обе ф-ции как, но переменной z присваивается значение из bar(), а значение из foo() игнорируется
```

## Тернарный if 
`c ? x : y` - Если c — ненулевое значение (true), то вычисляется x, в противном случае — y (**(условие) ? выражение : другое_выражение;**). Нужен для коротких выражений if else
```cpp
if (x > y)
    std::cout << x;
else
    std::cout << y;
  
// тоже самое 

larger = (x > y) ? x : y;
```
Или так:
```cpp
bool inBigClassroom = false;
const int classSize = inBigClassroom ? 30 : 20;  // если false, то 30, если true 20
```

## && (и) и || (или)
Логические операторы И и ИЛИ. Про них важно значть, что они "ленивые" те: всгде вычеслятся только первый (левый) опреанд, и если этого достаточно, то правый вычисляться не будет. Так для оператора И, если 1й опранд - false, то все выражение - false и нет смысла вычислять дальше. Для оператора ИЛИ, если 1й операнд - true, то все выражение - true. Наример,
```cpp
(a!=0) && (b == 1);	//вычисляется (a!=0), если false, то (b==1) не вычислятеся - все false
(a!=0) || (b == 1);	//вычисляется (a!=0), если true, то (b==1) не вычислятеся - все true
```
Казалось бы это не важно, но может возникнуть проблема, если второй операнд совершает какое-то важное действие, например ф-ция возвращающая bool, но что-то важное происходит в ее теле. Например,
```cpp
foo() && bar();		//вычисляется foo(), если false, то bar() не вычислятеся - все false
foo() || bar();		//вычисляется foo(), если true, то bar() не вычислятеся - все true
```

## Math
1. Экспоненциальная запись: 1.2 x 10^4 эквивалентно `1.2e4`
2. i++, ++i - инкременты. `int x = ++y` присвоит (y+1) (считается более безопасным). `int x = y++` сначала присвоит y, а потом прибавит 1. 
   i--, --i - декрименты
3. Деление: `int x, y; x/y` вернет целочисленное деление, если оба int. Если любой из них float/double, то вернет обычное деление.
`x%y` - остаток от деления.
4. Логика: не `!a`, и `&&`, или `||`
5. 8-ричная, 16-ричная сисемы и бинарная (с С++ 14):
```cpp
int x = 012; // 0 перед значением означает, что это восьмеричный литерал
int x = 0xF; // 0x перед значением означает, что это шестнадцатеричный литерал
// Начиная с С++ 14 бинарная
bin = 0b11; // присваиваем переменной бинарный литерал 0000 0011 
bin = 0b1010; // присваиваем переменной бинарный литерал 0000 1010
```

### cmath
`# include <cmath>`   
- `pow(x, power)` x^power. Принимает и ворварщает тип double. 

### random number generator
#### Хороший генератор последовательности случайных чисел (ГПСЧ)
Т.к комньютер не способен генерировать случайные числа, то все ГПСЧ работают по принципу: 1) берем какое то начальное значение (seed), а потом последовательно проводим операции над ним. Если опреции подобраны хорошо, то они будут производить псеводо случайные числа. Однако, у это последовательности есть логика (которую можно взломать) и переод генерации (это значит, что через сколько-то чисел все пойдет по кругу, и последовательность повторит саму себя). Хороший ГПСЧ обладает свойствами:    

1. ГПСЧ должен генерировать каждое новое число с примерно одинаковой вероятностью. Это называется **равномерностью распределения**.
2. Метод, с помощью которого генерируется следующее число в последовательности, не должен быть очевиден или предсказуем.
3. ГПСЧ должен иметь хорошее диапазонное распределение чисел. Это означает, что маленькие, средние и большие числа должны возвращаться случайным образом
4. Хороший ГПСЧ должен иметь длинный период для любых стартовых чисел (seed). Бывают ГПСЧ, которые имеют разный период и неравномерно распределяют СЧ в зависимости от seed. 

#### Типы ГПСЧ доступные в C++
1. `#include <cstdlib>` - простой ГПСЧ.
	- `srand(4541)` - создает зерно для генирации случайных чисел (СЧ). В качетсве seed часто ставят системные часы с помощью ф-ции `time()`, которая возвращает в качестве времени общее количество секунд от полуночи 1 января 1970 года. Например,   
	```cpp
	// устанавливаем значение системных часов в качестве стартового числа
	#include <ctime> // для функции time()
	#include <cstdlib> // для функций rand() и srand()
	srand(static_cast<unsigned int>(time(0)));
	```

	- `rand()` - создает СЧ с помощью Линейного Конгруэнтного Метода (или ещё «ЛКМ»).     
	Это довольно посредственный ГПСЧ т.к. 1) имеет невысокий период генерации, 2) RAND_MAX (максимум длинны) обычно устанавливается как 32 767 (15-битное значение), 3) генерирует только int.      
	**Генерачия СЧ в определенном диапозоне**
	```cpp
	// Генерируем рандомное число между значениями min и max
	// Предполагается, что функцию srand() уже вызывали
	int getRandomNumber(int min, int max)
	{
	    static const double fraction = 1.0 / (static_cast<double>(RAND_MAX) + 1.0); 
	    // Равномерно распределяем рандомное число в нашем диапазоне
	    return static_cast<int>(rand() * fraction * (max - min + 1) + min);
	}
	```

2. `#include <random>` - позволяет использовать более продвинутые ГПСЧ, такие как Вихрь Мерсенна и другие
	```cpp
	#include <iostream>
	// #include <ctime> // раскомментируйте, если используете Code::Blocks
	#include <random> // для std::random_device и std::mt19937

	int main()
	{
	    std::random_device rd; 
	    std::mt19937 mersenne(rd()); // инициализируем Вихрь Мерсенна случайным стартовым числом 

	// Примечание: Из-за одного бага в компиляторе Code::Blocks (если вы используете Code::Blocks в Windows) - удалите две строчки кода выше и раскомментируйте следующую строчку:
	// std::mt19937 mersenne(static_cast<unsigned int>(time(0))); // инициализируем Вихрь Мерсенна случайным стартовым числом

	    // Выводим несколько случайных чисел
	    for (int count = 0; count < 48; ++count)
	    {
		std::cout << mersenne() << "\t";

		// Если вывели 5 чисел, то вставляем символ новой строки
		if ((count + 1) % 5 == 0)
		    std::cout << "\n";
	    }
	}
	```
	Пример из Chili games:
	```cpp
	std::random_device rd;
	std::mt19937 rng(rd());
	std::uniform_int_distribution<int> widthDist(0, width);
	std::uniform_int_distribution<int> heightDist(0, height);
	gridPos.x = widthDist(rng);
	gridPos.y = heightDist(rng);
	```
