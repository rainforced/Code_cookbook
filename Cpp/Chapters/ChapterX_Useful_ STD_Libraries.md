# Chapter X: Useful STD Libraries
## chrono (для замеров времени)
На основе библотеки хроно удобно строить время выполнения программ. Например, в Chili Framework она используется для того, чтобы циклы работы игр были равномерны:
**FrameTimer.h**
```cpp
#pragma once
#include <chrono>

class FrameTimer
{
public:
	FrameTimer();
	float Mark();
private:
	std::chrono::steady_clock::time_point last;
};
```
**FrameTimer.cpp**
```cpp
#include "FrameTimer.h"

using namespace std::chrono;

FrameTimer::FrameTimer()
{
	last = steady_clock::now();
}

float FrameTimer::Mark()
{
	const auto old = last;
	last = steady_clock::now();
	const duration<float> frameTime = last - old;
	return frameTime.count();
}
```
Далее в .cpp игры создается экземпляр класса `FrameTimer ft`. При инициализации, замеряется время. Далее при каждом вызове `Mark()` замеряется время сейчас и находится разница между этим и прошлым ее вызовом (или инициализацией, если это первый вызов). Ф-ция возвращет разницу времени, те время цикла программы: `const float dt = ft.Mark();`.

## time.h (для замеров времени)
```cpp
#include <time.h>

clock_t time_req;
time_req = clock();
// делаем наше дело
time_req = clock() - time_req;
printf("Processor time taken for the integration: %f sec\n", (float)time_req / CLOCKS_PER_SEC);
```

## random
(повторенно из главы про математические операции)

### Хороший генератор последовательности случайных чисел (ГПСЧ)
Т.к комньютер не способен генерировать случайные числа, то все ГПСЧ работают по принципу: 1) берем какое то начальное значение (seed), а потом последовательно проводим операции над ним. Если опреции подобраны хорошо, то они будут производить псеводо случайные числа. Однако, у это последовательности есть логика (которую можно взломать) и переод генерации (это значит, что через сколько-то чисел все пойдет по кругу, и последовательность повторит саму себя). Хороший ГПСЧ обладает свойствами:    

1. ГПСЧ должен генерировать каждое новое число с примерно одинаковой вероятностью. Это называется **равномерностью распределения**.
2. Метод, с помощью которого генерируется следующее число в последовательности, не должен быть очевиден или предсказуем.
3. ГПСЧ должен иметь хорошее диапазонное распределение чисел. Это означает, что маленькие, средние и большие числа должны возвращаться случайным образом
4. Хороший ГПСЧ должен иметь длинный период для любых стартовых чисел (seed). Бывают ГПСЧ, которые имеют разный период и неравномерно распределяют СЧ в зависимости от seed. 

### Типы ГПСЧ доступные в C++
1. `#include <cstdlib>` - простой ГПСЧ.
	- `srand(4541)` - создает зерно для генирации случайных чисел (СЧ). В качетсве seed часто ставят системные часы с помощью ф-ции `time()`, которая возвращает в качестве времени общее количество секунд от полуночи 1 января 1970 года. Например,   
	```cpp
	// устанавливаем значение системных часов в качестве стартового числа
	#include <ctime> // для функции time()
	#include <cstdlib> // для функций rand() и srand()
	srand(static_cast<unsigned int>(time(0)));
	```

	- `rand()` - создает СЧ с помощью Линейного Конгруэнтного Метода (или ещё «ЛКМ»).     
	Это довольно посредственный ГПСЧ т.к. 1) имеет невысокий период генерации, 2) RAND_MAX (максимум длинны) обычно устанавливается как 32 767 (15-битное значение), 3) генерирует только int.      
	**Генерачия СЧ в определенном диапозоне**
	```cpp
	// Генерируем рандомное число между значениями min и max
	// Предполагается, что функцию srand() уже вызывали
	int getRandomNumber(int min, int max)
	{
	    static const double fraction = 1.0 / (static_cast<double>(RAND_MAX) + 1.0); 
	    // Равномерно распределяем рандомное число в нашем диапазоне
	    return static_cast<int>(rand() * fraction * (max - min + 1) + min);
	}
	```

2. `#include <random>` - позволяет использовать более продвинутые ГПСЧ, такие как Вихрь Мерсенна и другие
	```cpp
	#include <iostream>
	// #include <ctime> // раскомментируйте, если используете Code::Blocks
	#include <random> // для std::random_device и std::mt19937

	int main()
	{
	    std::random_device rd; 
	    std::mt19937 mersenne(rd()); // инициализируем Вихрь Мерсенна случайным стартовым числом 

	// Примечание: Из-за одного бага в компиляторе Code::Blocks (если вы используете Code::Blocks в Windows) - удалите две строчки кода выше и раскомментируйте следующую строчку:
	// std::mt19937 mersenne(static_cast<unsigned int>(time(0))); // инициализируем Вихрь Мерсенна случайным стартовым числом

	    // Выводим несколько случайных чисел
	    for (int count = 0; count < 48; ++count)
	    {
		std::cout << mersenne() << "\t";

		// Если вывели 5 чисел, то вставляем символ новой строки
		if ((count + 1) % 5 == 0)
		    std::cout << "\n";
	    }
	}
	```
	Пример из Chili games:
	```cpp
	std::random_device rd;
	std::mt19937 rng(rd());
	std::uniform_int_distribution<int> widthDist(0, width);
	std::uniform_int_distribution<int> heightDist(0, height);
	gridPos.x = widthDist(rng);
	gridPos.y = heightDist(rng);
	```
