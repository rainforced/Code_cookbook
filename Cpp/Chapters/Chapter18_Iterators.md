# Chapter 18: Iterators
**Iterator** - это специальный тип данных, который ведет себя подобно указателю, у который есть ряд расширенных возможностей. Под капотом это и есть указатель, но к нем прикручено много крутых фишек. У каждого контейнера, входящего в STL обязательно есть возможность работы с итераторами. Тип данных итератора и его реализация зависит от конкретного контейнера.

## Основы синтаксиса
Основной синтаксис и операции аналогичны операциям с указателями.     

Самым простым (и облажающий самыми широкими возможностями) является итератор работающий с непрерывнми контейнерами (где последовательные элементы лежат в памяти последовательно). Возьмем для примера `std::vector`. Его итератор имеет тип данных `std::vector<int>::iterator`.      

<img src = "https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/images/iterator.png" alt = "iterator" width = 500 >


```cpp
std::vector<int> v = {0,1,2,3,4,5,6};
//можно целиком писать тип данных итератора
std::vector<int>::iterator beg = v.begin(); //указывает на 1
//но удобнее использовать auto 
auto end = v.end();                         //указывает на ячейку памяти следующую за 6
  
for (auto i = v.begin() + 1, e = v.end() - 2; i !=e; ++i)
{
  std::count << *i << " ";                  // for пробегающий {1, 2, 3, 4, 5}
}
```

- У каждого контейнера из STL есть 2 метода: `begin()` (возвращает итератор указывющий на 1й элемент контейнера) и `end()` (возвращает итератор указывющий на ячейку памяти следующую за последним элементом контейнера). Так итератор обычно работают в диапозоне: **[begin, end)**.    
- Для итераторов работает арифметика указателей. Те инкремент `++i` передвинит итератор на следующий элемент, а `--i` на предыдущий. Важно отметить, что зачастую `++i` работает быстрее, чем `i--`, поэтому работая с итераторами **следуюет использовать ++i**. Если контейнер последовательный, то можно делать шаг в n элеметнов: `i+n` или `i-n`, где n - это int число. Разница итераторов работает как у указателей: `v.end() - v.begin()` - вернет размер контейнера.
- Разименование происхоидт аналогично указателям: `*i` возвращает ссылку на элемент. Например, `*(v.begin()+k)` - возвращает ссылку на k-й элемент контейнера v. Для итераторов `i->x` работает так же как и для указателей - это значит `(*i).x`.

### Iterator invalidation 
Одно из главных отличий итераторов от указателей - это то, что компилятор проверяет корректность операций над итераторами. Если операция некорректна, то срабатывает Исключение. Что может пойти не так? Например:
- `*v.end()` - пытаемся разименовать итератор указывающий на следующий за контейнером элемент, те лежащий вне контейнера. Исключение! 
- `--v.begin()` - декрементрировали за пределы контейнера. Исключение! 
- ```cpp
  std::vector<int> v = {0,1,2,3,4,5,6,7};
  auto i_invalid = v.begin() + 4;         //указывает на элемент 4
  v.erase(v.begin() + 3, v.begin() + 6);  //стерили из vector элементы [3, 5], теперь v={0,1,2,6,7}
  std::cout << *i_invalid;                //пытаемся разименовать элемент 4
  ```
  Мы создали итератор на элемент 4 нашего вектора. Затем мы стерли элементы [3,5]. Теперь пытаемся разименовать итератор, но он теперь указывает на 7 (тк erase удаляет указанные элементы и сдвигает последующие). Итератор понимает, что это не то чего мы хочем и вызовет Исколючение! 

- ```cpp
  std::vector<int> v = {0,1,2,3,4,5,6,7};
  auto i_invalid = v.begin() + 4;         //указывает на элемент 4
  v.push_back(69);                        //пристраиваем  69 в конец вектора
  std::cout << *i_invalid;                //пытаемся разименовать элемент 4
  ```
  Мы создали итератор на элемент 4 нашего вектора. Затем мы добавляем число 69 в конец вектора. Если при этом не хватит capacity этого вектора (см подробнее в главе про [std::vector](https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/Chapter12_std_data_types.md#vector-%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC%D0%B5%D1%80%D0%BD%D1%8B%D0%B9-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2-%D0%BB%D1%8E%D0%B1%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0), то ему придется выделить новый участок памяти и скоприровать свое содержимое туда, освободив старую память. В этом случаии итератор будет указывать на старый участок памяти. И этого не хотим, поэтому он вызовет Исключение!            
 
И куча других случаев. На самом деле, при работе с STL контейнерами многие методы могут invalidate (сломать и вызвать Исключение) итераторы, поэтому нужно смотреть докуметнацию к используемым методам (как это происходит с erase() и push_back() в примерах выше).      

-------

При этом, некоторые методы не только колечат итераторы, но и лечат их тоже. Например, следующий код с erase() вызовет Исключение:
```cpp
std::vector<int> v = {1,2,3,4,5};
for (auto i = v.begin(), e = v.end(); i != e; ++i)
{
  if(*i % 2 == 0)     //удаляем четные элементы
  {
    v.erase(i); 
  } 
}
```
Мы инициализуем итератор i в начале, а потом инкрементируем его в цикле. Тк при работе erase() сместит все элементы на место удаленного (те теперь v = {1,3,4,5}), то итератор будет указывать на неправильный элемент (в новом цикле попадет на 4, перескочив 3), что вызовет Исколючение. К счастью, erase() умнее, чем кажется, и когда он смещает все элементы на место только что удаленных, он возвращает итератор на первый из смещенных элеметнов (те на элемент 3). Таким образом, следующий код будет делать именно то, что мы хотим
```cpp
std::vector<int> v = {1,2,3,4,5};
for (auto i = v.begin(), e = v.end(); i != e;)
{
  if(*i % 2 == 0)     //удаляем четные элементы
  {
    i = v.erase(i);   //удаляем и возвращем итератор на первый из сдвинутых элементов
    e = v.erase(i);   //нужно поправить, тк конец тоже сдвинулся
  }      
  else
  {
    ++i;
  }
}
```

## Инкриментирование в итераторах
Пожалуй, главным преимушеством итератора над обычными указателями (и индексированием) является то, что **арифметика итераторов - умная арифметрика!**. Чтобы понять, что это значит сравним два вида контейнеров: vector и forward_list (это такой связанный список, где переместиться можно только 1 элемент вперед, тк только данный элемент знает адрес последующего).
- **vector** - нет особых проблем при перемещении между элементами непрерывного контейнера (например, array, vector или string), и можно использовать обычные указатели и индексирование. Например, арифметика для векторов будет рабоать одинаково для как для указателей, так и для итераторов: 
  ```cpp
  std::vector<int> v1 = { 1,2,3,4,5,6 };
  auto* v = &v1[0];
  std::cout << v[4] << ' ' << *(v + 3); // Все эти действия разрешены и будут работать как и ожидается.
  std::cout << *(++v);                  // Хотя и выглядит немного насильственно
  
  auto i = v.begin();   //создали итератор
  std::cout << *(i+4) << *(i+5);        //выведет то же самое. Индексирование для итераторов не работает
  std::cout << *(++i);
  ```
- **forward_list** - мы можем переместиться только на 1 элемент за раз, а также последовательные элементы списка лежат в памяти непоследовательно. Поэтому арифметрика указателей тут запрещена (и не имеет особого смысла, тк элементы не последовательны в памяти). В то же время, арифметрика итераторов работает (однако разрешены только `++i` и `i++`:  
  ```cpp
  std::forward_list<int> li {1,2,3,4,5,6};
  auto i = li.begin();
  std::cout << *(i) << std::endl;
  std::cout << *(++i); 
  ```

## Итераторы бывают разные
В зависимости от контейнера итератор может обладать разными возможностями. Типы итераторов и их особенности можно найти в [документации](http://www.cplusplus.com/reference/iterator/). В общем случаии, любой итератор может/имеет:
1. Конструктор копирования и оператор присваивания. Он также имеет деструктор (так что он сам за собой приберет).
2. Оператор инкремента `++i` и `i++` (но не обязательно имее декримент).
3. Оператор разименовывания (у некоторых он для rvalue, а у некоторых lvalue)      

Остальные возможности зависят от типа итератора.

## Почему вся STL построена на итераторах?
Использование итераторв позволяет писать универсальный код для самого разного типа контейнеров. Пусть мы хотим написать ф-цию, которая выводит элементы любого контейнера из STL. Мы не можем использовать указатели или индексирование, тк это не сработает для непоследовательных контейнеров (например, forward_list). Выход - итераторы:
```cpp
template<typename Iter>             // тип итератора зависит от контейнера
void print(Iter begin, Iter end)
{
    for (; begin != end; ++begin)
    {
        std::cout << *begin << " "; //итераторы прекрасно работают с ф-циями STL, включая потоки
    }
}

int main()
{
    std::vector<int> v{ 1,2,3,4,5,6 };
    std::forward_list<int> li{ 1,2,3,4,5,6 };
    std::string str = "asdgbvc";


    print(v.begin() + 1, v.end() - 1);  //можем и срез отправить
    print(li.begin(), li.end());
    print(str.begin(), str.end());
    return 0;
} 
```
По этой причине большиство ф-ций входящих в STL работают на итераторах. Библиотека <algorithm> вообще целиком на них работает.

## Const iterator
Существуют const итераторы, которые предоставляют read-only доступ к элементам. 
```cpp
void const_test(const std::vector<int>& vec)
{
  auto i = vec.begin();  // тк вектор передан по const ссылке, то итератор будет const.
  *i = 69;               // Ошибка! Нельзя изменять элемент по const итератор
}
```
Это реализовано через перегрузки ф-ций. Так сущетвует 2 версии ф-ции begin(): обычная (возвращает обычный итератор) и const (возваращет const итератор). То же самое и для end().       
Также есть возможность самому вызвать const версию ф-ции: `cbegin()` (возваращет const итератор) даже если вызвана на обычном контейнере. То же самое и для `cend()`.

## Reverse interator 
Все как и у обычного итератора с разницей в том, что: 
- `rbegin()` - указывает на последний элемент (включительно) контейнера.
- `rend()` - указывает на участок памяти предшествующий первому элементу контейнера. Те задает такие границы: **(v.rend(), v.rbegin()]**
- При инкременте `++i` двигается "справа на лево".
Нуден он для того, чтобы разворачивать алгоритмы, не меня их кода. Например, нам ничего не надо менять в ф-ции для вывода элементов контейнера, мы просто передаем туда reverse итераторы вместо обычных:
```cpp
template<typename Iter>             // тип итератора зависит от контейнера
void print(Iter begin, Iter end)
{
    for (; begin != end; ++begin)
    {
        std::cout << *begin << " "; //итераторы прекрасно работают с ф-циями STL, включая потоки
    }
}

int main()
{
    std::vector<int> v{ 1,2,3,4,5,6 };
    print(v.rbegin(), v.rend());    //выведет 6 5 4 3 2 1 
    return 0;
}
```

Не все виды контейнеров поддерживают reverse итераторы (например, forward_list не поддерживает).

## Библиотека `<iterator>`    

### std::begin() и std::end()
Эти две ф-ции напрямую не связаны с итераторами, но полезны при создании унифицированного кода. `std::begin(array)` - возвращает указатель на начала контейнера, `std::end(array)` -  на участок памяти следующий за последним элементом. Они не особенно полезны, когда работаешь с контейнерами, у которых реализованы итераторы. Однако, если работаешь с простыми массивами (C-style массивы), то возникает проблема: это просто указатель на учаток памяти; он понятия не имеет, что такое итератор. Поэтому наша ф-ция вывода элементов не сработает на нем:
```cpp
template<typename Iter>             // тип итератора зависит от контейнера
void print(Iter begin, Iter end)
{
    for (; begin != end; ++begin)
    {
        std::cout << *begin << " "; //итераторы прекрасно работают с ф-циями STL, включая потоки
    }
}

int main()
{
    int arr[] = {4,2,0};
    print(arr.begin(), arr.end());         //Ошибка! У массива нет методов
    print(arr);                            //Ошибка! Ф-ция ждет 2 итератора
    
    print(std::begin(arr), std::end(arr)); // То, что надо!
    return 0;
}
```
**Range-based for** - реализованы на основе этих ф-ций.

### std::advace()
У каждого итератора есть поле `tag`, указывающее тип итератора. `std::advace()` сама определяет тип данного итератора и двигет его на указанное кол-во шагов вперед. В случаии непрерывного контейнера (например, std::vector) можно передвигать итератор на несколько шагов с помощью арифметики:
```cpp
 std::vector<int> v1 = { 1,2,3,4,5,6 };
 auto i = v.begin();            //создали итератор
 i += 4;                        //передвинули вперед на 4   
```
Однако, в случаии std::forward_list мы можем только инкрементировать (`++i`). Если же мы хотим передвинуть итератор на 4 вперед, то надо 4 раза инкрементировать. Для этого и нужна `std::advance()` - она сама за нас все проинкрементирует: 

```cpp
std::forward_list<int> li = { 1,2,3,4,5,6 };
auto it = li.begin();   // итератор указывающий на 1й элемент
std::cout << *it;       // мы получим: 1
std::advance(it, 4);    // передвинули на 4 
std::cout << *it;       // мы получим: 5  
``` 

### Iterator adaptors
#### std::back_insert_iterator и std::back_inserter
- `std::back_insert_iterator ` - это специальный итератор-обертка, который опеспечивает добавление новых элементов в конец контейнера. Например:
  ```cpp
  std::vector<int> v;

  std::back_insert_iterator<std::vector<int>>  it(v);

  *it = 10;                     // it is equivalent to v.push_back(10);
   it = 99;                     // it is ALSO equivalent to v.push_back(99);

  for (auto const & i : v)
      std::cout << i << " " ;   // выведет: 10 99
  ```
  Нужно обратить внимание, что изначально контейнер - пустой. Обертка берет на себя расширение контейнера и выделение ресурсов под него.    
- `std::back_inserter()` - ф-ция упрощающая работу с std::back_insert_iterator. Она принимает контейнер, а возвращает  std::back_insert_iterator. Например:
  ```cpp
  /* Ф-ция суммирующая содержимое 2х контейнеров и сохраняющая результат в 3й */
  template<typename Iter1, typename Iter2, typename Iter3>
  void sum(Iter1 beg1, Iter1 end1, Iter2 beg2, Iter3 beg3)
  {
      for (; beg1 != end1; ++beg1, ++beg2, ++beg3)
      {
          *beg3 = *beg1 + *beg2;
      }
  }

  int main()
  {
      std::vector<int> v1 = { 1,2,3,4,5,6,7 };
      std::vector<float> v2 = { 7,6,5,4,3,2,1 };
      std::list<float> li1;                 // Внимание: 1. Подходит конейнер - любого типа. 2. Не надо самому выделять память

      sum(v1.begin(), v1.end(), v2.begin(), std::back_inserter(li1));
      for (auto ch : li1)
      {
          std::cout << ch << std::endl;
      }
      return 0;
  }
  ```
  Внимание: 
  1. Подходит конейнер - любого типа. Тут мы складываем содержимое std::vector и сохраняем в std::list. О синхронизации контейнеров заботится `std::back_insert_iterator`.
  2. Не надо самому заботиться о выделении памяти и величине контейнера ассоциированного с `std::back_insert_iterator()`.

- Также есть `std::front_insert_iterator()` и `std::front_inserter()`, делающие то же самое, только добавляя новые элементы впереди, а не сзади.

## Stream iterators 
### std::istream_iterator и std::ostream_iterator
Эти два итератора напрямую работают с потоками: `std::istream_iterator` - считывает с input; `std::ostream_iterator` - записывает в output потоки. Например, код выше можно переписать, неиспользуя 3й контейнер, а напрямую транслировать результат в output поток:
 ```cpp
  /* Ф-ция суммирующая содержимое 2х контейнеров и сохраняющая результат в 3й */
  template<typename Iter1, typename Iter2, typename Iter3>
  void sum(Iter1 beg1, Iter1 end1, Iter2 beg2, Iter3 beg3)
  {
      for (; beg1 != end1; ++beg1, ++beg2, ++beg3)
      {
          *beg3 = *beg1 + *beg2;
      }
  }

  int main()
  {
      std::vector<int> v1 = { 1,2,3,4,5,6,7 };
      std::vector<float> v2 = { 7,6,5,4,3,2,1 };

      sum(v1.begin(), v1.end(), v2.begin(), std::ostream_iterator<float>(std::cout, " | "));  // выведет результат в терминал
      return 0;
  }
  ```
  `std::ostream_iterator<float>(std::cout, " | "))`        
1. Это шаблон, и нужно указать вид параметра в <> . Этот параметр говорит компилятору в каком виде надо представить получиенные данные. Те в output потоке данные будут обработаны и представлены, как float. 
2. Первый параметр это сам поток (в нашем случаии std::cout). Второй параметр (опционально) - это разделитель между элементами контейнера, ассоциированного std::ostream_iterator.

## Базовый итератор для кастомного класса
Чтобы класс мог использовать range-based for нужно прописать базовый итератор. У него должны быть следующие методы:
1. `begin()` и `end()` - возвращающие что-то итерируемое (желательно итератор, но если элементы заполнены непрерывно в памяти, то сойдет и указатель). Плюс к этому надо прописать их константные версии `cbegin()` и `cend()`.
2. Оператор инкремента `++` для данного итератора.
3. Оператор `!=` для данного итератора.
4. Оператор раименования `*` для данного итератора.     

Ниже пример простого итератора для корректной работы range-base for для струкрутры LinkedListStack (из туториала Chili):
```cpp
/* Определение класса Итератора находится внутри класса LinkedListStack */
public:
  class Iterator
	{
	public:
		Iterator() = default;
		Iterator( Element* pElement )
			:
			pElement( pElement )
		{}
		Iterator& operator++()
		{
			pElement = pElement->pNext;
			return *this;
		}
		int& operator*() const  // Обратите внимание: раименование возращает не сам элемент,
		{                       // при этом (обнажая доступ к указателю на следующий элемент), 
			return pElement->val; // а на поле данных. Указатель на следующий элемент остается скрыт
		}
		bool operator!=( Iterator rhs ) const
		{
			return pElement != rhs.pElement;
		}
	private:
		Element* pElement = nullptr;
	};
	class ConstIterator           // Нужно всегда создавать 2 типа Итератора: обычный и const
	{
	public:
		ConstIterator() = default;
		ConstIterator( const Element* pElement )
			:
			pElement( pElement )
		{}
		ConstIterator& operator++()
		{
			pElement = pElement->pNext;
			return *this;
		}
		const int& operator*() const  // Отличие обычного и const итераторов тут:
		{                             // там возвращалась обычная ссылка, а тут const.
			return pElement->val;       // Таким образом мы запрещаем изменение этого поля
		}
		bool operator!=( ConstIterator rhs ) const
		{
			return pElement != rhs.pElement;
		}
	private:
		const Element* pElement = nullptr;
	};
```

- [Тут](https://gist.github.com/jeetsukumaran/307264) тут шаблон для универсального итератора, адаптированного к работе с библиотекой `<algorithm>`.
