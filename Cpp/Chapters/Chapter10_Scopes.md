# Chapter 10 Scopes

## Scopes (Зоны видимости)  
Переменные, объявленные внутри функции, существуют только в ней (это касатеся и main()). Поэтому при вызове функции, в нее передаются копии переменных/объектов.  
```cpp
int add(int a, int b) // здесь создаются переменные a и b функции add()
{
   return a + b;
} // здесь a и b функции add() выходят из области видимости и уничтожаются
 
int main()
{
   int a = 7; // здесь создаётся переменная a функции main()
   int b = 8; // здесь создаётся переменная b функции main()
   std::cout << add(a, b) << std::endl; // значения переменных a и b функции main() копируются в переменные a и b функции add()
   return 0;
} // здесь a и b функции main() выходят из области видимости и уничтожаются
```
### Локальные переменные
**Локальные переменные** имеют **автоматическую продолжительность (время жизни)**: они создаются (и инициализируются, если необходимо) в точке определения и уничтожаются при выходе из блока.
```cpp
int main() // внешний блок
{
    int m(4); // переменная m создаётся и инициализируется здесь 
    { // Начало вложенного блока 
        double k(5.0); // переменная k создаётся и инициализируется здесь
	/* m видная в этом блоке и может быть исаользована. 
	   Но если создать m тут, то будет использована "местная" переменная */
    } // k выходит из области видимости и уничтожается здесь 
    // Переменная k не может быть использована здесь, так как она уже уничтожена!
} // Переменная m выходит из области видимости и уничтожается здесь
```
### Сокрытие переменных    
Подобно тому, как переменные во внутреннем блоке скрывают переменные с теми же именами во внешнем блоке, локальные переменные скрывают глобальные переменные с одинаковыми именами внутри блока, в котором они определены. Однако, с помощью оператора разрешения области видимости (::), компилятору можно сообщить, какую версию переменной вы хотите использовать: глобальную или локальную. Например:
```cpp
int value(4); // глобальная переменная

int main()
{
    int value = 8; // эта переменная (локальная) скрывает значение глобальной переменной
    value++; // увеличивается локальная переменная value, не глобальная 
    ::value--; // уменьшается глобальная переменная value, не локальная 
    // ::value - вызов из глобального пространства имен
 
    std::cout << "Global value: " << ::value << "\n";   // выйдет "Global value: 3"
    std::cout << "Local value: " << value << "\n";	// выйдет "Local value: 9"
    return 0;
} // Локальная переменная уничтожается
```
Многие разработчики добавляют к глобальным переменным префикс **g_** (“g” от англ. “global”). Таким образом можно убить сразу двух зайцев: определить глобальные переменные и избежать конфликтов имён с локальными переменными.   

### Глобальные переменные   
Глобальные переменные включаются в *глобальное пространство имен*. Если вы хотите сделать глобальную переменную внутренней (которую можно использовать только внутри одного файла) — используйте ключевое слово `static`. Если вы хотите сделать глобальную переменную внешней (которую можно использовать в любом файле программы) — используйте ключевое слово `extern`:
```cpp
#include <iostream>
 
static int g_x; // g_x - это статическая глобальная переменная и её можно использовать только внутри этого файла
extern double g_y(9.8); // g_y - это внешняя глобальная переменная и её можно использовать и в других файлах программы

int main()
{
    return 0;
}
```
По умолчанию, неконстантные переменные, объявленные вне блока, считаются внешними. Однако константные переменные, объявленные вне блока, считаются внутренними. Чтобы использовать инициализированную внешнюю глобальную переменную (`extern`) в другом файле, нужно там ее объявить. Например:
```cpp
/* int g_m; 
int g_n(3); - были ранее инициализированны в другом файле. */
extern int g_m; // предварительное объявление g_m. Теперь g_m можно использовать в любом месте этого файла  
 
int main()
{
    extern int g_n; // предварительное объявление g_n. Теперь g_n можно использовать только внутри main()
 
    g_m = 4;
    std::cout << g_n; // должно вывести 3
 
    return 0;
}
```
**Глобальные переменные это зло!**. Если их использовать то только так: 1) `static` переменная доступ к которой сделан ф-цией:
```cpp
static double g_gravity (9.8); // ограничиваем доступ к переменной только на этот файл
 
double getGravity() // эта функция может быть экспортирована в другие файлы для доступа к глобальной переменной
{
    return g_gravity;
}
```
2) Не использовать их в теле ф-ции, а вызывать их как аргументы:
```cpp
// static double g_gravity (9.8); - глобальная переменная
// Передайте возвращаемое значение из getGravity() в параметр gravity, если хотите использовать глобальную переменную gravity
double instantVelocity(int time, double gravity)
{
    return gravity * time;
}
```

---
### Функции  
Функции имеют такие же свойства связи, что и переменные. По умолчанию они имеют внешнюю связь, которую можно сменить на внутреннюю с помощью ключевого слова `static`:
```cpp
// Эта функция определена как static и может быть использована только внутри этого файла
// Попытки доступа к ней через прототип функции будут безуспешными
static int add(int a, int b)
{
    return a + b;
}
```
Предварительные объявления функций не нуждаются в ключевом слове extern. Компилятор может определить сам (по телу функции): определяете ли вы функцию или пишите её прототип.

### Static
Используется в двух случаях:
1) Внутреннийе глобальные переменные (видимые во всем файле, объявленные в его начале). (По стандарту начинается с `g_` : `g_name`.)
2) **Статические переменные** (По стандарту начинается с `s_` : `s_name`.). Статическая переменная (или ещё «переменная со статической продолжительностью») сохраняет своё значение даже после выхода из блока, в котором она определена. То есть она создаётся (и инициализируется) только один раз, а затем сохраняется на протяжении выполнения всей программы. Например ф-ция для генерации ID:
	```cpp
	int generateID()
	{
	    static int s_itemID = 0;
	    return s_itemID++;
	}

	int main()
	{
		cout << generateID();		// вернет 0
		cout << generateID();		// вернет 1
		cout << generateID();		// вернет 2
		return 0;
	}
	```
	Прелесть в том, что s_itemID имеет локальную видимость видимость только внутри ф-ции  generateID, но не уничтожается при выходе (гораздо безопаснее чем глобальные переменные).    
При этом, **static переменная инициализуется только 1 раз при первом запуску ф-ции**. Далее строка соответсвующая инициализации просто пропускается. Например,
```cpp
int next (int start = 0) 
{
	static int k = start ;
	return k ++;
}

int main()
{
	std:: cout << next(10) << std::endl; // выведет 10 
	std:: cout << next(10) << std::endl; /* выведет 11, а не 20, тк static переменная k инициализуется 1 раз
						при первом вызове (next(10)). Далее при каждом последующем вызове
						строка инициализации пропускается и выполнятеся только return k++ */
	return 0;
}
```

## namespace 
**Пространство имен (namespace)** - это область видимости в программе. Нужно, чтобы избежать конфликтов имен. Например, в iostream ф-ция `cout` - она в *namespace std*, если не сообщить компилятору, что это std, то он будет считать cout неизвестной ф-цией (т.е. я могу сделать свой cout).   

**Глобальное пространство имен** все глобальные переменные и функции (не static) определятся в глобальное пространство имен (оно одно на всю программу). 

1. **оператор разрешения области видимости (::)**(`std::cout`) он определяет пространство имен только в данном случаи (т.е. далее я могу создавать свои ф-ции с именами из std).    
2. **using**. Ее видимость определятся блоком: если команда написана внутри ф-ции, то пространсво имен доступно только внутри нее. Если в начале файла, то на весь файл (это касается и *объявления* и *директив*).
	- **«объявление using»** `using std::cout;`- сообщает компилятору, что cout следует обрабатывать как std::cout. Позволяет подключить только одну ф-цнию/переменную из пространства имен.
	- **«директивы using»**. `using namespace std;` - команда, которая поделючает пространство имен (std) во всем файле (т.е. все ф-цнии/переменные, далее я не могу создавать свои ф-ции с именами из std).  

**Объявлять/добавлять новые элементы из разных файлов и мест внутри файла в один namespace** можно: 
```cpp
/* file add.h */
namespace DoMath
{
    // Функция add() является частью пространства имён DoMath
    int add(int x, int y)
    {
        return x + y;
    }
}

/* file substract.h */
namespace DoMath
{
    // Функция subtract() является частью пространства имён DoMath
    int subtract(int x, int y)
    {
        return x - y;
    }
}
```
В этом случаи из 2х разных файлов добавили ф-ции в один namespace. Их вызов можно сделать через `DoMath::add(5,4);` (незабыть #include оба файла).

**Псевдонимы (aliases) и вложенные пространства имён**   
Одни пространства имён могут быть вложены в другие пространства имён. Например:
```cpp
namespace Boo
{
    namespace Doo
    {
        const int g_x = 7;
    }
}
 
int main()
{
    std::cout << Boo::Doo::g_x;
    return 0;
}

/* аналогично используя псевдонимы (aliases) */

namespace Foo = Boo::Doo; // Foo теперь считается как Boo::Doo (псевдоним)
 
int main()
{
	std::cout << Foo::g_x; // это, на самом деле, Boo::Doo::g_x
	return 0;
}
```
