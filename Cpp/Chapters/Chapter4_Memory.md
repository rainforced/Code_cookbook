# Chapter 4 Memory

При выполнении инициализации переменной, ей автоматически присваивается свободный адрес памяти, и, любое значение, которое мы присваиваем переменной, сохраняется в этом адресе памяти. Нам не надо знать сам адрес, его связку с переменной знает компилятор. Мы просто ссылаемся на переменную через присвоенный ей идентификатор, а компилятор конвертирует это имя в соответствующий адрес памяти.    
**Оператор адреса (address-of operator)** (`&`) позволяет узнать, какой адрес памяти присвоен определённой переменной (в отличии от оператора побитового И (бинарного), это унарный опертор). **Оператор разыменования (dereference operator)** (`*`) позволяет получить значение по указанному адресу (в отличии от оператора умножения (бинарного), это унарный опертор).
```cpp
int a = 7;
std::cout << a << '\n'; // выводим значение переменной a
std::cout << &a << '\n'; // выводим адрес памяти переменной a
std::cout << *&a << '\n'; /// выводим значение ячейки памяти переменной a

/*  Вывод: 7 \n  0046FCF0  \n  7  */
```

## Pointers
**Указатель (pointer)** - это переменная, значением которой является адрес (ячейка) памяти. Указатели объявляются точно так же, как и обычные переменные, только со звёздочкой между типом данных и идентификатором. Тип указателя должен соответствовать типу переменной, на которую он указывает:
```cpp
int *iPtr; // указатель на значение типа int
double *dPtr; // указатель на значение типа double
 
int* iPtr3; // корректный синтаксис (допустимый, но не желателен)
int * iPtr4; // корректный синтаксис (не делайте так)

int *iPtr5, *iPtr6; // объявляем два указателя для переменных типа int
int* iPtr3, iPtr4; // iPtr3 - это указатель на значение типа int, а iPtr4 - это обычная переменная типа int!
```
Поскольку указатели содержат только адреса, то при присваивании указателю значения — это значение должно быть адресом:
```cpp
int value = 5;
int *ptr = &value; // инициализируем ptr адресом значения переменной
 
std::cout << &value << '\n'; 	// выводим адрес значения переменной value
std::cout << ptr << '\n'; 	// выводим адрес, который хранит ptr
std::cout << *ptr << std::endl; // разыменовываем ptr (получаем значение на которое указывает ptr)

/* Вывод: 003AFCD4 \n 003AFCD4 (один и тот же адрес) /n 5 (разыменовали ptr)  */
```
C++ также не позволит вам напрямую присваивать адреса памяти указателю: `double *dPtr = 0x0012FF7C; // не ок: рассматривается как присваивание целочисленного литерала`.      

**Указатель * и &**
- Оператор адреса (&) не возвращает адрес своего операнда в качестве литерала. Вместо этого он возвращает указатель, содержащий адрес операнда (и того же типа, что и операнд). 
- `ptr` — это то же самое, что и `&value`;
- `*ptr` обрабатывается так же, как и `value`.

### Размер
Usually the size is equal to *the word size* of the underlying processor architecture, and the size of total addressable memory (including virtual memory). So, for a 32bit computer, the pointer size can be 4 bytes; 64bit computers can have 8 bytes. 

### Scaling (Арифметика указателей)
Если `ptr` указывает на целое число, то `ptr + 1` является адресом следующего целочисленного значения в памяти после `ptr`. `ptr - 1` — это адрес предыдущего целочисленного значения (перед `ptr`). Обратите внимание, `ptr + 1` не возвращает *следующий любой адрес* памяти, который находится сразу после `ptr`, но он возвращает адрес памяти следующего объекта, тип которого совпадает с типом значения, на которое указывает `ptr`. Если `ptr` указывает на адрес памяти целочисленного значения (размер которого 4 байта), то `ptr + 3` будет возвращать адрес памяти 3го целочисленного значения после `ptr`. Если `ptr` указывает на адрес памяти значения типа char, то `ptr + 3` будет возвращать адрес памяти третьего значения типа char после `ptr`. На этом основана индексация массивов (подробнее см. в теме про индексацию массивов).     

Пример заполнения массива используя арифметику указателей (цикл по последовательным ячейкам памяти):
```cpp
constexpr int size = 5;
int m[size] = {};
//	    &m[0]	&m[size]
for(int *p = m ; p < i + size; p++)
	*p = (p-m);		// (p-m) -это разница между номером ячейки и началом массива; массив заполнится 0-9  
```

Пусть, например, есть указатель `int *ptr`. Если сделать инкремент `ptr++` то сдивг будет на один int (или 4 байта), те если ptr указавает на ячейку 0x0031f8a4, то ptr++ будет указывать на ячейку 0x0031f8a8 (сдвиг на 4 байта).

### null pointer
Если просто объявить указатель без присвоения ему данных, то ячейка памяти будет забита мусором. С целью явно показать, что указатель не указывает ни на что было введен **null pointer**:
```cpp
int *ptr(0);  // ptr теперь нулевой указатель
 
int *ptr1; // ptr1 не инициализирован
ptr1 = 0; // ptr1 теперь нулевой указатель

//C++ 11 и страше (рекомендован т.к. способы выше могут иметь конфликт: 0 - это int или null pointer)
int *ptr = nullptr; // примечание: ptr по-прежнему остаётся указателем типа int, просто со значением null (0)
```
Null pointer можно использовать в логических ветвелениях:
```cpp
double *ptr(0);
if (ptr)
	std::cout << "ptr is pointing to a double value.";
else
	std::cout << "ptr is a null pointer.";
```
Если нужно написать функцию, которая принимает ТОЛЬКО аргумент null pointer, то надо использовать `std::nullptr_t` (#include <cstddef>)

```cpp
void doAnything(std::nullptr_t ptr)
{
    std::cout << "in doAnything()\n";
}
 
int main()
{
    doAnything(nullptr); // вызов функции doAnything с аргументом типа std::nullptr_t (и только)
}
```

### const pointers and pointers to const
**"слово const делает неизменяемым тип слева от него"**    


1. **Указатель на константную переменную**. В этом случаи случаии указатель должен быть также константным. Иначе можно было бы присвоить новое значение переменной путем разименования указателя:
```cpp
const int value = 7;		// value - это константа
int *ptr = &value; 		// ошибка компиляции: невозможно конвертировать const int* в int*
*ptr = 8; 			// иначе могли бы изменить значение value на 8

const int value_two = 7;
const int *ptr = &value_two; 	// здесь всё ок: ptr - это неконстантный указатель, который указывает на "const int"
*ptr = 8;		 	// нельзя, мы не можем изменить константное значение
```
Однако, указатель на константное значение может указывать на неконстантную переменную. В этом случаии при вызове переменной через указатель она будет рассматриваться как константа. При вызове переменной через собственное имя она будет рассматриваться как  неконстантая.
```cpp
int value = 7;
const int *ptr = &value; // ptr указывает на "const int"
value = 8; 		 // переменная value уже не константа, если к ней получают доступ через неконстантный идентификатор
*ptr = 8;		 // ptr обрабатывает value как константу, поэтому изменение значения переменной value через ptr не допускается
```
Указателю на константное значение, который сам при этом не является константным (он просто указывает на константное значение), можно присвоить и другое значение:

```cpp
int value1 = 7;
const int *ptr = &value1; // ptr указывает на const int
 
int value2 = 8;
ptr = &value2;		 // хорошо, ptr теперь указывает на другой const int
```
**Т.е. указатель может быть изменен, но не переменная (точнее не через указатель)**

2. **Константный указатель**. В этом случаи указатель инициализируется только один раз и послу этого не может быть изменен (т.е. не может указавыть на другую переменную), но сама переменная - не константа, поэтому она может быть изменена через разименование:
```cpp
/* не может указавыть на другую переменную */
int value1 = 7;
int value2 = 8;
 
int * const ptr = &value1; 	// ок: константный указатель инициализирован адресом value1
ptr = &value2;			// не ок: после инициализации константный указатель не может быть изменён

/* переменная может быть изменена через разименование */
int value = 7;
int *const ptr = &value; // ptr всегда будет указывать на value
*ptr = 8; // ок, так как ptr указывает на тип данных (неконстантный int)
```
**Т.е. указатель не может быть изменен, но переменная может** 

3. **Констатный указатель на константную переменную**
```cpp
int value = 7;
const int *const ptr = &value;
```
**Ни указатель, ни переменная не могут быть изменены**

### Оператор доступа к членам класса через указатель (->)
При создании класса, можно присвоить ему указатель и получать доступ к членам через указатель (через заименование). При этом в C++ есть оператор доступа к члену класса через указатель (`->`), что делает чтение/написание удобнее:
```cpp
struct Man
{
    int weight;
    double height;
};
Man man;
 
// Доступ к члену осуществляется через указатель на переменную структуры Man
Man *ptr = &man;
//следующие вызовы идентичны
(*ptr).weight = 60;
ptr->weight = 60;
```
**Итого, **`foo->bar()`** то же самое, что **`(*foo).bar()`.

### Указатель типа void
`void *ptr` - может быть указателем на любой тип данных. Проблема в том, что он не будет знать ни тип данных своего объекта, ни его размер. Поэтому его нельзя разименовать (надо знать тип данных) и с ними нельзя выполнять арифметику (надо знать размер объекта).

### Указатель на указатель
Можно создать указатель на указатель, тогда он будет содержать адрес, где хранится адрес вложенного указателя. При его разименовании мы получим адрес вложенного указателя. При двоином раименовании мы получим значение, на которое указывает вложенный указатель: 
```cpp
int value = 7;
 
int *ptr = &value;
std::cout << *ptr << std::endl; // разыменовываем указатель, чтобы получить значение типа int 
// вывод: 7
int **ptrptr = &ptr;
std::cout << **ptrptr << std::endl;	
// вывод: 7
```
Нужно это в основном для создания массива указателей, а не его основе можно делать 2х мерный динамический массив (см. в разделе про динамические массивы).    

Можно создавать и более глубокое вложение: указатель на указатель на указатель и тд. Тройное вложение можно использовать для трех-мерных динамических массивов.

### Указатель для передачи массива в ф-цию
При передаче массива в ф-цию, массив распадается в указатель на первый элемент (т.е. до этого, массив знал о своем размере и мог проверить, выходим ли мы за его границу или нет, теперь же у нас есть прсото указатель на первый элемент и неизвестно, где в памяти кончается массив и начинаются другие объекты). Поэтому в ф-цию обычно передают массив (т.е. его указатель на первый элемент) и его размер. Однако большиство алгоритмов стандартной библиотеки реализованы через передачу двух указателей: на первый элемент и на место в памяти сразу после последнего элемента (т.е., если у нас есть массив `array[10]`, то 1й указатель - это просто `array` (автоматически указывает на первый элемент), а 2й - это `(array + 10)` (т.е. тут работает стандартная арифметика указателей: 1й указатель + размер массива). Т.к. счет в мессиве начинается с 0, то прибавив 10 (а не 9) мы попадем как раз на следующую после последнего элемента ячейку памяти. Это нужно, чтобы мы могли передавать в ф-цию пустой массив (чтобы не писать исключения в этом случаи). Например, ф-ция которая ищет максимальный элемент массива и возвращает указатель на него:
```cpp
int* array_max(int *m, int *p)
{
    int *max=m;
    for(;m != p; m++)
    {
        if(*m > *max)
            max = m;
    }
    return max;
}

int main()
{
    int array[5] = {22,1,13,444,5};
    int *max_arr = array_max(array, array + 5);
    std::cout << *max_arr;			//выведет 444;
    return 0;
}
```
Можно так же усовершенствовать программу, чтобы она возвращала не указатель, bool значение (true - если массив не пустой, false - если массива пустой). А указатель на максимальный элемент будет передаваться в качестве одного из аргументов ф-ции. 
```cpp
bool array_max(int* m, int* p, int* max)
{
	if (m == p)
		return false;
	else
	{
		*max = *m;
		for (; m != p; m++)
		{
			if (*m > * max)
				*max = *m;
		}
		return true;
	}
}

int main()
{
	int array[5] = { 22,1,13,444,5 };
	int max_arr = 0;
	if (array_max(array, array + 5, &max_arr))
		std::cout << max_arr;
	return 0;
}
```

## References (ссылки)
**Ссылка** — это тип переменной в C++, который работает как псевдоним другого объекта или значения. По сути, это тот же указатель, который неявно разыменовывается при доступе к значению, на которое он указывает (под капотом ссылки реализованы с помощью указателей. 

**Иничиализация** 
Ссылки должны быть инициализированы один раз и с l-value. После присвоение, ссылке нельзя присвоить новый объект (поэтому теряется возможноть потери, как у не NULL указателя):
```cpp
int a = 7;
int &ref1 = a; // ок: a - это неконстантное l-value
 
const int b = 8;
int &ref2 = b; // не ок: b - это константное l-value (для этого нужна константная ссылка: `const int &ref = b`) 
 
int &ref3 = 4; // не ок: 4 - это r-value
```
Ссылке нельзя присвоить новую переменную:
```cpp
int value1 = 7;
int value2 = 8;
 
int &ref = value1; 	// ок: ref - теперь псевдоним для value1
ref = value2; 		/* присваиваем 8 (значение переменной value2) переменной value1. Здесь НЕ изменяется объект, на который ссылается ссылка! Теперь value1 = 8 */
```

**Ссылки использутются в случаих:**
- Как псевдонимы 
	```cpp
	int value = 7; 				// обычная переменная
	int &ref = value; 			// ссылка на переменную value

	/* Объект на который ссылаются и ссылка ведут себя одинаково */
	value = 8;			 	// value теперь 8
	ref = 9;				// value теперь 9

	std::cout << value << std::endl; 	// выведется 9
	++ref;
	std::cout << value << std::endl; 	// выведется 10

	std::cout << &value; 			// выведется 0035FE58
	std::cout << &ref;			// выведется 0035FE58
	```
	Дургой пример, это псевдоним для дилинных названий при доступе к членам классов:
	```cpp
	int &ref = other.something.value1; 	//член value1, подкласса something, класса other
	/* ref теперь может использоваться вместо other.something.value1. Слудующие действия идентичны */
	other.something.value1 = 7;
	ref = 7;
	```
- Как параметр ф-ции. Все аналогично передаче по указателю: `void changeN(int &ref)`
	
### Константные ссылки
**Ссылки на константы** или **константные ссылки** могут быть инициализированы неконстантными l-values, константными l-values и r-values (в отличии от неконстантных). 
```cpp
int a = 7;
const int &ref1 = a; // ок: a - это неконстантное l-value
 
const int b = 9;
const int &ref2 = b; // ок: b - это константное l-value
 
const int &ref3 = 5; // ок: 5 - это r-value
```
Аналогично указателям на констатные переменные, константной ссылке можно присвоить неконстантную переменную. Эту переменную можно будет менять через ее собственное имя, но не через ссылку:
```cpp
int value = 7;
const int &ref = value; // создаём константную ссылку на переменную value
 
value = 8; // ок: value - это не константа
ref = 9; // нельзя: ref - это константа
```
Главная польза от них, это передача аргумента в ф-цию как константной ссылки, тем самым запретить этой ф-ции ее менять (см. главу про ф-ции, раздел аргументы).
	
## Dymanic memory allocation 
В C++ существует 3 типа **выделения памяти (memory allocation)**:
1. **Статическое выделение памяти** выполняется для статических и глобальных переменных. Память выделяется один раз, при запуске программы, и сохраняется на протяжении работы всей программы.
2. **Автоматическое выделение памяти** выполняется для параметров функции и локальных переменных. Память выделяется при входе в блок, в котором находятся эти переменные, и удаляется при выходе из него.    
В обих случаях (1 и 2) память выделяется из **стека (stack)**. Его рамер зависит от компилятора, но всегда очень мал (порядка 1-2 МБ).
3. **Динамическое выделение памяти** - это способ запроса памяти из операционной системы запущенными программами по надобности. Эта память не выделяется из ограниченной памяти стека программы, а из гораздо большего хранилища, управляемого операционной системой — **кучи** (порядка n-Гб). Эта память относится к сегменту данных.    

Когда программа запущена ОС выделяет ей какой-то участок памяти. Некоторая часть используется на обработку ф-ций и пд, какая-то часть идет на переменные и прочее (т.е. 1й и 2й варианты). Однако большая часть выделенной памяти висит без использования в ожидании запроса от программы на динамическое выделение памяти. Так, объявляя динамическую переменную, мы записываем ее в кучу, и не тратим стек (и без того маленький).    

Создадим переменную выделяя динамическую память. Для этого используется оператор `new`, он возвращает ссылку (поэтому ее надо присвоить какой-нибудь переменной). Присвоение осуществляется через опертор разименования ссылки (dereference: `*`ptr):
```cpp
/* Динмаическое выделение памяти и присвоение значения этой ячейке */
int *ptr = new int; // динамически выделяем целочисленную переменную и присваиваем её адрес ptr, чтобы потом иметь доступ к ней
*ptr = 8; // присваиваем значение 8 только что выделенной памяти
/* Также можно делать прямую и uniform (C++11 и выше) инициализацию */
int *ptr1 = new int (7); // используем прямую инициализацию
int *ptr2 = new int { 8 }; // используем uniform инициализацию (в C++11 и выше)
```
Динамическое выделение памяти не обладает свойствами автоматического, такими как автоматическое очищение и удаление переменных после выхода из блока. Надо самостоятельно *удалить* (т.е. вернуть выделенную память назад ОС) и *очистить указатель* (т.к. даже после возвращения выделенной памяти, указатель продолжить указывать на ее адрес. Может получиться, что ОС уже выделила эту память другому процессу, а указать все еще указывает - это **висячий указатель**). 
```cpp
delete ptr; // возвращаем память обратно в операционную систему. ptr теперь висячий указатель
ptr = 0; // (или ptr = nullptr;) ptr теперь уже nullptr (не сможет указать на этот участок память)
```
Этого можно не делать, если сразу после инструкции `delete ptr;` блок заканчиватся, тогда `prt` будет удален автоматически. 

### Когда следует выделять память в куче (динамически)
1. Для массивов неизвествных размеров (динамических)
2. Для объектов, которые занимают слишком много места (например, огромный массив).
3. Т.к. локальные переменные уничтожаются при выходе из ф-ции, то можно выделить место под переменную в куче и она будет незвисима от стека, соответсвенно не будет унижтожаться. (**не путать с глобальными и статическими (static) переменными** - для них выделяется свой раздел памяти **bss**). 

### Placement new
Взято [отсюда](https://ru.wikipedia.org/wiki/New_(C%2B%2B)#Placement_new%EF%BB%BF).     
Существует особая форма оператора new, называемая Placement new. Данный оператор не выделяет память, а получает своим аргументом адрес на уже выделенную каким-либо образом память (например, на стеке или через `malloc())`. Происходит размещение (инициализация) объекта путём вызова конструктора, и объект создается в памяти по указанному адресу. Часто такой метод применяют, когда у класса нет конструктора по умолчанию и при этом нужно создать массив объектов. Пример вызова выглядит следующим образом:
```cpp
  class A
  {
  public:
      A(int x){}
      ~A(){}
  };
  
  const int n = 50;
  A* placementMemory = static_cast<A*>(operator new[] (n * sizeof(A)));
  for (int i = 0; i < n; i++)
  {
      new (placementMemory + i) A(rand()); //здесь память для объекта не выделяется, но инициализируется
  }
  //!!деинициализация памяти
  for (int i = 0; i < n; i++)
  {
      placementMemory[i].~A();
  }
  operator delete[] (placementMemory);
```

### исключение *bad_alloc*
Может получится так, что у ОС не будет памяти для выделения, и тогда оператор `new` вместо адреса вызовет исключение `bad alloc`, и все покрашится. С этой целью есть специальная константа: `(std::nothrow)` - если ее указать между `new` и типом данных, то в случаи `bad alloc` оператор `new` вернет `nullptr`. Однако даже так, если программа пойдет дальше использовать этот указатель, то все может покрашится. Чтобы этого избежать, надо делать проверку того, что память выделилась:
```cpp
int *value = new (std::nothrow) int; /* запрос на выделение динамической памяти для целочисленного значения
вернет nullptr, если не сможет выделить память */
if (!value) // обрабатываем случай, когда new возвращает null (т.е. память не выделяется)
{
    	// Обработка этого случая
	std::cout << "Could not allocate memory";
}
else
{
	// do your beautiful code
}
```
### Утечка памяти (memory leak)
Динамически выделенная память не имеет области видимости, т.е. она остаётся выделенной до тех пор, пока не будет явно освобождена или пока ваша программа не завершит своё выполнение (и операционная система очистит все буфера памяти самостоятельно). Однако указатели, используемые для хранения динамически выделенных адресов памяти, следуют правилам области видимости обычных переменных. Когда ваша программа теряет адрес (т.е. "теряет" указатель) некоторой динамически выделенной части памяти (например, переменной или массива), прежде чем вернуть её обратно в операционную систему - это **утечка памяти (memory leak)**. Подобное может произойти например в следующих случаях:
```cpp
// указатель использовали для другого случая, напр., переменной */
int value = 7;
int *ptr = new int; // выделяем память
ptr = &value; // старый адрес утерян - произойдёт утечка памяти
// дважды выделили память, но использовали только один указатель
int value = 7;
int *ptr = new int; // выделяем память
ptr = &value; // старый адрес утерян - произойдёт утечка памяти
```

### Тест на memory leak
Утилита, помогающая выявить утечки. 
```cpp
/*необходимые библеотеки*/
#define _CRTDBG_MAP_ALLOC  
#include <stdlib.h>  
#include <crtdbg.h>  

/*регулирует куда будут выводиться предупреждения, ошибки и тд*/
_CrtSetReportMode( _CRT_WARN,_CRTDBG_MODE_FILE );
_CrtSetReportFile( _CRT_WARN,_CRTDBG_FILE_STDERR );
_CrtSetReportMode( _CRT_ERROR,_CRTDBG_MODE_FILE );
_CrtSetReportFile( _CRT_ERROR,_CRTDBG_FILE_STDERR );
_CrtSetReportMode( _CRT_ASSERT,_CRTDBG_MODE_FILE );
_CrtSetReportFile( _CRT_ASSERT,_CRTDBG_FILE_STDERR );

//TODO место для вашей программы

/*сама ф-ция проверки. Нужно засуть ее в критических местах программы (например, в конце)*/
_CrtDumpMemoryLeaks();
```
