# Chapter 8 Functions
## Термины
**Параметр функции (parameters)** (или ещё «формальный параметр») — это переменная, объявленная в объявлении функции:
```cpp
void boo(int x); // объявление (прототип функции). x - это параметр
 
void boo(int x) // определение (также объявление). x - это параметр
{
}
```
**Аргумент (arguments)** (или ещё «фактический параметр») — это значение, которое передает в функцию вызывающий объект (caller):
```cpp
boo(7); // 7 - это аргумент, который передаётся в параметр x
boo(y+1); // выражение y+1 - это аргумент, который передаётся в параметр x
```
Когда функция вызывается, все параметры функции создаются как переменные, а значения аргументов копируются в параметры.     
**Передача аргумента по значению (arguments by value)**. Когда аргумент передаётся по значению, то его значение копируется в параметр функции. По умолчанию аргументы в C++ передаются по значению.

## Общий синтаксис
```cpp
    int lcd (int a, int b){
	if (a%b == 0) return b; 	// возврат, когда мы довольны (нашли b)
	else lcd(b, a%b);		// вызов рекурсией
``` 

### ``` int main() ```  
Почему нужно возвращать значения обратно в операционную систему? Дело в том, что возвращаемое значение функции main() является кодом состояния, который сообщает операционной системе о том, успешно ли было выполнение программы или нет. Обычно, возвращаемое значение 0 (ноль) означает что, всё прошло успешно, тогда как любое другое значение означает неудачу/ошибку.  
Обратите внимание, по стандартам C++ функция main() должна возвращать целочисленное значение. Однако, если вы не укажете return в конце функции main(), то компилятор возвратит 0 автоматически, если никаких ошибок не будет. Но рекомендуется указывать return в конце main() и использовать тип возврата int для функции main().

#### Передача в main() аргументов из командной строки
```cpp
int main(int argc, char *argv[])
//или то же самое 
int main(int argc, char** argv)
```
- `int argc` («argument count» = «количество аргументов») -  это целочисленный параметр, содержащий количество аргументов, переданных в программу. argc всегда будет как минимум 1, так как первым аргументом всегда является имя самой программы. Каждый аргумент командной строки, который предоставляет пользователь, заставит argc увеличиться на 1.
- `char *argv[]` («argument values» = «значения аргументов») — это место, где хранятся фактические значения аргументов. Это всего лишь массив строк C-style. Длина этого массива — argc. Что бы не было передано в main (числа, строки, файлы и тд) оно сохраняется в массив argv в отдельную ячейку в виде C-style строки. Так что ее дальнейшая обработка лежит на плечах программиста.

```cpp
int main(int argc, char *argv[])
{
    std::cout << "There are " << argc << " arguments:\n";
 
    // Перебираем каждый аргумент и выводим его порядковый номер и значение
    for (int count=0; count < argc; ++count)
        std::cout << count << " " << argv[count] << '\n';
 
    return 0;
}
```
##### Командная строка
Чтобы передать в программу какие-то параметры, их надо перечислить через пробел следом за path к программе:
`C:\>MyProgram 444 SomeContent.txt SomeOtherContent.txt` - тут запустится программа "MyProgram" (лежащая прямно на C:\) с параметрами 444, SomeContent.txt и SomeOtherContent.txt. Таким образом для `main(int argc, char *argv[])`: argc = 4, {argv[0] = "C:\>MyProgram", argv[1] = "444", argv[2] = "SomeContent.txt", argv[3] = "SomeOtherContent.txt"}.

### Явно указываеся возвращаемый тип: `void` (нельзя в main()), `int`, `vector<int>`, etc: 
```cpp
void returnNothing()
{
    std::cout << "Hi!" << std::endl;
    // эта функция не возвращает никакого значения, поэтому оператор return здесь не нужен
}
 
int main()
{
    returnNothing(); // функция returnNothing() вызывается, но обратно в main() ничего не возвращается
 
    std::cout << returnNothing(); // ошибка: эта строчка не скомпилируется. Вам нужно будет её закомментировать
    return 0;
}
```

## Прототип функции  
Перед любым вызовом функция должна быть **определена** (т.е. описана). Если по какой-то причине ее нельзя определить раньше вызова, то сначала ставим ее **прототип**:  
```cpp
int add(int x, int y); // предварительное объявление функции add() (используется её прототип)
```

## **Аргументы**
### Передача по значению
- При вызове функции, все её параметры создаются как локальные переменные, а значение каждого из аргументов копируется в соответствующий параметр (локальную переменную). Этот процесс называется *передачей по значению*. При вызове в функцию передается копия передаваемой переменной, так что ее нельзя изменить внутри функции:
```cpp
    int funct(int a)
    {
    a = 100100;       //меняет только локальную копию, но не сам x
    return a;
    }
    
    int main()
    {
    int x = 10;
    funct(x);         //сюда передается копия x, не сам x
    cout << x;        //покажет x = 10 
    }
```
Рекомендуюется только при передаче **фундаментальных типов данных и перечислителей**, когда предполагается, что функция не должна изменять аргумент.

### Передача аргумента по ссылке
`int funct(int& a)` вместо копирования перемнной a в аргументы ф-ции, ей передается ссылка (псевдоним) на сам аргумент. Таким образом можно менять этот аргумент внутри блока ф-ции и эти изменения сохранятся после выхода из него. Тк работа с ссылками ничем не отличается от работы с переменной (синтаксически), то все действия внутри ф-ции будут производиться аналогично действиям над переменной.
```cpp
void addOne(int &x) // x - это переменная-ссылка
{
    x = x + 1;
} // x (ссылка) уничтожается здесь, но сохраненная в ней переменная изменилась
//  вызов ф-ции происходит так же как и вызов "по значению"
int x = 5;
addOne(x)
```

#### Константные ссылки
`void boo(const int &y) `    
Неконстантные ссылки могут ссылаться только на неконстантные l-values (например, на неконстантные переменные), поэтому параметр-ссылка не может принять аргумент, который является константным l-value или r-value (например, литералом или результатом выражения). Однако, константные ссылки могу принять *любые данные* (включая l-values, константные l-values и r-values). Также, они позволяют удостовериться, что значение аргумента не будет измененно.     

#### Возвращаемое значение ф-ции как аргумент другой ф-ции
`void funct_one(funct_two())` - в этом случаии возвращаемое значение ф-ции funct_two передается внешней ф-ции funct_one в качетсве аргумента. Это возможно только в случаи, если внешняя ф-ция принимает только константную ссылку в качестве аргумента (т.е. `void funct_one(const int& a)`.


Передача по ссылке рекомендуется при: 1) **передаче структур или классов** (используйте const, если нужно только для чтения); 2) когда нужно, чтобы функция изменяла значение аргумента; 3) При вызове ф-ции, когда ее аргумент является возвращаемым значением другой ф-ции (напр., `void funct_one(funct_two())`).


### Передача аргумента по адресу (указателю)
В этом случаии ф-ция принимает указатель, а аргумент должен быть адресом (т.е. его на него надо подействовать оператором `&` (address-of)). Внутри ф-ции параметр обрабатывается как указатель (он и есть указатель):
```cpp
void boo(int *ptr)				// принимает указатель
{
    *ptr = 7;					// обрабатывается как указатель 
}
 
int main()
{
    int value = 4;
 
    std::cout << "value = " << value << '\n';	// выведет 4
    boo(&value);				// передаем адрес переменной value
    std::cout << "value = " << value << '\n';	// выведет 7
}
```

- При передаче аргумента по адресу в переменную-параметр функции копируется адрес из аргумента. В этот момент параметр функции и аргумент указывают на одно и то же значение.
- Если параметр функции затем разыменовать для изменения исходного значения, то это приведёт к изменению значения, на которое указывает аргумент, поскольку параметр функции и аргумент указывают на одно и то же значение!
- Eсли параметру функции присвоить другой адрес, то это никак не повлияет на аргумент, поскольку параметр функции является копией, а изменение копии не приводит к изменению оригинала. После изменения адреса параметра функции, параметр функции и аргумент будут указывать на разные значения, поэтому разыменование параметра и дальнейшее его изменение никак не повлияет на значение, на которое указывает аргумент. Например,
```cpp
void test(int *ptr)
{   		// пока что ptr указывает на переменную a
    int b = 10;
    ptr = &b;	// теперь ptr указывает на переменную b 
    *ptr = 17;	// изменение *ptr поменяет b, а не a, тк теперь это указатель на b
}

int main()
{
    int a = 5;
    test(&a);
    cout<< a;	// выведет 5
}
```

### Передача массива в качестве аргумента
Обычные (не динамические) массивы автоматически передаются по указателю (т.е. **распадаются** в указатель) (напр., `int funct(int array[])` тоже самое, что и `int fucnt(int* array)`). Внутри ф-ции параметр (те массив) синтаксически ведет себя как массив, но обрабатывается как указатель. Однако, при распадании в указатель массив меняет тип данных с `int[4]` (тип данных массива, который знает адрес первого элемента и свою длинну) на `int *` (просто адрес первого элемента). В связи с этим, для работы с массивом полезно передать в ф-цию длинну массива:
```cpp
void changeArray(int *some_array, int array_size)
{
    if (array_size > 3){
        std::cout << some_array << std::endl;		// выведет: 0x6afee0 (тип: `Pi` - т.е. pointer int)
        std::cout << *some_array << std::endl;		// выведет: 5
        std::cout << some_array[0] << std::endl;	// выведет: 5

        some_array[2] = 2000;
    }
}

int main()
{
int array[4] = { 5, 8, 6, 4 };
    std::cout << "Element 3: " << array[2]<< std::endl;	// выведет: 6
    changeArray(array, 4);
    std::cout << "Element 3: " << array[2];		// выведет: 2000
}
```

Т.к. при передаче массива он разименновываетс в указатель, то внутри ф-ции `my_array` - это просто указатель. Для него нельзя использовать foreach loop, т.к. указатель, а не контейнер, и для него неизвестен размер.

```cpp
void array_killa(int my_array[])
{
	for (int a : my_array)		// не будет компилироваться!
		std::cout << a << std::endl;
}

int main()
{
	int my_array[] = { 1,2,3,4,5,6,7,8,9 };
	array_killa(my_array);
}

```
Передача по адресу рекомендуется при: **передаче обычных массивов** (если нет никаких проблем с тем, что массивы распадаются в указатели при передаче).

#### Передача массива по ссылке
Тк как передача по ссылке во многом аналогична передаче по адресу, то массив можно передать и по ссылке: `(&a)[]` (важно соблисти скобки, иначе это будет массив ссылок, а не сслыка на массив). В этом случаи, можно указать размер передоваемого массива (те определить его тип), тогда ф-ция сама проверит размерность: 
```cpp
void foo(int (&a)[3]) { /* ... */ }
int a[1] = {};
foo(a);
//компилятор выведет ошибку
//error: invalid initialization of reference of type ‘int (&)[3]’ from expression of type ‘int [1]’
```

### Это всего лишь копия
Когда указатель передаётся в функцию по адресу, то значение этого указателя (адрес, на который он указывает) копируется из аргумента в параметр функции. Другими словами, указатель передаётся по значению! Если изменить значение параметра функции, то изменится только копия, исходный указатель-аргумент не будет изменён. Например,
```cpp
void setToNull(int *tempPtr)
{			/* Мы передали сюда адрес x (те указатель ptr) и скоприровали в указатель tempPtr. 
			Теперь на адрес x указывают 2 указателя: ptr и tempPtr */
    &tempPtr  = 100; 	// теперь x=100, тк мы разименовали указатель и изменили значение
    tempPtr = nullptr;  /* теперь tempPtr указаывает на 0, но адрес x от этого не изметинтся 
    			т.к. tempPtr - это копия адреса и все действия тут делаются над копией */
} 			// копия tempPtr уничтожена
int x =5;
int *ptr = &x;
setToNull(ptr); // передали адрес переменной x
```
Если надо, чтобы указатель был передан не по значению, как в примере выше, то надо передать указатель по ссылке (т.е. `void setToNull(int *&tempPtr)`). В этом случаии в ф-цию передасться сам указатель (адрес), а не его копия.

### read only (const) pass
Часто имеет смысл передать по ссылке объект (чтобы не копировать его), но при этом надо убедится что он не будет изменен (например случайно). В этом случаии надо передавать объект с префиксом `const` (те сслыка на константный объект). Если объект попытаются изменить внутри ф-ции, то произойдет ошибка компиляции. 
```cpp
void funct(const int array)			// передача по указателю на const
// this_dude is an innstance of Dude class
void funct_two(const Dude& this_dude)		// передача по const ссылке
```
В случаи class member functions передача константной ссылки аналогична следующей записи `type funct_name() const`:
```cpp
void funct_two(Dude& this_dude) const
// то же самое, что и 
void funct_two(const Dude& this_dude)
```
**Правило:** При передаче аргументов по ссылке (в случаии массивов, указателю) всегда используйте сслыки на константные объекты, если вам не нужно, чтобы функция изменяла значения аргументов.    

### Страшная правда об аргументах ф-ций
Ссылки на самом деле реализуются с помощью указателей. Это означает, что передача по ссылке является просто передачей по адресу. И чуть выше мы говорили, что передача по адресу на самом деле является передачей адреса по значению (а передача адреса по ссылке - это передача адреса по адресу (sick!) )! Из этого следует, что C++ действительно передает всё по значению!

### Default arguments (параметры по умолчанию)
```cpp
void printValues(int a=10, int b=11, int c=12)
{
    std::cout << "Values: " << a << " " << b << " " << c << '\n';
}
// все вызовы ок
printValues(3, 4, 5);	// выведет: 3, 4, 5
printValues(3, 4);	// выведет: 3, 4, 12
printValues(3);		// выведет: 3, 11, 12
printValues();		// выведет: 10, 11, 12
```
**Правила**     
1. Все параметры по умолчанию в прототипе или в определении функции должны находиться справа:
```cpp
// не ок
void printValue(int a=5, int b); 
// ок
void printValue(int a, int b=5);
```
2. Если имеется более одного параметра по умолчанию, то самым левым параметром по умолчанию должен быть тот, который с наибольшей вероятностью (среди всех остальных параметров) будет явно переопределён пользователем.

## Возвращаемое значение 
Тут все очень похоже на передачу аргументов: если возврат по 1) значению, 2) адресу и 3) ссылке. Ключевым моментом при выборе типа являются: 1) время и scope жизни и 2) тип возвращаемого значения.

### 1. По значению
В этом случаии ф-ция передает в caller (т.е. return из ф-ции) копию возвращаемого объекта. Тут все просто, потерять значение невозможно, однако копировать большие объекты трудоемко и не всегда хочется копировать.    

#### Когда использовать?
- при возврате переменных, которые были **объявлены внутри** функции;
- при возврате аргументов функции, которые были **переданы в функцию по значению**.  

#### Когда НЕ использовать? 
- при возврате **стандартных массивов** или **указателей** (используйте возврат по адресу);
- при возврате **больших структур или классов** (используйте возврат по ссылке).

### 2. По адресу
Тут может возникнуть проблема: если объект был создан внутри ф-ции, то при выходе из нее он уничтожется. Поэтому, если вернуть адрес этого объекта, то после выхода из ф-ции (и уничтожения переменной) этот адрес будет указвать на пустую/мусорнyю/перезаписанную ячейку памяти. 
```cpp
int* doubleValue(int a)
{
    int value = a * 3;
    return &value; // value возвращается по адресу здесь
} // value уничтожается здесь
```
Возврат по адресу часто используется для возврата динамически выделенной памяти обратно в caller. Здесь не возникнет никаких проблем, так как динамически выделенная память не выходит из области видимости в конце блока, в котором объявлена и всё ещё будет существовать, когда адрес будет возвращаться в caller.

#### Когда использовать?
- при возврате **динамически выделенной памяти**;
- при возврате **аргументов** функции, которые были **переданы по адресу**.

#### Когда НЕ использовать? 
- при возврате переменных, которые были **объявлены внутри** функции (используйте возврат по значению);
- при возврате большой **структуры или класса**, который был передан по ссылке (используйте возврат по ссылке).

### 3. По ссылке
Все то же самое, что и при возврате по адресу. Те же самые проблемы с уничтожением переменных созданных внутри ф-ции при выходе из нее. `Game& operator=( const Game& ) = delete;`   

#### Перегрузка оператора   
Тут есть **lhs** (left hand side) и **rhs** (right hand side): lhs += rhs; 
```cpp
Smth& operator+= ( const Smth& rhs)
{
	return *this = *this.x + rhs.x; //тут *this указывает на lhs
}
```

#### Когда использовать?
- при возврате **параметра-ссылки**;
- при возврате элемента **массива, который был передан в функцию**;
- при возврате большой **структуры или класса**, который не уничтожается в конце функции (например, тот, который был передан в функцию).
- при **перегрузке операторов**;
- для **function chaining**;

#### Когда НЕ использовать? 
- при возврате переменных, которые были **объявлены внутри** функции (используйте возврат по значению);
- при возврате **стандартного массива или указателя** (используйте возврат по адресу).


## inline (встроенные ф-ции)
Одним из главных недостатков использования функций является то, что каждый раз, когда она вызывается, происходит расход ресурсов, что влияет на производительность программы. Это связано с тем, что ЦП должен хранить адрес текущей команды (инструкции или стейтмента), которую он выполняет (чтобы знать, куда нужно будет вернуться позже) вместе с другими данными. Затем точка выполнения перемещается в другое место программы. Дальше все параметры функции должны быть созданы и им должны быть присвоены значения. И только потом, после выполнения функции, точка выполнения возвращается обратно. Код, написанный «на месте» (т.е. внутри main()), выполняется значительно быстрее.

При этом, чем короче ф-ция и чем чаще ее вызывают, тем больше потери в памяти. При компиляции вашего кода, все **встроенные функции (ключевое слово `inline`)** раскрываются «на месте», то есть вызов функции заменяется копией содержимого самой функции. Например,
```cpp
inline int max(int a, int b)
{
    return a < b ? b : a;
}
// вместо этого 
int main()
{
    std::cout << max(7, 8) << '\n';
    std::cout << max(5, 4) << '\n';
    return 0;
}
// компилятор увидит это
int main()
{
    std::cout << (7 < 8 ? 8 : 7) << '\n';
    std::cout << (5 < 4 ? 4 : 5) << '\n';
    return 0;
}
```

- В месте вызова inline ф-ции должно быть известно ее определение. Те нельзя разбить объявление и определение такой ф-ции на .cpp и .h файлы. В связи с этим, **inline ф-ции обычно определяют прямо в .h файле**. 
- Все методы определенные внутри класса - это inline методы.
- Если в экземпляр inline ф-ции встречается несколько раз (например, код в разных компилируемых файлах), то на этапе линковки вибирается только одна, хотя компилируются все. 
- На самом деле, все современные компиляторы сами ставят `inline`, если это улучшает перфоманс. При том, компилятор может проигнорировать inline поставленный пользователем, если посчитате, что это не нужно. Таким образом, **не имеет смысла самому делать `inline`, так как компилятор знает лучше**.

## Function overloading (перегрузка ф-ций)
**Перегрузка функций** — это особенность в C++, которая позволяет определять несколько функций с одним и тем же именем, но с разными параметрами.
```cpp
//  ок, перегруженные ф-ции
int subtract(int a, int b);
int subtract(int a, int b, int c);
int subtract(double a, double b);

/* не ок, разницы в возвращаемом значении недостаточно, 
чтобы компилятор однозначно определил перегруженную ф-цию */
int getRandomValue();
double getRandomValue();

/* не ок, псевдоним на самом деле имеет все тот же тип данных, что и оригинал,
поэтому компилятор не может однозначно определить перегруженную ф-цию */
typedef char *string;
void print(string value);
void print(char *value);
```
Cтоит отметить, что параметры по умолчанию НЕ относятся к параметрам, которые учитываются при определении уникальности функции. Следовательно, следующее не допускается:
```cpp
// не ок
void printValues(int a);
void printValues(int a, int b=15);

// ок
void print(std::string string);
void print(char ch=' ');
/*Если пользователь вызовет просто print() (без параметров), 
то выведется пробел, что будет результатом выполнения  print(' ').*/
```

### Порядок сравнения параметров 
Как происходит сравнение поэтапно C++ пытается найти точное совпадение:
1.  C++ пытается найти точное совпадение. Это тот случай, когда фактический аргумент точно соответствует типу параметра одной из перегруженных функций. Например:
```cpp
void print(char *value);
void print(int value);
 
print(0); // точное совпадение с print(int)
```
Хотя `0` может технически соответствовать и `print(char *)` (как нулевой указатель), но он точно соответствует `print(int)`. Таким образом, `print(int)` является лучшим (точным) совпадением.

2.  Если точного совпадения не найдено, то C++ пытается найти совпадение путём дальнейшего неявного преобразования типов (автоматическое преобразование, те в "соседа" и больший тип: `short` -> `int`, `float`->`double`, `char`->`int`, etc)
```cpp
void print(char *value);
void print(int value);
 
print('b'); // совпадение с print(int) после неявного преобразования
```
В этом случае, поскольку нет print(char), символ b конвертируется в тип int, который затем соответствует print(int).

3. Если неявное преобразование невозможно, то C++ пытается найти соответствие посредством стандартного преобразования. В стандартном преобразовании: 1) любой числовой тип будет соответствовать любому другому числовому типу, включая unsigned (например, int равно float), 2) enum соответствует формальному типу числового типа данных (например, enum равно float), 3) нуль (0) соответствует типу указателя и числовому типу (например, 0 как char * или 0 как float).
```cpp
struct Employee; // определение упустим
void print(float value);
void print(Employee value);
 
print('b'); // 'b' конвертируется в соответствие версии print(float)
```
В этом случае, поскольку нет `print(char)` (точного совпадения) и нет `print(int)` (совпадения путём неявного преобразования), символ `b` конвертируется в тип `float` и сопоставляется с `print(float)`. *Так как все стандартные преобразования считаются равными, ни одно из них не считается выше остальных по приоритету* -> до этого лучше не доводить потому, что результаты непредсказуемы.

4. C++ пытается найти соответствие путём пользовательского преобразования. Например, мы можем создать класс W и в нём определить пользовательское преобразование в тип int:
```cpp
class W; // с пользовательским преобразованием в тип int
 
void print(float value);
void print(int value);
 
W value; // объявляем переменную value типа класса W
print(value); // value конвертируется в int и, следовательно, соответствует print(int)
```
Хотя value относится к типу класса W, но, поскольку тот имеет пользовательское преобразование в тип int, вызов print(value) соответствует версии print(int).

**!** Поскольку все стандартные и пользовательские преобразования считаются равными, то, если вызов функции соответствует нескольким кандидатам посредством стандартного или пользовательского преобразования, результатом будет **неоднозначное совпадение (Ambiguous matches)** (т.е. несколько совпадений). Например,
```cpp
void print(unsigned int value);
void print(float value);
// неоднозначности можно избежать, если использовать static_cast при передаче аргумента
 
print('b');
print(3.14159);
```
- В случае с `print('b')` C++ не может найти точного совпадения. Он пытается преобразовать `b` в тип `int`, но версии `print(int)` тоже нет. Используя стандартное преобразование, C++ может преобразовать `b` как в `unsigned int`, так и во `float`. Поскольку все стандартные преобразования считаются равными, то получается два совпадения.    

- А вот с `print(3.14159)` всё несколько запутаннее: большинство программистов отнесут его однозначно к `print(float)`. Однако, помните, что по умолчанию все значения-литералы типа с плавающей запятой относятся к типу `double`, если у них нет окончания `f`. 3.14159 — это тип `double`, а версии `print(double)` нет. Следовательно, мы получаем ту же ситуацию, что и в предыдущих случаях — неоднозначное совпадение (два варианта).

## Адрес ф-ции и указатель на нее
Указатели на функции полезны, прежде всего, когда вы хотите хранить функции в массиве (или в структуре) или когда вам нужно передать одну функцию в качестве аргумента другой функции.     

Ф-ции это особый тип данных и они имеют свой адрес в памяти. Например, ф-ция `int boo(int a)` имеет тип данных ф-ции принимающей int и возвращающей int. Ф-ция `int boo_two()` имеет тип данных ф-ции не принимающей ничего и возвращающей int. Таким образом, **ф-ции - это l-value**. Отсда следуют, что у них есть однозначный адрес (где хранится их код) и на этот адрес можно создать указатель.   

Вызов ф-ции осуществляется через оператор `()`, а имена функций являются указателями на функции. Вызов происходит при действии оператором `()` на указатель (`имя_ф-ции()`). При вызове ф-ции CPU переходит по ее адресу и выполняет код внутри ф-ции, а потом возвращается назад на точку после вызова.
```cpp
int boo() 		// код функции boo находится в ячейке памяти 002B1050
{
    return 7;
}
 
int main()
{
    boo(); 		// переходим к адресу 002B1050
    std::cout << boo;	/* мы хотим вызвать boo(), но вместо этого мы просто выводим адрес, где хранится boo.
    Выведет: 002B1050 (хотя компилятор может сам конвертировать во что-то другое*/
    return 0;
}
```
Тк у ф-ции есть адерес, то для него можно создать указатель. При этом указатель должен точно соответствовать типу ф-ции. Если указатель не const, то ему можно присвоить адрес другой ф-ции такого же типа (те которая принимает такие же аргуметы по типу, кол-ву и возвращает такое же значение):
```cpp
// fcnPtr - это указатель на функцию, которая не принимает никаких аргументов и возвращает целочисленное значение
int (*fcnPtr)();
// fcnPtr_two -  константный указатель на такую же ф-цию
int (*const fcnPtr_two)();
/* не путать int const (*fcnPtr_two)(); Это указатель на функцию, которая возвращает const int. */
int (*fcnPtr3)(int); // это указатель на функцию, которая принимает int и возвращает int
```
Скобки вокруг `*fcnPtr` необходимы для соблюдения приоритета операций, в противном случае int `*fcnPtr()` будет интерпретироваться как предварительное объявление функции `fcnPtr`, которая не имеет параметров и возвращает указатель на целочисленное значение.    

### Инициализация и присвоение ф-ции указателем
```cpp
 int (*fcnPtr)() = fu; 	// fcnPtr указывает на функцию fu
 fcnPtr = bar;		// fcnPtr теперь указывает на функцию bar (имеет такой же тип данных, что и fu)
// не путать с 
fcnPtr = doo();		// fcnPtr - присваивает возвращаемое значение ф-ции doo, а не адрес
```
Можно вызывать ф-ции разыименовывая указатель на них. Можно раименовать явно и неявно. По сути, имя любой ф-ции - это указатель на нее, а при вызвое (через оператор `()`) он неявно разыменовывается.
```cpp
int boo(int a)
{
    return a;
}
 
int main()
{
    int (*fcnPtr)(int) = boo; // присваиваем функцию boo для fcnPtr 
    (*fcnPtr)(7); // вызываем функцию boo(7), через явное разыменование fcnPtr
    fcnPtr(7);	  // вызываем функцию boo(7), через неявное разыменование fcnPtr
    return 0;
}
```
Важно, что указатель это compile-time const, а **параметры по умолчанию** - это run-time const. Поэтому при вызове ф-ции через разименование указателя пораметры по умолчанию **не будут работать**.

### Передача ф-ции в качестве параметра ф-ции
Возможность передать ф-цию в качетсве параметра - это основная цель создания указателя на ф-цию. Например, при создании ф-ции с алгоритмом сортировки (`void selectionSort(int *array, int size)` ей можно передать ф-цию задающую способ сравниния чисел при сортироке (напр, `descending()` - по убыванию, `ascending()` - по возрастанию, `even_first()` - четные будут впереди и тд):
```cpp
void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int))
{
/* опустим тело программы. Суть в том, что сюда передается ф-ция comparisonFcn, которая будет 
сравнивать 2 числа опреденным образом */
	 if (comparisonFcn(array[bestIndex], array[currentIndex])) // СРАВНЕНИЕ ВЫПОЛНЯЕТСЯ ЗДЕСЬ
	 	// если результат true, то двигаем число вверх по списку
}

bool ascending(int a, int b)
{
    return a > b; // меняем местами, если первый элемент больше второго
}
 
bool descending(int a, int b)
{
    return a < b; // меняем местами, если второй элемент больше первого
}
// пример многофункционального использования
int main()
{
    int array[8] = { 4, 8, 5, 6, 2, 3, 1, 7 };
 
    // Сортируем массив в порядке убывания, используя функцию descending()
    selectionSort(array, 8, descending);
    printArray(array, 8);
 
    // Сортируем массив в порядке возрастания, используя функцию ascending()
    selectionSort(array, 8, ascending);
    printArray(array, 8);
 
    return 0;
}
```
Тут можно выбрать параметр по-умолчанию для функции (те если пользователь не выбрал ф-цию отбора сам, то по дефолту будет, например, `ascending()`):
```cpp
void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int) = ascending)
//те указатель по дефолту указывает на адрес ф-ции ascending)
```

### Псевдонимы для указателей на ф-ции
Синтаксис указателей на ф-ции достаточно уродлив, поэтому имеет смысл использовать псевдонимы:
```cpp
// если такая ф-ция 
bool validate(int a, int b, bool (*fcnPtr)(int, int));

// два способа сделать спевдоним для bool (*fcnPtr)(int, int)
typedef bool (*validateFcn)(int, int); // validateFcn - псевдоним для типа данных bool(*)(int, int)
using validateFcn = bool(*)(int, int); // тоже самое (для C++11)

// теперь вызов ф-ции 
bool validate(int a, int b, validateFcn pfcn);
```

### std::function
В C++11 ввели более удобный синтаксис для работы с указателями на ф-ции: `std::function<bool(int, int)> fcn;` - указатель (имя fcn) на ф-цию принимающую два int и возвращающую bool.
```cpp
std::function<int()> fcnPtr; // объявляем указатель на функцию, который возвращает int и не принимает никаких параметров
fcnPtr = doo; // fcnPtr теперь указывает на функцию doo
std::cout << fcnPtr(); // вызываем функцию, как обычно
```

----

## Эллипсис (ellipsis) аргумент
Функции, использующие эллипсис, выглядят следующим образом:
`тип_возврата имя_функции(список_аргументов, ...)`   
- `список_аргументов` — это один или несколько обычных параметров функции. Обратите внимание, функции, которые используют эллипсис, должны иметь по крайней мере один параметр, который не является эллипсисом.
- `...` - это эллипсис (англ. «ellipsis«), в C++ всегда должен быть последним параметром в функции. О нём можно думать, как о массиве, который содержит любые другие параметры, кроме тех, что указаны в списке_аргументов.
```cpp
#include <iostream>
#include <cstdarg> // требуется для использования эллипсиса
 
// Эллипсис должен быть последним параметром
// Переменная count - это количество переданных аргументов
double findAverage(int count, ...)
{
    double sum = 0;
 
    // Мы получаем доступ к эллипсису через va_list, поэтому объявляем переменную этого типа
    va_list list;
 
    // Инициализируем va_list, используя va_start. Первый параметр - это список, который нужно инициализировать
    /* Второй параметр - это последний параметр, который не является эллипсисом, 
    	в этом случаи это int, который указывает сколько параметров было переданов в эллипс */
    va_start(list, count);
 
    // Перебираем каждый из аргументов эллипсиса 
    for (int arg=0; arg < count; ++arg)
         // Используем va_arg для получения параметров из эллипсиса
         // Первый параметр - это va_list, который мы используем
         // Второй параметр - это ожидаемый тип параметров
         sum += va_arg(list, int);
 
    // Выполняем очистку va_list, когда уже сделали всё необходимое 
    va_end(list);
 
    return sum / count;
}
 
int main()
{
    std::cout << findAverage(4, 1, 2, 3, 4) << '\n';
    std::cout << findAverage(5, 1, 2, 3, 4, 5) << '\n';
}
```
Это опасный подход, тк он не контролирует: 1)кол-во получаемых параметров, 2)их тип. То есть если программа предполагает, что пользователь передаст 5 int, а он передал 2 int и 2 double - too bad! Коспилятор это не поймет и получится мусор.   
Если 2 способа контролировать кол-во и тип параметров:
1. Тк необходимо передать хотя бы один параметр в начале, то лучше чтобы это был `int count`, который говорит сколько ожидается параметров в эллипсисе. При этом лучше, чтобы все параметры эллипсиса были одного типа, чтобы не запутаться.
2. Можно передать строку декодер в качестве первого параметра:
```cpp
#include <iostream>
#include <string>
#include <cstdarg> // требуется для использования эллипсиса
 
// Эллипсис должен быть последним параметром 
double findAverage(std::string decoder, ...)
{
	double sum = 0;
 
	// Мы получаем доступ к эллипсису через va_list, поэтому объявляем переменную этого типа
	va_list list;
 
	// Инициализируем va_list используя va_start.  Первый параметр - это список, который необходимо инициализировать
	// Второй параметр - это последний параметр, который не является эллипсисом
	va_start(list, decoder);
 
	int count = 0;
	// Бесконечный цикл
	while (1)
	{
		char codetype = decoder[count];
		switch (codetype)
		{
		default:
		case '\0':
			// Выполняем очистку va_list, когда уже сделали всё необходимое
			va_end(list);
			return sum / count;
 
		case 'i':
			sum += va_arg(list, int);
			count++;
			break;
 
		case 'd':
			sum += va_arg(list, double);
			count++;
			break;
		}
	}
}
	
 
int main()
{
	std::cout << findAverage("iiii", 1, 2, 3, 4) << '\n';
	std::cout << findAverage("iiiii", 1, 2, 3, 4, 5) << '\n';
	std::cout << findAverage("ididdi", 1, 2.2, 3, 3.5, 4.5, 5) << '\n';
}
```
В этом примере мы передаём строку, в которой указывается как количество передаваемых аргументов, так и их типы (i = int, d = double). Таким образом, мы можем работать с параметрами разных типов. Однако следует помнить, что если число или типы передаваемых параметров не будут в точности соответствовать тому, что указано в строке-декодере, то могут произойти плохие вещи.

