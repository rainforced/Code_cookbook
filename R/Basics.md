# Общее
- Конец операции. Конец строки - это конец операции. Также, `;` отделяет конкц операции:
    ```r
    > a <- c(1,2,3,4) # операция 1
    > a # операция 2
    [1] 1 2 3 4
    > a <- c(1,2,3,4); a # операция 1 и 2
    [1] 1 2 3 4
    ```
- Оператор присвоения `<-` или `->` работает, как указатель направления потока (т.е. присваивает переменной слева или справа, соответственно):
    ```r
    x <- 4 # основной оператор присвоения 
    foo(bar = x) # оператор присвоения для аргументов
    ```
    - `<<-` оператор присвоения, который создает глобальную переменную (можно создать из локальной области видимости).
- Области видимости тут как в питоне: внутри ф-ций локальная и тд. Ограничения и предостерижения, соответственно, такие же.
- Сравнение чисел типа double
    ```r
    > 0.05 + 0.1 == 0.15
    [1] FALSE
    > all.equal(0.05 + 0.1, 0.15) 
    [1] TRUE
    ```
    `all.equal(x, y)` - специальная ф-ция для сравнения double чисел. Она позволяет небольшую погрешность, поэтому нет проблем сравнивать два числа типа double.

# Типы данных
В R типы данных называются **моды (modes)**. Бывают следующие моды:
    1. logical
    2. int
    3. double/numeric
    4. Complex
    5. Character
    6. raw (байтовые строки)

Существуют следующие виды структур:
- **vector** - непрерывный массив с одним типом данных/модой (на нем же основаны скаляры и строки)
- **matrix** (на самом деле это тоже вектор. Матрица хранится в лианиризованном виде в векторе. Строки и столбцы реализованы через индексы, которые считаются по правилам матрицы). Матричное произведение: `%*%`.
- **lists** - класс-контейнер, хранящий разные типы данных. Нужен в основном, чтобы возвращать красивые и удобные outputs от разных ф-ций. Например, мы сделали график, а нам возвращается list, где все данные о графике.
- **DataFrame** - это list, в каждой ячейке которого лежит vector с определенными данными (если точнее, то там лежит указатель на вектор).
- **class** - вообще говоря, все в R - это класс, включая все структуры выше (у каждого из них свой набор дефолтных атрибутов). 

## NA, NaN и NULL
В R есть три похожих ключевых слова, `NA`, `NaN` и `NULL`. Они различаются по смысловой нагрузке. 

- `NA` - это пропущенное значение ("not available"). Например, респондент не ответил на все вопросы предложенной анкеты, или данные с метеостанции за определённый период потерялись из-за сбоя оборудования. NA в этом случае обозначает, что эти данные существуют и имеют смысл, но их не удалось узнать.
- `NaN` - "not-a-number" -- результат недопустимой арифметической операции, например 0/0 или Inf - Inf.
- `NULL` - отсутствие объекта, "пустота". Применяется в тех случаях, когда объект действительно не существует, не может иметь осмысленного значения.   

Для проверки значений есть три функции: `is.na`, `is.nan` и `is.null`, соответственно.

## Приведение типов
### Узнать тип и структура класса
- `typeof(x)` - возвращает тип данных   
- `is.<type>(x)` - возвращает bool проверки типа данных
    ```r
    > is.double(4.0)
    [1] TRUE
    > is.double(4)
    [1] TRUE
    > is.character(4)
    [1] FALSE
    ```
- `class(x)` - возвращает моду (если это структура с одной модой) или вид структуры (если - несколько мод). 
    ```r
    > v <- 1:10
    > class(v)
    [1] "integer" # мода вектора
    > x <- data.frame(v)
    > class(x)
    [1] "data.frame" # вид структуры
    ```
- `str(x)` - *structure* - выдает описание класса (атрибуты и тд) в красивом виде

### Естественное приведение типов
**logic -> int -> double/numeric -> char**       
Это последовательность автоматического преобразования типов. Т.е., если у нас сначала есть вектор int и мы к нему добавили double, то вектор автоматически преобразуется в double. Но не наоборот, т.е. от double к int автоматического преобразования не может быть. Тип char - это *самый вместительный* тип, преобразования идут только к нему.

### Принудительное приведение
- `as.<type>()` - принудительное преобразование 
    ```r
    > a = 4
    > as.double(a)
    [1] 4 
    > typeof(as.double(a))
    [1] "double"
    > as.character(a)
    [1] "4"
    ```
- Если для каког-то элемента тип данных сужается, то будет выведено предупреждение, а элемент будет преобразован с потерей данных. Если преобразование невозможно, то тип будет `NA`.
    ```r
    > as.integer(1.5)
    [1] 1
    > as.integer('a')
    [1] NA
    Warning message:
    NAs introduced by coercion 
    ```

# Batch and interactive modes
## Interactive mode 
- `help('foo')`, `?'foo'` - помощь. Еще: `help.search('foo')`.
- `example("foo")` - выдаст развернутый пример использования ф-ции.
- `ctrl + l` - очистить консоль в rstudio
- `ls()` - показать все переменные окружения
- удадение:
    ```r
    > rm(a) #удалить переменную a
    > rm(list = ls()) #удалить все переменные окружения
    ```
## Batch mode 
Запуск скрипта из консоли:
```bash
$ R CMD BATCH z.R 
```
где z.R - название скрипта

## Startup and shutdow
- R позволяет сохраненять результаты и историю операций interactive modes.    
- Также можно настроить скрипт, который должен выполнятся при каждом запуске rstudio.     

Подробнее об этом в "Art of R" Chapter 1.6.

# Операторы
```r
#Operator 	Description
< 	#less than
<= 	#less than or equal to
> 	#greater than
>= 	#greater than or equal to
== 	#exactly equal to
!= 	#not equal to
!x 	#Not x
x | y 	#x OR y
x & y 	#x AND y
isTRUE(x) 	#test if X is TRUE 
```

# Полезные ф-ции
- `sort(v, decreasing = FALSE, ...)` - сортировка вектора.
- `unique(v)` - возвращает вектор с уникальными значениями.

## Последовательности
- **целочисленная последовательность**
    ```r
    > 5:10
    [1]  5  6  7  8  9 10
    ```
- **seq** - любая последовательность
    ```r
    > seq(1, 5, by = 1.5) # by - указываем шаг
    [1] 1.0 2.5 4.0
    > seq(1, 5, by = 1)
    [1] 1 2 3 4 5
    > seq(1, 5, length.out = 6) # можно указать какой длинны вектор должен быть, а шаг будет вычислен автоматически
    [1] 1.0 1.8 2.6 3.4 4.2 5.0
    > seq(1, 5, length = 6) # можно опусть вызов поля out, просто указав length
    [1] 1.0 1.8 2.6 3.4 4.2 5.0
    ```

# Управление потоками
## if else
```r
if (sqrt(1.5) > 2) {
  print("more")
} else { # важно не разрывать скобки ...} else {...
  print("less")
}
```
т.к. новая операция в R начинается с новой строки, то важно не разрывать `...} else {...`. Т.е. else должен быть на одной строке со своей скобкой (т.е. `{...` ) и скобкой от if (т.е. `...}` ) 
## ifelse
```r
ifelse(expression, to_do_if_TRUE, to_do_if_FALSE)
```
Это векторизуемый if-else - т.е. он поэлементно применяется к вектору. 
```r
> ifelse(c(0,1,1,1,0), 'yes', 'no')
[1] "no"  "yes" "yes" "yes" "no" 
> ifelse(runif(8) > 0.5, 'орел', 'решка')
[1] "решка" "орел"  "орел"  "орел"  "орел"  "решка" "орел"  "решка"
```

### Вложенные ifelse
```r
> ifelse(x > 2/3, "камень", ifelse(x > 1/3, "ножницы", "бумага"))
[1] "ножницы" "камень"  "ножницы" "бумага"  "камень"  "бумага"  "бумага"  "ножницы"
```

## switch
```r
switch (expression, list)
```
Here, the `expression` is evaluated and based on this value, the corresponding item in the `list` is returned. If the value evaluated from the `expression` matches with more than one item of the `list`, `switch()` function returns the first matched item.    

Примеры:
1.  ```r
    > switch(2,"red","green","blue")
    [1] "green"
    > switch(1,"red","green","blue")
    [1] "red"
    ```
    Если ничто не соответсвует expression, то возвращается NA:
    ```r
    > x <- switch(4,"red","green","blue")
    > x
    NULL
    > x <- switch(0,"red","green","blue")
    > x
    NULL
    ```
2.  ```r
    > switch("color", "color" = "red", "shape" = "square", "length" = 5)
    [1] "red"
    ```
3. Более полезный пример: 
   ```r
    # эта ф-ция со switch
    test1 <- function(type) {
    switch(type,
            mean = 1,
            median = 2,
            trimmed = 3)
    }
    # это то же самое, что и ф-ция ниже
    test2 <- function(type) {
    if (type == "mean") 1
    else if (type == "median") 2
    else if (type == "trimmed") 3
    }
    # пример вызова
    > x <- rcauchy(10)
    > centre(x, "mean")
    [1] 0.8760325
    > centre(x, "median")
    [1] 0.5360891
    > centre(x, "trimmed")
    [1] 0.6086504
   ```
### template для switch
```r
AA = 'foo'
switch(AA, 
foo={
  # case 'foo' here...
  print('foo')
},
bar={
  # case 'bar' here...
  print('bar')    
},
{
   print('default')
}
)
```
# Циклы
- `break` - выход из цикла
- `next` - аналог *continue* - т.е. проскакивает 1 итерацию.
## while
```r
x <- 10^5
while(x > 100)
{
  print(x)
  x <- x/2
}
# вывод
[1] 1e+05
[1] 50000
[1] 25000
[1] 12500
[1] 6250
[1] 3125
[1] 1562.5
[1] 781.25
[1] 390.625
[1] 195.3125
```
- проверка условия выполняется до входа в цикл
## repeat
```r
x <- 10^5
repeat
{
  print(x)
  x <- x/2
  if (x<100) break
}
```
- бесконеный цикл без проверки условия для выхода. Поэтому его нужно прописать самому (т.е. прописать `break`). 

## for 
`for` - это итерация по вектору (как в питоне). Т.е. условие выхода из цикла - конец вектора.   
Примеры:
1.  ```r
    x <- 1:10
    for (n in x) {
    if (n %% 2 == 1) print(n)
    }
    # вывод
    [1] 1
    [1] 3
    [1] 5
    [1] 7
    [1] 9
    ```
2.  ```r
    > for (l in 'abcd') print(l)
    [1] "abcd"
    > for (l in c('a', 'b', 'c')) print(l)
    [1] "a"
    [1] "b"
    [1] "c"
    ```
Можно сделать цикл и в индексной форме. Это может понадобиться, если надо найти индекс определенного элемента:
3.  ```r
    x <- 1:10
    for (i in 1:length(x)) {
    if (x[i] %% 2 == 1) print(x[i])
    }
    # вывод
    [1] 1
    [1] 3
    [1] 5
    [1] 7
    [1] 9
    ```
# Garbage Collection (GC)
Работа с памятью в R реализована аналогично питону. Так, у каждого объекта есть счетчик ссылок. Если на объект никто не ссылается, GC удаляет объект и освобождает память. Например, когда *анонимная ф-ция* завершила работу, на нее никто не ссылается -> GC ее удаляет.