# Matrix
**Matrix** - это линеаризованный (по столбцам) вектор с одним типом данных, у которого есть атрибуты: кол-во строк и кол-во столбцов. Чтобы привести этот вектор к матричному виду, просто делается пересчет идексов исходя из кол-ва строк и стобцов.    

Для объявления матрицы передаелся вектор и кол-во столбцов и/или строк:
```r
> m <- matrix(1:10, nrow = 2) # указали только nrow
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10
> n <- matrix(1:10, ncol = 2) # указали только ncol
> n
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10
```
Если нужно, чтобы матрица формировалась не по столбцам, а по рядам, то указать `byrow = TRUE`:
```r
> m <- matrix(1:10, nrow = 2, byrow = TRUE)
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    6    7    8    9   10
```
Размеры матрицы:
```r
> dim(m) # row, col
[1] 2 5
> c(nrow(m), ncol(m))
[1] 2 5
```
Можно менять размерность матрицы, изменив атрибут `dim`. Также можно лианеризовать матрицу занулив `dim`:
```r
> m <- matrix(1:10, nrow = 2, byrow = TRUE)
> dim(m)
[1] 2 5
> dim(m) <- NULL # обнулили размерность матрицы
> m
 [1]  1  6  2  7  3  8  4  9  5 10 # матрица стала вектором
> dim(m) <- c(2,5) # снова стала матрицей
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    6    7    8    9   10
```

## Индексирование 
Пусть у нас есть матрица:
```r
> m <- matrix(1:10, nrow = 2, byrow = TRUE)
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    6    7    8    9   10

```
**положительные индексы**:
```r
> m[2,] # 2nd row
[1]  6  7  8  9 10
> m[,2] # 2nd col
[1] 2 7
> m[1,2] # 1st row, 2nd col
[1] 2
```
**отрицательные индексы** - исключение ряда и/или столбца:
```r
> m[-1,] # матрица без 1го ряда
[1]  6  7  8  9 10
> m[,-2] # матрица без 2го столбца
     [,1] [,2] [,3] [,4]
[1,]    1    3    4    5
[2,]    6    8    9   10
> m[-1,-2] # матрица без 1го ряда и 2го стобца
[1]  6  8  9 10
```
**векторное индексирование**:
```r
> m[1:2, 2:4] # вернет 1-2 ряды и 2-4 стобцы
     [,1] [,2] [,3]
[1,]    2    3    4
[2,]    7    8    9
```
**логическое индексирование**
- `m > 5` - логическая матрица, построенная по условию
- `m[m > 5]` - вектор с элементами, отобранными по условию   

Например:   
```r
> m <- matrix(1:10, nrow = 2)
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10
> m > 5
      [,1]  [,2]  [,3] [,4] [,5]
[1,] FALSE FALSE FALSE TRUE TRUE
[2,] FALSE FALSE  TRUE TRUE TRUE
> m[m>5]
[1]  6  7  8  9 10
```

## Именованные матрицы
```r
> m <- matrix(1:6, nrow = 2)
> m
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
> rownames(m) <- c("row1","row2") # название строк
> colnames(m) <- paste0("col", 1:3) # название столбцов
> m
     col1 col2 col3
row1    1    3    5
row2    2    4    6
> colnames(m) <- paste0("col", c("A","B","C")) 
> m
     colA colB colC
row1    1    3    5
row2    2    4    6
```
- `paste0(v1, v2, ...)` - комбинирует элементы переданных векторов и формирует строковый вектор

## Присоединение матриц
```r
> m <- matrix(1:6, nrow = 2)
> n <- matrix(10:15, nrow = 2)
> rbind(m, n) #строки
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
[3,]   10   12   14
[4,]   11   13   15
> cbind(m, n) #столбцы
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5   10   12   14
[2,]    2    4    6   11   13   15
```

## apply
Общий вид ф-ции:
```r
apply(matrix, index, function)
```
Ф-ция применяется по-элементно к матрице. Параметры `index`:
- `1` - ко всем элементам каждого из *рядов*
- `2` - ко всем элементам каждого из *столбцов*
- `1:2` - к каждому элементу матрицы

Например:
```r
> m <- matrix(1:25, nrow = 5)
> f <- function(x) sum(x^2)
> apply(m, 1, f) # по-строчно
[1]  855  970 1095 1230 1375
> apply(m, 2, f) # по-стобцово
[1]   55  330  855 1630 2655
> apply(m, 1:2, f) # по-элементно
     [,1] [,2] [,3] [,4] [,5]
[1,]    1   36  121  256  441
[2,]    4   49  144  289  484
[3,]    9   64  169  324  529
[4,]   16   81  196  361  576
[5,]   25  100  225  400  625
# передадим анонимную ф-цию
> apply(m, 1:2, function(x) if (x>13) x else 13)
     [,1] [,2] [,3] [,4] [,5]
[1,]   13   13   13   16   21
[2,]   13   13   13   17   22
[3,]   13   13   13   18   23
[4,]   13   13   14   19   24
[5,]   13   13   15   20   25
```


## Арифметика
Тут работают все те же правила арифметики векторов - recycling, vectorization
```r

```

## Специальные ф-ции
- `rowSums()` и `colSums()` - считают сумму членов ряда/столбца
- `rowMeans()` и `colMeans()` - считают среднее членов ряда/столбца
```r
> m <- matrix(1:25, nrow = 5)
> rowSums(m)
[1] 55 60 65 70 75
> colSums(m)
[1]  15  40  65  90 115
> rowMeans(m)
[1] 11 12 13 14 15
> colMeans(m)
[1]  3  8 13 18 23
```

# list
Список это массив, хранящий сслыки на другие объекты. Таким образом, список в R похож на питон - т.е. это массив хранящий разные типы данных.   

Нужен он в основном для красивой упаковки сложных данных. Например, результутато построения графика может быть картинка, коэфиценты прямой, значения дисперсии, точки по фита и тд - все это пакуется в список и возвращается как результат операции. 

```r
> list(a = 1, b = 2, "three" = 3, 4, list(1:3))
$a
[1] 1

$b
[1] 2

$three
[1] 3

[[4]]
[1] 4

[[5]]
[[5]][[1]]
[1] 1 2 3
```
- именнованные элементы
- вложенные списки
- `[[4]]` - так обозначается неименованный элемент списка

## vector в list и обратно
Вектор логично конвертирутеся в одно-элементный список. Обратное преобразование, зачастую, не имеет смысла. Однако, если имеет, то его можно сделать с помощью `unlist()`:
```r
> v <- 1:6
> list(v)
[[1]]
[1] 1 2 3 4 5 6

> l <- list(v) # vector -> list
> l
[[1]]
[1] 1 2 3 4 5 6

> v <- unlist(l) # list -> vector
> v
[1] 1 2 3 4 5 6
```

## Индексирование 
Пусть у нас есть следующий список:
```r
> l <- list(a = 1, "two" = 2, 3, list(1:3), data.frame())
> l # содержание списка
$a
[1] 1

$two
[1] 2

[[3]]
[1] 3

[[4]]
[[4]][[1]]
[1] 1 2 3


[[5]]
таблица данных с 0 колонок и 0 строками
```
### Через едининые скобки `[]`
Возвращает подсписок. Работает по правилами индексирования векторов
```r
> l[1:2] # срез 1-2
$a
[1] 1

$two
[1] 2

#----------------#
> l["two"] # через имя
$two
[1] 2

#----------------#
> l[length(l)] # последний элемент
[[1]]
таблица данных с 0 колонок и 0 строками

> l[-length(l)] # все кроме послднего
$a
[1] 1

$two
[1] 2

[[3]]
[1] 3

[[4]]
[[4]][[1]]
[1] 1 2 3

#----------------#
> l[c(1, 3, 5)] # индексирование вектором
$a
[1] 1

[[2]]
[1] 3

[[3]]
таблица данных с 0 колонок и 0 строками

#----------------#
> l[c(T, F)] # логическим вектором 
[1] 1

[[2]]
[1] 3

[[3]]
таблица данных с 0 колонок и 0 строками
# Тут с(T, F) расширяется до (T, F, T, F, T) и работает как логическая маска
```
### Через двойную скобку `[[]]`
Обращение к конкретному элементу. Возращает ссылку соответствующий объект:
```r
> l["two"] # ссылка на 2й вектор
$two
[1] 2

> l[[2]] # ссылка тоже на 2й вектор
[1] 2
> l[[length(l)]] # ссылка на DataFrame
таблица данных с 0 колонок и 0 строками
```

### Как полям объекта через разименование `$`
Если у элемента уникальное имя, можно обратиться через него. Возвращает элемент списка.
```r
> l$a # доступ к элементу a
[1] 1
> l$two # доступ к элементу two
[1] 2
> l$tw # тоже доступ к элементу two
[1] 2
> l$t # тоже доступ к элементу two
[1] 2
```
- При этом, если написание позволяет однозначно определить элемент, то необязательно писать имя полность (как в примере выше для `"two"`).